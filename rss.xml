<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[按太阳穴轮刮眼眶]]></title><description><![CDATA[佚树的个人博客]]></description><link>https://hrayd.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Mon, 02 Aug 2021 13:12:51 GMT</lastBuildDate><item><title><![CDATA[React核心原理浅析]]></title><description><![CDATA[1. JSX与虚拟DOM 我们从React官方文档开头最基本的一段Hello World代码入手: 很明显, 这段代码的意思是通过  方法将  包裹的JSX元素渲染到id为“root”的HTML元素上. 除了在JS…]]></description><link>https://hrayd.github.io/react/</link><guid isPermaLink="false">https://hrayd.github.io/react/</guid><pubDate>Sun, 18 Jul 2021 22:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;1. JSX与虚拟DOM&lt;/h1&gt;
&lt;p&gt;我们从React官方文档开头最基本的一段Hello World代码入手:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;ReactDOM&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;Hello, world!&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;h1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;root&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很明显, 这段代码的意思是通过 &lt;code class=&quot;language-text&quot;&gt;ReactDOM.render()&lt;/code&gt; 方法将 &lt;code class=&quot;language-text&quot;&gt;h1&lt;/code&gt; 包裹的JSX元素渲染到id为“root”的HTML元素上. 除了在JS中早已熟知的 &lt;code class=&quot;language-text&quot;&gt;document.getElementById()&lt;/code&gt; 方法外, 这段代码中还包含两个知识点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以 &lt;code class=&quot;language-text&quot;&gt;h1&lt;/code&gt; 标签包裹的JSX元素&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;ReactDOM.render()&lt;/code&gt; 方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而这两个知识点则对应着React中要解决的核心问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为何以及如何使用(JSX表示的)虚拟DOM?&lt;/li&gt;
&lt;li&gt;如何对虚拟DOM进行处理, 使其高效地渲染出来?&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1.1 虚拟DOM是什么? 为何要使用虚拟DOM?&lt;/h3&gt;
&lt;p&gt;虚拟DOM其实就是用JavaScript对象表示的一个DOM节点, 内部包含了节点的 &lt;code class=&quot;language-text&quot;&gt;tag&lt;/code&gt; , &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;children&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;为何使用虚拟DOM? 因为直接操作真实DOM繁琐且低效, 通过虚拟DOM, 将一部分昂贵的浏览器重绘工作转移到相对廉价的存储和计算资源上.&lt;/p&gt;
&lt;h3&gt;1.2 如何将JSX转换成虚拟DOM?&lt;/h3&gt;
&lt;p&gt;通过babel可以将JSX编译为特定的JavaScript对象, 示例代码如下:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// JSX&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; e &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;root&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;className&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;title&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;Title&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;h1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// babel编译结果(React17之前), 注意子元素的嵌套结构&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; e &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; React&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;token string&quot;&gt;&quot;div&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; id&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;root&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
	React&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
		&lt;span class=&quot;token string&quot;&gt;&quot;h1&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; className&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;title&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
		&lt;span class=&quot;token string&quot;&gt;&quot;Title&quot;&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// React17之后编译结果有所区别, 创建节点的方法由react导出, 但基本原理大同小异&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.3 如何将虚拟DOM渲染出来?&lt;/h3&gt;
&lt;p&gt;很明显, 虚拟DOM中包含了创建DOM所需的各种信息, 对于首次渲染, 直接依照这些信息创建DOM节点即可.&lt;/p&gt;
&lt;p&gt;但虚拟DOM的真正价值在于“更新”: 当一个list中的某些项发生了变化, 或删除或增加了若干项, 如何通过对比前后的虚拟DOM树, 最小化地更新真实DOM? 这就是React的核心目标.&lt;/p&gt;
&lt;h1&gt;2. React Diffing&lt;/h1&gt;
&lt;p&gt;“Diffing”即“找不同”, 就是解决上文引出的React的核心目标——如何通过对比新旧虚拟DOM树, 以在最小的操作次数下将旧DOM树转换为新DOM树.&lt;/p&gt;
&lt;p&gt;在算法领域中, 两棵树的转换目前最优的算法复杂度为 &lt;code class=&quot;language-text&quot;&gt;O(n**3)&lt;/code&gt; , n为节点个数. 这意味着当树上有1000个元素时, 需要10亿次比较, 显然远远不够高效.&lt;/p&gt;
&lt;p&gt;React在基于以下两个假设的基础上, 提出了一套复杂度为 &lt;code class=&quot;language-text&quot;&gt;O(n)&lt;/code&gt; 的启发式算法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不同类型(即标签名、组件名)的元素会产生不同的树;&lt;/li&gt;
&lt;li&gt;通过设置 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt; 属性来标识一组同级子元素在渲染前后是否保持不变.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在实践中, 以上两个假设在绝大多数场景下都成立.&lt;/p&gt;
&lt;h2&gt;2.1 Diffling算法描述&lt;/h2&gt;
&lt;h3&gt;不同类型的元素/组件&lt;/h3&gt;
&lt;p&gt;当元素的标签或组件名发生变化, 直接卸载并替换以此元素作为根节点的整个子树.&lt;/p&gt;
&lt;h3&gt;同一类型的元素&lt;/h3&gt;
&lt;p&gt;当元素的标签相同时, React保留此DOM节点, 仅对比和更新有改变的属性, 如className、title等, 然后递归对比其子节点.&lt;/p&gt;
&lt;p&gt;对于 &lt;code class=&quot;language-text&quot;&gt;style&lt;/code&gt; 属性, React会继续深入对比, 仅更新有改变的属性, 如color、fontSize等.&lt;/p&gt;
&lt;h3&gt;同一类型的组件&lt;/h3&gt;
&lt;p&gt;当组件的props更新时, 组件实例保持不变, React调用组件的 &lt;code class=&quot;language-text&quot;&gt;componentWillReceiveProps()&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;componentWillUpdate()&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;componentDidUpdate()&lt;/code&gt; 生命周期方法, 并执行 &lt;code class=&quot;language-text&quot;&gt;render()&lt;/code&gt; 方法.&lt;/p&gt;
&lt;p&gt;Diffing算法会递归比对新旧 &lt;code class=&quot;language-text&quot;&gt;render()&lt;/code&gt; 执行的结果.&lt;/p&gt;
&lt;h3&gt;对子节点的递归&lt;/h3&gt;
&lt;p&gt;当一组同级子节点(列表)的末尾添加了新的子节点时, 上述Diffing算法的开销较小; 但当新元素被插入到列表开头时, Diffing算法只能按顺序依次比对并重建从新元素开始的后续所有子节点, 造成极大的开销浪费.&lt;/p&gt;
&lt;p&gt;解决方案是为一组列表项添加 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt; 属性, 这样React就可以方便地比对出插入或删除项了.&lt;/p&gt;
&lt;p&gt;关于 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt; 属性, 应稳定、可预测且在列表内唯一(无需全局唯一), 如果数据有ID的话直接使用此ID作为 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt;, 或者利用数据中的一部分字段哈希出一个key值.&lt;/p&gt;
&lt;p&gt;避免使用数组索引值作为 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt;, 因为当插入或删除元素后, 之后的元素和索引值的对应关系都会发生错乱, 导致错误的比对结果.&lt;/p&gt;
&lt;p&gt;避免使用不稳定的key(如随机数), 因为每次渲染都会发生改变, 从而导致列表项被不必要地重建.&lt;/p&gt;
&lt;h2&gt;2.2 递归的Diffing&lt;/h2&gt;
&lt;p&gt;在1.2节中的虚拟DOM对象中可以得知: 虚拟DOM树的每个节点通过 &lt;code class=&quot;language-text&quot;&gt;children&lt;/code&gt; 属性构成了一个嵌套的树结构, 这意味着要以递归的形式遍历和比较新旧虚拟DOM树.&lt;/p&gt;
&lt;p&gt;2.1节的策略解决了Diffing算法的时间复杂度的问题, 但我们还面临着另外一个重大的性能问题——浏览器的渲染线程和JS的执行线程是互斥的, 这意味着DOM节点过多时, 虚拟DOM树的构建和处理会长时间占用主线程, 使得一些需要高优先级处理的操作如用户输入、平滑动画等被阻塞, 严重影响使用体验. &lt;/p&gt;
&lt;h3&gt;时间切片(Time Slice)&lt;/h3&gt;
&lt;p&gt;为了解决浏览器主线程的阻塞问题, 引出 &lt;strong&gt;时间切片&lt;/strong&gt; 的策略——将整个工作流程分解成小的工作单元, 并在浏览器空闲时交由浏览器执行这些工作单元, 每个执行单元执行完毕后, 浏览器都可以选择中断渲染并处理其他需要更高优先级处理的工作.&lt;/p&gt;
&lt;p&gt;浏览器中提供了 &lt;code class=&quot;language-text&quot;&gt;requestIdleCallback&lt;/code&gt; 方法实现此功能, 将待调用的函数加入执行队列, 浏览器将在不影响关键事件处理的情况下逐个调用.&lt;/p&gt;
&lt;p&gt;考虑到浏览器的兼容性以及 &lt;code class=&quot;language-text&quot;&gt;requestIdleCallback&lt;/code&gt; 方法的不稳定性, React自己实现了专用于React的类似 &lt;code class=&quot;language-text&quot;&gt;requestIdleCallback&lt;/code&gt; 且功能更完备的 &lt;code class=&quot;language-text&quot;&gt;Scheduler&lt;/code&gt; 来实现空闲时触发回调, 并提供了多种优先级供任务设置.&lt;/p&gt;
&lt;h3&gt;递归与时间切片&lt;/h3&gt;
&lt;p&gt;时间切片策略要求我们将虚拟DOM的更新操作分解为小的工作单元, 同时具备以下特性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可暂停、可恢复的更新;&lt;/li&gt;
&lt;li&gt;可跳过的重复性、覆盖性更新;&lt;/li&gt;
&lt;li&gt;具备优先级的更新.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于递归形式的程序来说, 这些是难以实现的. 于是就需要一个处于递归形式的虚拟DOM树上层的数据结构, 来辅助完成这些特性. &lt;/p&gt;
&lt;p&gt;这就是React16引入的重构后的算法核心——Fiber.&lt;/p&gt;
&lt;h1&gt;3. Fiber&lt;/h1&gt;
&lt;p&gt;从概念上来说, Fiber就是重构后的虚拟DOM节点, 一个Fiber就是一个JS对象.&lt;/p&gt;
&lt;p&gt;Fiber节点之间构成 &lt;strong&gt;单向链表&lt;/strong&gt; 结构, 以实现前文提到的几个特性: 更新可暂停/恢复、可跳过、可设优先级. &lt;/p&gt;
&lt;h2&gt;3.1 Fiber节点&lt;/h2&gt;
&lt;p&gt;一个Fiber节点就是一个JS对象, 其中的关键属性可分类列举如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结构信息(构成链表的指针属性)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;return: 父节点&lt;/li&gt;
&lt;li&gt;child: 第一个子节点&lt;/li&gt;
&lt;li&gt;sibling: 右侧第一个兄弟节点&lt;/li&gt;
&lt;li&gt;alternate: 本节点在相邻更新时的状态, 用于比较节点前后的变化, 3.3节详述&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组件信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tag: 组件创建类型, 如FunctionComponent、ClassComponent、HostComponent等&lt;/li&gt;
&lt;li&gt;key: 即key属性&lt;/li&gt;
&lt;li&gt;type: 组件类型, Function/Class组件的type就是对应的Function/Class本身, Host组件的type就是对应元素的TagName&lt;/li&gt;
&lt;li&gt;stateNode: 对应的真实DOM节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本次更新的props和state相关信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pendingProps、memoizedProps&lt;/li&gt;
&lt;li&gt;memoizedState&lt;/li&gt;
&lt;li&gt;dependencies&lt;/li&gt;
&lt;li&gt;updateQueue&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新标记&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;effectTag: 节点更新类型, 如替换、更新、删除等&lt;/li&gt;
&lt;li&gt;nextEffect、firstEffect、lastEffect&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优先级相关: lanes、childrenLanes&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.2 Fiber树&lt;/h2&gt;
&lt;p&gt;前文说到, Fiber节点通过 &lt;code class=&quot;language-text&quot;&gt;return&lt;/code&gt; , &lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;slibling&lt;/code&gt; 属性构成了单向链表结构, 为了与DOM树对应, 习惯上仍称其为“树”. &lt;/p&gt;
&lt;p&gt;如一棵DOM树:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;html&quot;&gt;&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
	&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;Title&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;h1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
	&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;section&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
		&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;h2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;Section&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;h2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
		&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;p&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;Content&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;p&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
	&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;section&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
	&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;footer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;Footer&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;footer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其 &lt;code class=&quot;language-text&quot;&gt;section&lt;/code&gt; 节点的Fiber可表示为:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; sectionFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	key&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;SECTION_KEY&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
	child&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; h2Fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
	sibling&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; footerFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; divFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
	alternate&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; oldSectionFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;  
	&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;otherFiberProps&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整体的Fiber结构:&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 351px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/b3457a432995dc057094ab9e3bb38373/7c2a6/DOM.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 79.74683544303798%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAABwklEQVQ4y5WU12oDUQxE9/9/y2D8YGxccO+9994mHAWZzWYdiECsb5E0M9J1MBgMhLdaLS0WC81mMz0eD2Gv10v/teB0Omk4HKpUKtnG4XDQ7Xb7mJA93/ffYQ9Go5FWq5V2u52KxaL2+33sxTiPRdjv95XNZo1uKpXS5XL5ge6vYO7CkC8OmKDT6Qi/Xq+aTqdar9dG+fl8mruxdzweLRCNz+ezMZvP5+r1eppMJmq32wo2m43wSqVigclkUrlczpJ3u11lMhnl83lbFwoFIRE6w4g9ktVqNWtqtVr9TujVQMAaFNAECcFU986HDYrENhoNi6WIacgG0BOJhB1EOxztfFTX5XL5XgdAhgqJoO1NCdt2u9X9fv84e+HJMIQMM5Q5ADaI6B5UOUO38Xhs80rTKO4yMWro5+gDDukwARgJaEI6nbbLJCmXy4aexDSARADhHmuPtYQkYKhxqvN1AyX6eFebzaY1jUDO0B0pkORN2bvpHhWdoQcNCEEc9yQp8n4pcSJ7QjoLXZCgL5TD44OO7MPC2QR/vVNoQol/I28WmjJmFEICCqAhxev1+m+E4TeMNuEBJjko6D6vCOSuNUaxL8UZzYzW8I5pAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;./DOM.png&quot;
        title=&quot;./DOM.png&quot;
        src=&quot;/static/b3457a432995dc057094ab9e3bb38373/7c2a6/DOM.png&quot;
        srcset=&quot;/static/b3457a432995dc057094ab9e3bb38373/c26ae/DOM.png 158w,
/static/b3457a432995dc057094ab9e3bb38373/6bdcf/DOM.png 315w,
/static/b3457a432995dc057094ab9e3bb38373/7c2a6/DOM.png 351w&quot;
        sizes=&quot;(max-width: 351px) 100vw, 351px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3.3 Fiber架构&lt;/h2&gt;
&lt;p&gt;基于Fiber构成的虚拟DOM树就是Fiber架构.&lt;/p&gt;
&lt;p&gt;在3.1节中我们介绍过, 在Fiber节点中有一个重要属性 &lt;code class=&quot;language-text&quot;&gt;alternate&lt;/code&gt; , 单词意为“备用”. &lt;/p&gt;
&lt;p&gt;实际上, 在React中最多会同时存在两棵Fiber树:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前显示在屏幕上、已经构建完成的Fiber树称为“Current Fiber Tree”,  我们将其中的Fiber节点简写为 &lt;code class=&quot;language-text&quot;&gt;currFiber&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;当前正在构建的Fiber树称为“WorkInProgress Fiber Tree”, 我们将其Fiber节点节点简写为 &lt;code class=&quot;language-text&quot;&gt;wipFiber&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而这两棵树中节点的 &lt;code class=&quot;language-text&quot;&gt;alternate&lt;/code&gt; 属性互相指向对方树中的对应节点, 即: &lt;code class=&quot;language-text&quot;&gt;currFiber.alternate === wipFiber; wipFiber.alternate === currFber;&lt;/code&gt; 他们用于对比更新前后的节点以决定如何更新此节点.&lt;/p&gt;
&lt;p&gt;在React中, 整个应用的根节点为 &lt;code class=&quot;language-text&quot;&gt;fiberRoot&lt;/code&gt; , 当wipFiber树构建完成后, &lt;code class=&quot;language-text&quot;&gt;fiberRoot.current&lt;/code&gt; 将从currFiber树的根节点切换为wipFiber的根节点, 以完成更新操作.&lt;/p&gt;
&lt;h3&gt;3.1 基于Fiber的调度——时间切片&lt;/h3&gt;
&lt;p&gt;在2.2节我们讨论了采用拆分工作单元并以时间切片的方式执行, 以避免阻塞主线程. 在Fiber架构下, 每个Fiber节点就是一个工作单元. &lt;/p&gt;
&lt;p&gt;在以下示例代码中, 我们使用浏览器提供的 &lt;code class=&quot;language-text&quot;&gt;requestIdleCallback&lt;/code&gt; 方法演示这个过程, 它会在浏览器空闲时执行一个workLoop、处理一个Fiber节点, 然后可以根据实际情况继续执行或暂停等待执行下一个workLoop.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;workLoop&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;deadline&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; shouldYield &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;nextUnitOfWork &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;shouldYield&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;token comment&quot;&gt;// 处理一个Fiber节点, 返回下一个Fiber节点, 详见3.3节&lt;/span&gt;
    nextUnitOfWork &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;performUnitOfWork&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;nextUnitOfWork&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 暂停处理的演示: 当时间不足时取消循环处理过程&lt;/span&gt;
    shouldYield &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; deadline&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;timeRemaining&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 当执行完毕(不存在下一个执行单元), 提交整个DOM树&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;nextUnitOfWork &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; wipRoot&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;commitRoot&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;requestIdleCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;workLoop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;requestIdleCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;workLoop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.2 对Fiber节点的处理顺序——DFS&lt;/h3&gt;
&lt;p&gt;由前文我们可知, Fiber节点通过 &lt;code class=&quot;language-text&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;sibling&lt;/code&gt; 三个属性相互连接, 整体构成一个单向链表结构,其调度方式就是 深度优先遍历 :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以wipFiber树的Root节点作为第一个执行单元;&lt;/li&gt;
&lt;li&gt;若当前执行单元存在child节点, 则将child节点作为下一个执行单元;&lt;/li&gt;
&lt;li&gt;重复2, 直至当前执行单元无child;&lt;/li&gt;
&lt;li&gt;若当前执行单元存在sibling节点, 则将sibling节点作为下一个执行单元, 并回到2;&lt;/li&gt;
&lt;li&gt;若当前执行单元无child且无sibling, 返回到父节点, 并回到4;&lt;/li&gt;
&lt;li&gt;重复5; 直至回到Root节点, 执行完毕, 将 &lt;code class=&quot;language-text&quot;&gt;fiberRoot.current&lt;/code&gt; 只为wipFiber树的根节点.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上步骤说明, Fiber节点通过 &lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt; → &lt;code class=&quot;language-text&quot;&gt;sibling&lt;/code&gt; → &lt;code class=&quot;language-text&quot;&gt;return&lt;/code&gt; 的顺序进行深度优先遍历“处理”, 而后更新Fiber树. 那么如何“处理”Fiber节点呢?&lt;/p&gt;
&lt;h3&gt;3.3 对Fiber节点的处理过程&lt;/h3&gt;
&lt;p&gt;对Fiber节点的处理就是执行一个 &lt;code class=&quot;language-text&quot;&gt;performUnitOfWork&lt;/code&gt; 方法, 它接收一个将要处理的Fiber节点, 然后完成以下工作:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;完善构建Fiber节点: 创建DOM并获取 &lt;code class=&quot;language-text&quot;&gt;children&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于HostComponent和ClassComponent, 根据Fiber中的相关属性, 创建DOM节点并赋给 &lt;code class=&quot;language-text&quot;&gt;Fiber.stateNode&lt;/code&gt; 属性;&lt;/li&gt;
&lt;li&gt;对于FunctionComponent, 直接通过函数调用获取其children: &lt;code class=&quot;language-text&quot;&gt;Fiber.type(Fiber.props)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 执行工作单元,并返回下一个工作单元&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;performUnitOfWork&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;fiber&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 构建当前节点的fiber&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; isFunctionComponent &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;type &lt;span class=&quot;token keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;isFunctionComponent&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;updateFunctionComponent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;updateHostComponent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// 处理子节点, 构建Fiber树&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; elements &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;children&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;reconcileChildren&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; elements&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// TODO: 返回下一个执行单元&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// fiber.child || fiber.sibling || fiber.return&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// Class/Host组件: 创建DOM&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateHostComponent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;fiber&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dom&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dom &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createDom&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;reconcileChildren&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;children&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 更新Function组件, Function组件需要从返回值获取子组件&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 注意: Function组件无DOM&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateFunctionComponent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;fiber&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 初始化hooks&lt;/span&gt;
  wipFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fiber&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  hookIndex &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;hooks &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; children &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Function组件返回children&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;reconcileChildren&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; children&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// TODO: reconcileChildren处理子节点,见第3步&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 &lt;code class=&quot;language-text&quot;&gt;Fiber.alternate&lt;/code&gt; 获取 &lt;code class=&quot;language-text&quot;&gt;oldFiber&lt;/code&gt; , 即上一次更新后的Fiber值, 然后在下一步中构建和Diff当前Fiber的 &lt;code class=&quot;language-text&quot;&gt;children&lt;/code&gt; .&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;reconcileChildren&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;wipFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; elements&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; oldFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate
			&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;child&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构建 &lt;code class=&quot;language-text&quot;&gt;children&lt;/code&gt; Fibers, 对于每个子Fiber, 同步地完成以下工作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建Fiber链表: 为每个子元素创建Fiber, 并将父Fiber的 &lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt; 属性指向第一个子Fiber, 然后按顺序将子Fiber的 &lt;code class=&quot;language-text&quot;&gt;sibling&lt;/code&gt; 属性指向下一个子Fiber;&lt;/li&gt;
&lt;li&gt;对比(Diffing)新旧Fiber节点的 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt; 等属性, 确定节点是可以直接复用、替换、更新还是删除, 需要更新的Fiber节点在其 &lt;code class=&quot;language-text&quot;&gt;effectTag&lt;/code&gt; 属性中打上 &lt;code class=&quot;language-text&quot;&gt;Update&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;Placement&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;PlacementAndUpdate&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;Deletion&lt;/code&gt; 等标记, 以在提交更新阶段进行处理.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;reconcileChildren&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;wipFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; elements&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; oldFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;child&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; index &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; prevSibling &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;index &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; elements&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; oldFiber &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; element &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; elements&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;index&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; newFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token comment&quot;&gt;// Compare oldFiber to element&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; sameType &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; oldFiber &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; element &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; element&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;type &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; oldFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;type&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sameType&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// update the node&lt;/span&gt;
      newFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; oldFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;type&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; element&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        dom&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; oldFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dom&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        parent&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; wipFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        alternate&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; oldFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        effectTag&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;UPDATE&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;element &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;sameType&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// add this node&lt;/span&gt;
      newFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; element&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;type&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; element&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        dom&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        parent&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; wipFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        alternate&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        effectTag&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;PLACEMENT&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;oldFiber &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;sameType&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// delete the oldFiber&apos;s node&lt;/span&gt;
      oldFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;effectTag &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;DELETION&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      deletions&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;oldFiber&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;oldFiber&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      oldFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; oldFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sibling&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;index &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;child &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newFiber&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      prevSibling &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newFiber&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    prevSibling &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newFiber&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    index&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按DFS顺序返回下一个工作单元, 示例代码如下:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;child&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;child&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; nextFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fiber&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;nextFiber&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;nextFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sibling&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; nextFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sibling&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    nextFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; nextFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;parent&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当DFS过程回到根节点时, 表明本次更新的 wipFiber树 构建完成, 进入下一步的提交更新阶段.&lt;/p&gt;
&lt;h3&gt;3.4 提交更新阶段&lt;/h3&gt;
&lt;p&gt;在进入本阶段时, 新的Fiber树已构建完成, 需要进行替换、更新或删除的Fiber节点也在其 &lt;code class=&quot;language-text&quot;&gt;effectTag&lt;/code&gt; 中进行了标记, 所以本阶段第一个工作就是根据 &lt;code class=&quot;language-text&quot;&gt;effectTag&lt;/code&gt; 操作真实DOM.&lt;/p&gt;
&lt;p&gt;为了避免从头再遍历Fiber树寻找具有 &lt;code class=&quot;language-text&quot;&gt;effectTag&lt;/code&gt; 属性的Fiber, 在上一步Fiber树的构建过程中保存了一条需要更新的Fiber节点的单向链表 &lt;code class=&quot;language-text&quot;&gt;effectList&lt;/code&gt; , 并将此链表的头节点存储在Fiber树根节点的 &lt;code class=&quot;language-text&quot;&gt;firstEffect&lt;/code&gt; 属性中, 同时这些Fiber节点的 &lt;code class=&quot;language-text&quot;&gt;updateQueue&lt;/code&gt; 属性中也保存了需要更新的 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;除了更新真实DOM外, 在提交更新阶段还需要在特定阶段调用和处理生命周期方法、执行Hooks操作, 本文不再详述.&lt;/p&gt;
&lt;p&gt;在此参考了 &lt;a href=&quot;https://pomb.us/build-your-own-react/&quot;&gt;https://pomb.us/build-your-own-react/&lt;/a&gt; 中提供的 &lt;code class=&quot;language-text&quot;&gt;useState&lt;/code&gt; Hook的实现代码, 有助于理解在执行 &lt;code class=&quot;language-text&quot;&gt;setState&lt;/code&gt; 方法后都发生了什么: &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;initial&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 判断上一次渲染是否存在此Hook,如果存在就使用上一个state,否则创建新的hook并更新索引&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; oldHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;
    wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
    wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;hooks &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
    wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;hooks&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;hookIndex&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; hook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    state&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; oldHook &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; oldHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; initial&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    queue&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 每次执行setState时,将action加入此队列,并在下一次渲染时执行&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// 下一次渲染时, 获取执行队列并逐步执行, 使得state保持最新&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; actions &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; oldHook &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; oldHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;queue &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  actions&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// setState方法: 将action添加到执行队列并触发渲染, 在下一次渲染时执行此action&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;setState&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;action&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 执行setState后应重新触发渲染&lt;/span&gt;
    wipRoot &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      dom&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; currentRoot&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dom&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; currentRoot&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      alternate&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; currentRoot&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    nextUnitOfWork &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; wipRoot&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    deletions &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;hooks&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;hook&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  hookIndex&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; setState&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;参考文献&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;React官方文档与相关源码&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pomb.us/build-your-own-react/&quot;&gt;https://pomb.us/build-your-own-react/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://react.iamkasong.com/renderer/beforeMutation.html#commitbeforemutationeffects&quot;&gt;https://react.iamkasong.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[在线编辑器实现浅析]]></title><description><![CDATA[在线编辑器根据其侧重点和实现方式的不同, 可大致分为富文本编辑器和代码编辑器两类, 本文对这两类编辑器的实现方式进行最基本的解读和分析. 富文本编辑器 基本实现原理 富文本编辑器的实现原理很简单, 其编辑区域一般使用一个  的  元素来实现. 当HTML…]]></description><link>https://hrayd.github.io/online-editor/</link><guid isPermaLink="false">https://hrayd.github.io/online-editor/</guid><pubDate>Sat, 10 Jul 2021 22:00:00 GMT</pubDate><content:encoded>&lt;p&gt;在线编辑器根据其侧重点和实现方式的不同, 可大致分为富文本编辑器和代码编辑器两类, 本文对这两类编辑器的实现方式进行最基本的解读和分析.&lt;/p&gt;
&lt;h1&gt;富文本编辑器&lt;/h1&gt;
&lt;h2&gt;基本实现原理&lt;/h2&gt;
&lt;p&gt;富文本编辑器的实现原理很简单, 其编辑区域一般使用一个 &lt;code class=&quot;language-text&quot;&gt;contentedtable=&amp;quot;true&amp;quot;&lt;/code&gt; 的 &lt;code class=&quot;language-text&quot;&gt;div&lt;/code&gt; 元素来实现. 当HTML元素的 &lt;code class=&quot;language-text&quot;&gt;contenteditable&lt;/code&gt; 属性设为 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt; 后, 该元素的内容变为可编辑状态:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;html&quot;&gt;&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;contenteditable&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;true&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;这是一个可编辑元素&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时即可修改元素的内容, 当点击回车键后, 会自动生成一个 &lt;code class=&quot;language-text&quot;&gt;p&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;div&lt;/code&gt; 元素.
可设置 &lt;code class=&quot;language-text&quot;&gt;outline: none&lt;/code&gt; 以去掉默认的聚焦态边框.&lt;/p&gt;
&lt;h2&gt;修改样式与内容&lt;/h2&gt;
&lt;p&gt;此时即可修改元素的内容, 当点击回车键后, 会自动生成一个 &lt;code class=&quot;language-text&quot;&gt;p&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;div&lt;/code&gt; 元素.&lt;/p&gt;
&lt;p&gt;可设置 &lt;code class=&quot;language-text&quot;&gt;outline: none&lt;/code&gt; 以去掉默认的聚焦态边框.文本样式的修改主要通过调用 &lt;code class=&quot;language-text&quot;&gt;document.execCommand()&lt;/code&gt; 方法来实现, 此方法会影响当前处于活动状态的可编辑元素. 此方法接收三个输入参数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令名称[string], 如fontsize、backcolor、undo等, 详见MDN相关参考.&lt;/li&gt;
&lt;li&gt;是否展开用户界面[boolean], 一般传入false即可.&lt;/li&gt;
&lt;li&gt;命令参数[可选], 如fontSize传入字体尺寸、backColor传入color类型的string等, 默认为null.&lt;/li&gt;
&lt;li&gt;返回值: boolean, 返回 false 表示命令不被支持或未启用.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 将当前行设为“Heading2”, 添加“h2”标签&lt;/span&gt;
document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;execCommand&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;formatblock&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;h2&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 在插入点或选中文字部分修改字体、字号&lt;/span&gt;
document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;execCommand&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;fontname&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Times New Roman&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;execCommand&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;fontsize&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;3&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 撤销上一次修改&lt;/span&gt;
document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;execCommand&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;undo&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; 是否展开用户界面&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;boolean&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 一般传入&lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;即可&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;浏览器实现差异&lt;/h2&gt;
&lt;p&gt;可编辑元素在不同浏览器及其版本之间可能存在一些差异, 如按下回车键后, IE/Opera会添加一个 &lt;code class=&quot;language-text&quot;&gt;p&lt;/code&gt; 标签元素, 旧版本的Firefox会添加 &lt;code class=&quot;language-text&quot;&gt;br&lt;/code&gt; 元素, 而Chrome/Safari会添加 &lt;code class=&quot;language-text&quot;&gt;div&lt;/code&gt; 元素. 通过调用 &lt;code class=&quot;language-text&quot;&gt;document.execCommand(&amp;quot;defaultParagraphSeparator&amp;quot;, false, &amp;quot;div&amp;quot;)&lt;/code&gt; 可显式指定创建新段落的方式, 此方法也支持使用自定义标签, 如语雀的编辑器就使用了以 &lt;code class=&quot;language-text&quot;&gt;ne&lt;/code&gt; 开头的一系列自定义标签.&lt;/p&gt;
&lt;p&gt;文末提供了MDN中展示的一个最基本的原生富文本编辑器Demo.&lt;/p&gt;
&lt;hr&gt;
&lt;h1&gt;代码编辑器&lt;/h1&gt;
&lt;p&gt;富文本编辑器受到原生HTML和DOM技术的友好支持, 其编辑区生成的就是一组的HTML元素, 通过自定义标签、添加自定义样式表等方式来定制主题样式即可.&lt;/p&gt;
&lt;p&gt;相较于富文本编辑器, 代码编辑器则要复杂得多. 代码编辑器的核心是通过对代码文本的词法、语法和语义分析, 将内容划分为关键字、变量名、字面量、函数体等元素, 并为每类元素添加不同的CSS class, 同时插入一些带边框的空格元素来实现代码的缩进和格式化等.&lt;/p&gt;
&lt;h2&gt;monaco-editor&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;monaco-editor&lt;/code&gt; 是VSCode中分离出的编辑器模块, 也是目前最典型、应用最为广泛的前端代码编辑器之一, 本文以 &lt;code class=&quot;language-text&quot;&gt;monaco-editor&lt;/code&gt; 为例分析代码编辑器的实现方式.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;monaco-editor&lt;/code&gt; 的编辑器区域使用了绝对定位、完全重叠的两层 &lt;code class=&quot;language-text&quot;&gt;div&lt;/code&gt; 区域与一个1px宽度的 &lt;code class=&quot;language-text&quot;&gt;textarea&lt;/code&gt; 元素构成:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一层 div 主要负责背景样式的渲染, 其内部由绝对定位、固定高度的 div 代码行构成, 每个代码行内包含若干个绝对定位的 div 块, 用于展示缩进线、当前聚焦行边框、文字选中态高亮、警告和错误信息的下划波浪线等样式信息. 这一层的所有 div 都没有文本元素.&lt;/li&gt;
&lt;li&gt;第二层 div 用于渲染代码文本, 内部的 div 代码行与第一层完全重叠, 每个代码行内由若干 span 标签包裹的文本元素(一个单词、一个标点符号、一段连续空格等)构成. 对代码进行语义分析后为每个 span 元素赋予不同的 class , 从而实现代码高亮.&lt;/li&gt;
&lt;li&gt;输入光标为一个绝对定位、宽度为1px、内容为空的 textarea , 当使用鼠标或触控板单击编辑器区域、或使用方向键和其他快捷键改变输入光标位置后, 需要计算出正确的文本编辑位置并更新 textarea 元素的位置.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1&gt;结语&lt;/h1&gt;
&lt;p&gt;本文对富文本编辑器和代码编辑器的实现方式进行了最基本最浅显的分析, 相较于代码编辑器而言, 富文本编辑器应用更广、更贴近前端.&lt;/p&gt;
&lt;p&gt;作为学习者, 可以扒一扒市面上比较有名的在线富文本编辑器(如语雀、幕布、Notion、EverNote等), 发挥自己的创意, 做一个自己心目中更易用、更美观、更极客的富文本编辑器吧!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;附:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Editable_content/Rich-Text_Editing_in_Mozilla#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E4%BD%86%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8&quot;&gt;MDN - 一个简易但完整的富文本编辑器实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Microsoft/monaco-editor&quot;&gt;Monaco Editor - Github Pages&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://prosemirror.net/&quot;&gt;ProseMirror - 一个开源的支持Markdown、WYSIWYG的富文本编辑器Toolkit&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Clean Architecture]]></title><description><![CDATA[第一部分 概述 第…]]></description><link>https://hrayd.github.io/clean-architecture/</link><guid isPermaLink="false">https://hrayd.github.io/clean-architecture/</guid><pubDate>Fri, 18 Jun 2021 22:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;第一部分 概述&lt;/h2&gt;
&lt;h3&gt;第 1 章 设计与架构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;随着软件版本的更迭: 需要的工程师人数越来越多、人均生产效率显著降低(以同期代码行数作为统计)、每行代码的变更成本显著增高.&lt;/li&gt;
&lt;li&gt;对于重构的过于乐观: 为了快速上线而容忍混乱的代码, 忽略软件架构, 而寄希望于未来的重构工作. 事实上, 新功能源源不断, 混乱的架构又会导致新功能的开发成本急速上升, 生产效率持续下降, 陷入恶性循环, 导致重构的成本越来越大, 重构的时机几乎不会存在.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 2 章 两个价值维度&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;两个价值纬度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;系统行为, 即软件功能是否满足需求&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;系统架构, 即软件是否足够灵活&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;何者更重要?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是系统正常工作更重要, 还是系统易于修改更重要?&lt;/li&gt;
&lt;li&gt;对于业务部门来说, 答案一般是前者, 而一旦开发人员也选择了前者, 紧接着就会面临源源不断的新增需求和需求变更, 导致生产效率直线下降.&lt;/li&gt;
&lt;li&gt;所以对于开发人员来说, 系统架构大于系统行为: 只要保持系统的灵活性, 系统行为总会以平和的方式得到满足.&lt;/li&gt;
&lt;li&gt;开发团队同市场、销售、运营团队一样需要“长期抗争”, 保护系统的灵活性/可维护性, 是开发团队的职责.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第二部分 编程范式&lt;/h2&gt;
&lt;h3&gt;第 3 章 编程范式总览&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;三大编程范式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构化编程&lt;/li&gt;
&lt;li&gt;对程序控制权的直接转移进行了限制和规范&lt;/li&gt;
&lt;li&gt;限制了 goto: 使用 if、for、while 等流程控制&lt;/li&gt;
&lt;li&gt;面向对象编程&lt;/li&gt;
&lt;li&gt;对程序控制权的间接转移进行了限制和规范&lt;/li&gt;
&lt;li&gt;限制了函数指针&lt;/li&gt;
&lt;li&gt;函数式编程&lt;/li&gt;
&lt;li&gt;对程序中的赋值进行了限制和规范&lt;/li&gt;
&lt;li&gt;限制了赋值语句&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编程范式与架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;架构的三大关注点&lt;/li&gt;
&lt;li&gt;功能性&lt;/li&gt;
&lt;li&gt;组件独立性&lt;/li&gt;
&lt;li&gt;数据管理&lt;/li&gt;
&lt;li&gt;编程范式的作用&lt;/li&gt;
&lt;li&gt;结构化编程: 实现逻辑功能&lt;/li&gt;
&lt;li&gt;面向对象: 封装与多态&lt;/li&gt;
&lt;li&gt;函数式: 规范数据存放与访问权限&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 4 章 结构化编程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可推导性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三种基本结构&lt;/li&gt;
&lt;li&gt;顺序结构&lt;/li&gt;
&lt;li&gt;分支结构&lt;/li&gt;
&lt;li&gt;循环结构&lt;/li&gt;
&lt;li&gt;可以用三种基本结构构造出任何程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不受限制的直接控制转移语句——goto 是有害的, 可被三种基本结构替代&lt;/li&gt;
&lt;li&gt;结构化编程范式使得可以将大型系统设计拆分为模块和组件, 然后可递归拆分为更小的、可证明的函数&lt;/li&gt;
&lt;li&gt;结构化编程范式促使将一段程序递归降解为一系列小单元, 程序的测试过程即证伪过程.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 5 章 面向对象编程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;面向对象编程语言&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;封装性: 较 C 而言实际上减弱了封装性&lt;/li&gt;
&lt;li&gt;继承性: 提供了一定便利,但没有开创出新&lt;/li&gt;
&lt;li&gt;多态: C 本来就有,只是提供了安全性和便利&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面向对象的多态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插件式架构&lt;/li&gt;
&lt;li&gt;程序应与设备无关&lt;/li&gt;
&lt;li&gt;依赖反转&lt;/li&gt;
&lt;li&gt;原本: 层层依赖-上层组件依赖下层组件&lt;/li&gt;
&lt;li&gt;多态: 上层组件提供需求接口, 底层组件实现接口&lt;/li&gt;
&lt;li&gt;例子&lt;/li&gt;
&lt;li&gt;原本: 业务逻辑引入(依赖)用户界面和数据库&lt;/li&gt;
&lt;li&gt;应用多态: 用户界面和数据库作为业务逻辑的插件,从而可以各自独立部属&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;架构师眼中的面向对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以多态为手段来对源代码中的依赖关系进行控制, 构建出某种插件式架构, 让高层策略性组件和底层实现性组件相分离, 底层组件可以作为插件, 独立于高层组件进行开发和部属&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 6 章 函数式编程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;变量不可变&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不可变性与软件架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果变量不可变, 一切并发问题都会不复存在: 竞争、死锁、并发更新等.&lt;/li&gt;
&lt;li&gt;不可变性是否可行? 如果能忽略存储器和处理器的速度限制,则可行; 否则只有一定情况下可行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可变形隔离&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个架构设计良好的应用程序应该将状态修改的部分和不需要修改状态的部分隔离成单独的组件，然后用合适的机制来保护可变量&lt;/li&gt;
&lt;li&gt;软件架构师应该着力于将大部分处理逻辑都归于不可变组件中，可变状态组件的逻辑应该越少越好&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件溯源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果有足够大的存储量和处理能力，应用程序就可以用完全不可变的、纯函数式的方式来编程&lt;/li&gt;
&lt;li&gt;只存储事务记录, 不存储具体状态, 通过计算所有事务来获取当前状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第三部分 设计原则&lt;/h2&gt;
&lt;h3&gt;综述&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;构建中层结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使软件可容忍被改动&lt;/li&gt;
&lt;li&gt;使软件更容易被理解&lt;/li&gt;
&lt;li&gt;构建可复用的组件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SOLID 原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SRP: 单一职责原则——每个模块有且只有一个被改变的理由&lt;/li&gt;
&lt;li&gt;OCP: 开闭原则——允许通过新增代码来扩展功能,尽量减少代码修改&lt;/li&gt;
&lt;li&gt;LSP: 李氏替换原则——遵守同一约定的组件可相互替换&lt;/li&gt;
&lt;li&gt;ISP: 接口隔离原则——在设计中避免不必要的依赖&lt;/li&gt;
&lt;li&gt;DIP: 依赖反转原则——实现底层细节的代码应依赖高层策略性代码,而非反向依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 7 章 SRP: 单一职责原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;不仅仅是“每个模块只做一件事”&lt;/li&gt;
&lt;li&gt;任何一个软件模块都应该只对某一类行为者负责&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 8 章 OCP: 开闭原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;易于扩展(新增代码),抗拒修改&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;将需求分组,即 SRP&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;调整分组之间的依赖,即 DIP&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果 A(Father)组件不想被 B(Child)组件发生的修改所影响,那么就让 B 依赖于 A.&lt;/li&gt;
&lt;li&gt;分层设计: 高层组件更核心、更封闭, 低层依赖于高层.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 9 章 LSP: 李氏替换原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;子类型可以替代父类型被调用/使用, 即继承关系&lt;/li&gt;
&lt;li&gt;LSP 演变为更广泛的、指导接口与实现方式的设计原则&lt;/li&gt;
&lt;li&gt;反例: 当核心业务逻辑出现无法避免的例外情况时,避免在核心组件中进行特殊情况判断,而应该使用一个额外的调度组件来处理特殊情况&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 10 章 ISP: 接口隔离原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;尽量避免多个行为依赖并操作同一个接口: 在中间再做一层封装进行隔离.&lt;/li&gt;
&lt;li&gt;尽量减少不必要的依赖, 第 13 章再继续探讨更多细节&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 11 章 DIP: 依赖反转原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在源代码层次上只引用包含接口、抽象类或其他抽象类型声明的源文件, 而不引用任何具体实现.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编码守则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多使用抽象接口,避免使用多变的具体实现类&lt;/li&gt;
&lt;li&gt;不要在具体实现类上创建衍生类&lt;/li&gt;
&lt;li&gt;不要覆盖(override)包含具体实现的函数&lt;/li&gt;
&lt;li&gt;避免在代码中写入任何具体实现相关或其他容易变动的事务的名字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用抽象工厂模式创建对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第四部分 组件构建原则&lt;/h2&gt;
&lt;h3&gt;第 12 章 组件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;组件是软件在部属过程中的最小单元&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在编译运行语言中是一组二进制文件;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在解释运行语言中是一组源代码文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;设计良好的组件: 独立部署、单独开发&lt;/li&gt;
&lt;li&gt;组件概念的历史: 动态链接文件&lt;/li&gt;
&lt;li&gt;现状: 组件化的插件式架构&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 13 章 组件聚合&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;问题: 哪些类应该被合成一个组件?&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;REP: 复用/发布等同原则&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- 软件复用的最小粒度应等同于其发布的最小粒度
- 被复用的组件应有明确的发布版本号、适当的通知和发布文档
- 组件中包含的类与模块也应该可以同时发布,共享相同的版本号和版本跟踪,被包含在发布文档中.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CCP: 共同闭包原则&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- 将会同时修改、并且为相同目的而修改的类放入同一组件; 反之放入不同组件.
- SRP原则在组件层面的阐述
- 一个组件应该只有一个变更原因;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一次变更最好都体现在一个组件中 - 一般来说, 可维护性比可复用性重要得多&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CRP: 共同复用原则&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- 将经常共同复用的类和模块放入同一个组件
- 不是紧密相连的类不应被放入同一组件
- 是ISP原则的普适版&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;组件聚合原则张力图&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;REP 和 CCP 使组件更大, CRP 使组件更小, 架构师的任务就是在三原则中进行取舍, 并且是随着项目状态逐步调整&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目早期一般偏向右侧, 主要牺牲复用性&lt;/li&gt;
&lt;li&gt;随着项目逐渐成熟,其他项目对其产生依赖,会逐渐向左侧滑动&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 14 章 组件耦合&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无依赖环原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决方案&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;将项目划分为可独立发布的组件&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;组件独立发布,打版本号并通知其他成员&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;其他开发者基于组件公开发布的版本进行开发,并可以选择是否采用新版本&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;组件依赖图: 有向无环图(DAG)&lt;/li&gt;
&lt;li&gt;可以直观地判断出某个组件变更的影响范围&lt;/li&gt;
&lt;li&gt;无环: 从任意节点开始沿依赖线都回不到起始点&lt;/li&gt;
&lt;li&gt;发布过程从下至上进行编译、测试、发布&lt;/li&gt;
&lt;li&gt;循环依赖: 组件依赖图存在环, 组件的独立维护工作以及单元测试、发布流程都将十分困难&lt;/li&gt;
&lt;li&gt;消除循环依赖&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;应用依赖反转原则(DIP), 将环形依赖反转&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;创建新的上层组件, 将相互依赖的类进行抽象提取&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;当循环依赖出现时,必须立刻进行消除,调整组件结构&lt;/li&gt;
&lt;li&gt;组件结构图的构建&lt;/li&gt;
&lt;li&gt;不可能在系统构建之初就被完美设计, 因为它不是描述软件功能的,而是软件构建性和维护性的地图&lt;/li&gt;
&lt;li&gt;隔离频繁的变更: 将稳定的高价值组件与常变的组件进行隔离&lt;/li&gt;
&lt;li&gt;随着项目的逻辑设计一起扩张和演进&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;稳定依赖原则(SDP)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;稳定性&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直观上&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果组件不依赖其他组件, 或被多个其他组件依赖, 则是稳定的组件.&lt;/li&gt;
&lt;li&gt;如果组件依赖多个组件, 则是不稳定的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I(不稳定性) = FanOut / (FanIn + FanOut)&lt;/li&gt;
&lt;li&gt;FanIn: 入向依赖,组件内部类被外部类依赖的数量&lt;/li&gt;
&lt;li&gt;FanOut: 出向依赖, 组件内部类依赖外部类的数量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;要求: 每个组件的 I 指标都大于其所依赖组件的 I 指标. 即: 越高层的组件越稳定.&lt;/li&gt;
&lt;li&gt;高阶组件 &gt;&gt; I=0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;稳定抽象原则(SAP)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组件的抽象化程度应与其稳定性保持一致,&lt;/li&gt;
&lt;li&gt;如何使一个趋于无限稳定(I=0)的组件接收变更?&lt;/li&gt;
&lt;li&gt;抽象类(与接口)&lt;/li&gt;
&lt;li&gt;指标&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A(抽象化程度) = Na / Nc&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Na: 组件中类的数量&lt;/li&gt;
&lt;li&gt;Nc: 组件中抽象类和接口的数量&lt;/li&gt;
&lt;li&gt;0 表示没有抽象类; 1 表示只有抽象类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SDP 与 SAP&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I/A 图&lt;/li&gt;
&lt;li&gt;最稳定、包含无限抽象类的组件位于左上角(0,1)&lt;/li&gt;
&lt;li&gt;最不稳定、最具体的组件位于右下角(1,0)&lt;/li&gt;
&lt;li&gt;主序列、痛苦区与无用区&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;痛苦区: 稳定且具体, 涉及很多具体业务但又难以修改&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;典型: 数据库的表结构、工具型类库&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;无用区: 无限抽象、但没有被其他组件依赖, 多为无用代码&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主序列线: 合适的位置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽量让组件贴近主序列线&lt;/li&gt;
&lt;li&gt;最优位置是线的两端&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;D 指标 = |A + I - 1|&lt;/li&gt;
&lt;li&gt;组件与主序列线的距离: 0 表示在主序列上; 1 表示最远位置&lt;/li&gt;
&lt;li&gt;可用“D 指标小于 xx”来指导组件的重构&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用途&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重点分析 D 指标处于平均值的标准差之外的组件: 要么过于抽象但依赖不足, 要么过于具体而被依赖太多&lt;/li&gt;
&lt;li&gt;按时间跟踪每个组件的 D 指标, 及时发现组件架构隐患&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第五部分 软件架构&lt;/h2&gt;
&lt;h3&gt;第 15 章 什么是软件架构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;软件架构师: 坚持一线程序员、更多的编程任务&lt;/li&gt;
&lt;li&gt;实质: 如何将系统切分成组件, 并安排好组件之间的排列关系及互相通信的方式.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目的: 更好地对组件进行研发、部属、运行及维护&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发: 当开发人员组成复杂、系统体量较大时, 清晰的组件和稳定的接口是开发顺利的必要条件&lt;/li&gt;
&lt;li&gt;部属: 一键式的轻松部属应该是设计软件架构的目标.&lt;/li&gt;
&lt;li&gt;微服务架构虽然有利于开发, 但要考虑其部属和通信带来的隐患&lt;/li&gt;
&lt;li&gt;运行: 软件架构对运行的影响较小, 但架构应该将系统中的用例、功能和核心行为设为开发者可见的一级实体, 简化理解&lt;/li&gt;
&lt;li&gt;维护: 成本最高的部分&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主要成本&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;探秘: 对现系统的挖掘, 确定新增功能或被修复问题的最佳位置和方式&lt;/li&gt;
&lt;li&gt;风险: 进行修改时, 对可能衍生出新问题的风险成本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过架构设计(切分、隔离组件)降低以上成本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;策略: 保持可选项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件系统的主要元素&lt;/li&gt;
&lt;li&gt;策略: 业务规则与操作过程, 是系统的价值所在&lt;/li&gt;
&lt;li&gt;细节: 用户、程序员或第三方与策略进行交互的行为, 包括 I/O 设备、数据库、Web 系统、服务器、框架、交互协议等&lt;/li&gt;
&lt;li&gt;架构: 以策略为基本元素, 让细节与策略脱离关系, 并允许在具体决策过程中推迟或延迟与细节相关的内容&lt;/li&gt;
&lt;li&gt;方法: 做高层的策略决策时,尽可能摆脱并推迟对细节的决策(如数据库、框架和设备的选型等)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;好处&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对策略的信息越多, 对细节的决策越合理&lt;/li&gt;
&lt;li&gt;保持可选项, 可尝试不同的细节决策&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;示范: 设备无关性的应用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 16 章 独立性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;架构的支持目标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用例: 架构的首要目标是为所有系统用例提供支持&lt;/li&gt;
&lt;li&gt;运行: 架构需要支持系统的运行条件&lt;/li&gt;
&lt;li&gt;如为了支持系统的吞吐量和响应时间要求, 使用微服务或多进程、多线程架构&lt;/li&gt;
&lt;li&gt;开发: 将系统切分为隔离良好、可独立开发的组件&lt;/li&gt;
&lt;li&gt;部属: 设计目标是“一键部属”, 减少部属脚本与配置文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;挑战: 无法预知所有用例、运行条件、开发团队结构和部属需求; 并且这些需求会发生变化&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;策略: 保留可选项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用例: 解耦模式&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;水平分层解耦&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UI 界面&lt;/li&gt;
&lt;li&gt;应用独有的业务逻辑&lt;/li&gt;
&lt;li&gt;领域通用的业务逻辑&lt;/li&gt;
&lt;li&gt;数据库&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;垂直解耦: 按用例(如新增、删除)对系统进行垂直切分, 每个用例都可能涉及 UI 界面、业务逻辑和数据库&lt;/li&gt;
&lt;li&gt;运行: 按用例解耦后, 可以将高吞吐量和低吞吐量的组件、UI 和数据库等按需分开部属在不同的环境中&lt;/li&gt;
&lt;li&gt;开发: 解耦后可按水平分层或用例分别独立开发&lt;/li&gt;
&lt;li&gt;部属: 解耦后可独立部署、热更新等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重复的代码不一定是坏事&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用例之间的重复代码: 可能之后的变更速率和变更缘由会完全不同, 必须加倍小心地避免在用例之间复用代码&lt;/li&gt;
&lt;li&gt;水平分层的重复代码: 当数据库结构与 UI 界面的数据接口非常相似时(几乎一定是表面性的重复),也不要省略中间的视图模型,要保持水平分层之间的隔离&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解耦&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模式&lt;/li&gt;
&lt;li&gt;水平分层&lt;/li&gt;
&lt;li&gt;用例解耦&lt;/li&gt;
&lt;li&gt;解耦层次&lt;/li&gt;
&lt;li&gt;源码层次: 源代码模块之间通过函数调用来交互&lt;/li&gt;
&lt;li&gt;部属层次: 部属单元(jar 包、DLL、共享库)之间通过函数调用、跨进程通信、socket 或共享内存通信&lt;/li&gt;
&lt;li&gt;服务层次: 组件之间仅通过网络数据包通信&lt;/li&gt;
&lt;li&gt;解决方案&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单一层次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源码层次: 适合系统只运行在一台服务器上(单体结构), 但之后可能需要进行部属层次和服务层次的解耦&lt;/li&gt;
&lt;li&gt;服务层次: 资源成本、研发成本、人力成本高昂&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态层次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源码层次 -&gt; 部属层次 -&gt; 服务层次&lt;/li&gt;
&lt;li&gt;根据系统开发和部属需要进行变更&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;良好的架构&lt;/li&gt;
&lt;li&gt;允许从单体结构向可部属单元、独立的服务或微服务进行转变&lt;/li&gt;
&lt;li&gt;允许从部属和服务层次回退到单体结构&lt;/li&gt;
&lt;li&gt;在层次转变过程中保持系统的大部分源码不受影响&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 17 章 划分边界&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;划分边界的目的: 尽量将一些决策延后, 并确保这些决策不对核心业务逻辑产生干扰&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统最消耗人力资源的问题: 耦合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尤其是与系统业务需求无关的决策造成的耦合, 如过早决策系统框架、数据库、服务器等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;范例分析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;过早地做出决策去适应一个并不存在的大型服务器集群环境,导致开发成本急剧上升.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;过早地采用一整套域对象服务体系,需要将一整套服务全部运行起来才能进行开发,导致开发效率急剧下降&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;成功案例: 延后数据库相关决策,采用一种与数据库无关的设计,并预留空的数据访问方法,使得开发过程中不需要面对表结构问题、查询问题、数据库服务器问题、密码问题、链接时间等一系列数据库带来的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在何处划分?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GUI 与业务逻辑之间&lt;/li&gt;
&lt;li&gt;数据库与 GUI 之间&lt;/li&gt;
&lt;li&gt;数据库与业务逻辑之间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插件式架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心业务逻辑与其他组件隔离&lt;/li&gt;
&lt;li&gt;其他组件要么是可去掉的, 要么是有多种实现的&lt;/li&gt;
&lt;li&gt;GUI 与数据库都应可作为插件进行替换&lt;/li&gt;
&lt;li&gt;是单一职责原则(SRP)的具体实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 18 章 边界剖析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;跨边界调用: 边界一侧的函数调用另一侧的函数,并同时传递数据&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单体结构/源码层次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单体结构: 各组件合并产生一个单独的可执行文件&lt;/li&gt;
&lt;li&gt;一般利用某种动态形式的多态来管理内部依赖关系&lt;/li&gt;
&lt;li&gt;最简单的调用形式: 低层客户端调用高层服务函数&lt;/li&gt;
&lt;li&gt;当高层组件需要调用低层组件中的服务时,可以运行动态形式的多态来反转依赖关系&lt;/li&gt;
&lt;li&gt;高层组件提供接口&lt;/li&gt;
&lt;li&gt;低层组件实现接口并被高层组件调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;部属层次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跨边界调用方式与单体结构类似, 只是普通的函数调用.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程模型: 单体结构和按部属层次划分的组件都可以采用线程模型&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本地进程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不同进程拥有不同的地址空间, 无法共享内存&lt;/li&gt;
&lt;li&gt;进程间通信&lt;/li&gt;
&lt;li&gt;用某种独立的内存区域实现共享&lt;/li&gt;
&lt;li&gt;socket(最常见)&lt;/li&gt;
&lt;li&gt;一些操作系统提供的方式,如共享邮件、消息队列&lt;/li&gt;
&lt;li&gt;进程间的隔离策略与单体结构类似, 依赖关系始终指向更高层次组件&lt;/li&gt;
&lt;li&gt;高层进程源码中不应包含低层进程的名称、物理地址或注册表键名.&lt;/li&gt;
&lt;li&gt;设计目标: 低层进程作为高层进程的插件&lt;/li&gt;
&lt;li&gt;进程间通信成本相对较高,需要谨慎控制通信次数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统架构中最强的边界形式&lt;/li&gt;
&lt;li&gt;不依赖于具体的运行位置,始终假设服务之间的通信全部通过网络进行&lt;/li&gt;
&lt;li&gt;跨边界通信速度缓慢,尽可能控制通信次数并适应高延时情况&lt;/li&gt;
&lt;li&gt;目标: 低层服务成为高层服务的插件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 19 章 策略与层次&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;策略&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序 = 策略语句的集合&lt;/li&gt;
&lt;li&gt;策略语句&lt;/li&gt;
&lt;li&gt;描述计算部分的业务逻辑&lt;/li&gt;
&lt;li&gt;描述计算报告的格式&lt;/li&gt;
&lt;li&gt;描述输入数据的校验策略&lt;/li&gt;
&lt;li&gt;架构设计&lt;/li&gt;
&lt;li&gt;将策略语句彼此分离, 按变更方式(原因、时间、层次)重新分组(组件)&lt;/li&gt;
&lt;li&gt;将组件重新组合为一个有向无环图, 低层依赖于高层&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;层次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按输入与输出之间的距离来分层, 距离越远层次越高&lt;/li&gt;
&lt;li&gt;高层提供接口, 低层实现接口并依赖高层&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;涉及原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单一职责原则（SRP）、开闭原则（OCP）、共同闭包原则（CCP）、依赖反转原则（DIP）、稳定依赖原则（SDP）以及稳定抽象原则（SAP）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 20 章 业务逻辑&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;应用程序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;业务逻辑&lt;/li&gt;
&lt;li&gt;插件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;业务实体(Entity)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构成&lt;/li&gt;
&lt;li&gt;关键业务逻辑&lt;/li&gt;
&lt;li&gt;关键业务数据: 包含或容易访问&lt;/li&gt;
&lt;li&gt;接口&lt;/li&gt;
&lt;li&gt;实现关键业务逻辑的函数&lt;/li&gt;
&lt;li&gt;操作关键业务数据的属性或函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用例(Usecase)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义输入、输出及产生输出的过程&lt;/li&gt;
&lt;li&gt;描述某种特定应用场景下的业务逻辑&lt;/li&gt;
&lt;li&gt;用例属于低层概念, 依赖于业务实体&lt;/li&gt;
&lt;li&gt;只描述业务逻辑, 不描述交互方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求/响应模型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入输出都是简单的数据结构&lt;/li&gt;
&lt;li&gt;不派生任何 HTTP 接口和用户界面细节&lt;/li&gt;
&lt;li&gt;避免引用业务实体, 即使二者有很多相同的数据&lt;/li&gt;
&lt;li&gt;因为两个对象会以不同原因和速率发生变更&lt;/li&gt;
&lt;li&gt;会违反共同闭包原则(CCP)和单一职责原则(SRP)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 21 章 尖叫的软件架构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;架构设计的主题应该是业务, 而非架构/框架本身&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;推荐阅读《Object Oriented Software Engineering: A Use Case Driven Approach》&lt;/li&gt;
&lt;li&gt;系统的架构图基于用例, 而不是框架&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;良好的架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;围绕用例, 可以在脱离框架、工具和使用环境的情况下完整地描述用例.&lt;/li&gt;
&lt;li&gt;尽可能允许推迟和延后决定细节: 框架、数据库、Web 服务等. 并且容易改变&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Web 只是一种交付手段, 而非架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统应尽量保持它与交付方式之间的无关性&lt;/li&gt;
&lt;li&gt;应该可以将应用程序交付成命令行程序、Web 程序、富客户端程序、Web 服务程序等任何一种形式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;框架是工具而非信条&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;待着怀疑的态度审视每一个框架&lt;/li&gt;
&lt;li&gt;权衡使用框架、保护系统&lt;/li&gt;
&lt;li&gt;保持对系统用例的关注,避免让框架主导架构设计&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可测试的架构设计&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;架构设计应围绕用例展开, 应该可以在不依赖框架、Web 服务、数据库的情况下对用例进行单元测试&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 22 章 整洁架构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;几种架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;六边形架构/端口与适配器架构&lt;/li&gt;
&lt;li&gt;《Growing Object Oriented Software with Tests》&lt;/li&gt;
&lt;li&gt;DCI 架构&lt;/li&gt;
&lt;li&gt;BEC 架构&lt;/li&gt;
&lt;li&gt;《Object Oriented Software Engineering: A Use Case Driven Approach》&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;设计目标: 按照不同的关注点对软件进行切割&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;独立于框架: 框架作为工具而非依赖&lt;/li&gt;
&lt;li&gt;可被测试: 脱离框架、数据库、Web 服务测试&lt;/li&gt;
&lt;li&gt;独立于 UI: UI 变更很容易&lt;/li&gt;
&lt;li&gt;独立于数据库: 轻易替换数据库&lt;/li&gt;
&lt;li&gt;独立于外部机构: 不依赖任何外部接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;整洁架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分层: 中心为高层&lt;/li&gt;
&lt;li&gt;内层: 策略&lt;/li&gt;
&lt;li&gt;外层: 机制&lt;/li&gt;
&lt;li&gt;依赖关系: 由外指向内&lt;/li&gt;
&lt;li&gt;业务实体: 封装关键业务逻辑, 可以是带有方法的对象或一组数据结构和函数的集合&lt;/li&gt;
&lt;li&gt;用例: 特定应用场景下的业务逻辑, 封装了系统的所有用例, 引导业务实体的数据流&lt;/li&gt;
&lt;li&gt;接口适配器: 一组数据转换器, 负责在内部(用例和业务实体)和外部(数据库、Web)之间进行数据转换, 本层内部的同心圆不依赖任何数据库&lt;/li&gt;
&lt;li&gt;框架与驱动程序: 包含所有实现细节(Web 和数据库等), 实现不影响内层, 只有一些与内层沟通的黏合性代码&lt;/li&gt;
&lt;li&gt;跨越边界: 如图像右下角, 控制流从控制器开始, 穿过用例, 最后执行展示器代码&lt;/li&gt;
&lt;li&gt;当用例代码需要调用展示器时, 不能违反依赖关系直接调用, 可以使用依赖反转原则(DIP)来解决.&lt;/li&gt;
&lt;li&gt;跨越边界的数据: 数据结构应独立、简单, 避免直接传递业务实体或数据库记录对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 23 章 展示器和谦卑对象&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;谦卑对象模式: 按照是否难以测试将行为拆分成两组模块, 其中包含系统中所有难以测试的行为的一组模块称为谦卑(Humble)组.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;谦卑对象模式应用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;展示器与视图&lt;/li&gt;
&lt;li&gt;GUI 难以进行单元测试, 但可以利用谦卑对象模式将 GUI 拆分成展示器与视图两部分&lt;/li&gt;
&lt;li&gt;视图: 难以测试的谦卑对象, 代码越简单越好, 只负责将数据填充到 GUI 而不做任何处理&lt;/li&gt;
&lt;li&gt;展示器: 可测试的对象, 负责接收和处理数据, 以便视图将其呈现在屏幕上&lt;/li&gt;
&lt;li&gt;数据库网关&lt;/li&gt;
&lt;li&gt;用例交互器与数据库中间的组件, 是一个多态接口, 包含了应用程序在数据库上要执行的所有操作&lt;/li&gt;
&lt;li&gt;SQL 不应出现在用例层代码中, 需要由数据库网关接口提供, 其实现由数据库层来负责, 这些实现(SQL 或其他数据库提供的接口)属于谦卑对象&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据映射器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ORM(对象关系映射器)只是将数据从关系数据库加载到了对应的数据结构中, 属于数据库层, 是在数据库和数据库网关接口之间构建了一种谦卑对象的边界&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务监听器: 从服务接口中接收并处理数据, 使得数据可以跨服务边界传输. 也属于谦卑对象模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;谦卑对象模式将最难以测试的跨边界的数据交互行为分割出来, 可以大幅提高整个系统的可测试性.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 24 章 不完全边界&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;架构边界的挑战——
引入不完全边界的原因&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建完整的架构边界成本极高: 设计双向多态边界接口、输入输出数据结构、依赖关系管理、分割组件等&lt;/li&gt;
&lt;li&gt;为了应对将来可能的需要, 希望预留边界&lt;/li&gt;
&lt;li&gt;违背YAGNI原则(You aren’t going to need it, 不要预测未来的需要)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构建不完全边界&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;省掉最后一步: 将系统分割为可独立编译、部属的组件之后, 再将其合并起来构建成一个组件&lt;/li&gt;
&lt;li&gt;设计工作量和代码量与构建完整边界相同&lt;/li&gt;
&lt;li&gt;省去了多组件发布管理的工作&lt;/li&gt;
&lt;li&gt;危险性: 组件之间的独立性逐渐降低、隔离弱化&lt;/li&gt;
&lt;li&gt;单向边界: 在设计时就进行必要的依赖反转, 使得跨边界调用保持单向&lt;/li&gt;
&lt;li&gt;危险性: 只能依赖于开发者和架构师的自律性来保证组件的持久隔离&lt;/li&gt;
&lt;li&gt;门户模式: 边界由一个统一的类来定义, 这个类中包含了所有的服务函数列表, 负责将外层的调用传递给外层不可见的服务函数&lt;/li&gt;
&lt;li&gt;危险性: 外层组件传递性地依赖于所有服务函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 25 章 层次与边界&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;本章示例: 将一个简单的小程序逐步扩展为具有系统架构边界的复杂程序&lt;/li&gt;
&lt;li&gt;架构边界可以存在于任何地方, 需要小心审视何时需要设计架构边界&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;困难之处&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完全实现边界需要很高的成本, 且违反 YAGNI 原则, 容易过度设计&lt;/li&gt;
&lt;li&gt;如果事先忽略了某些边界, 后续再添加可能极为困难&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;架构师&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;权衡哪里需要设计架构边界&lt;/li&gt;
&lt;li&gt;权衡需要完整边界 or 不完整的边界&lt;/li&gt;
&lt;li&gt;持续观察系统演进、权衡架构边界成本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 26 章 Main 组件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;负责创建、协调、监督其他组件运转&lt;/li&gt;
&lt;li&gt;最底层、最细节的策略, 没有其他组件依赖于它&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置起始状态、配置信息、加载外部资源, 并将系统控制权交给最高抽象层的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可以以插件形式为系统设计多个 Main 组件对应于不同的配置&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 27 章 服务: 宏观与微观&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;面向服务的架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务只是一种跨进程/平台边界的函数调用, 不一定蕴含架构的意义&lt;/li&gt;
&lt;li&gt;架构是由跨越架构边界的关键函数调用来定义的, 并且必须遵守依赖关系规则&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务的好处谬论&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解耦合&lt;/li&gt;
&lt;li&gt;任何形式的共享数据行为都会导致强耦合&lt;/li&gt;
&lt;li&gt;服务的接口与函数接口类似, 并没有更好&lt;/li&gt;
&lt;li&gt;独立开发部属&lt;/li&gt;
&lt;li&gt;并非服务仅有的特性, 采用单体或组件模式同样可以独立开发和部属&lt;/li&gt;
&lt;li&gt;强耦合的服务并不能真正做到独立开发部属维护&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务与架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统的架构边界在服务内部的组件而不在服务上&lt;/li&gt;
&lt;li&gt;在服务内部应采用遵守依赖关系原则的组件设计方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 28 章 测试边界&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;测试也是一种系统组件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遵守依赖关系原则: 处于最外层, 向内依赖&lt;/li&gt;
&lt;li&gt;测试组件可以独立部署(测试环境)&lt;/li&gt;
&lt;li&gt;支持开发过程, 而非运行过程(往往不会部属到生产环境)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可测试性设计&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脆弱的测试问题&lt;/li&gt;
&lt;li&gt;测试代码与系统强耦合, 系统组件的小变化都需要测试组件做出相应变更&lt;/li&gt;
&lt;li&gt;GUI 是多变的, 通过 GUI 来验证系统的测试一定是脆弱的, 应该让业务逻辑不通过 GUI 也能被测试&lt;/li&gt;
&lt;li&gt;测试专用 API&lt;/li&gt;
&lt;li&gt;拥有超级用户权限, 允许测试代码忽视安全限制、绕过成本高昂的资源(数据库), 强制将系统设置到可测试状态中&lt;/li&gt;
&lt;li&gt;将测试代码从应用程序中分离&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免结构性耦合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果每个产品函数都有一个对应的测试函数, 那么测试套件与应用程序在结构上是紧耦合的, 导致脆弱的测试问题. 测试专用 API 使测试代码与应用程序解耦.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安全性: 具有超级权限的测试专用 API 应该放置在单独的、可独立部属的组件中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 29 章 整洁的嵌入式结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;软件与固件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件本身不会随时间而磨损, 周期很长&lt;/li&gt;
&lt;li&gt;但硬件和固件会随着硬件演进而过时, 进而可能导致软件无法使用.&lt;/li&gt;
&lt;li&gt;固件代码&lt;/li&gt;
&lt;li&gt;对特定硬件平台 API 依赖的代码都属于固件代码, 如未分离业务与系统 API 调用的 Android 开发&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分离固件代码: 延长软件代码的生命周期&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;”程序适用测试“&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果代码只有在特定硬件平台上才能被测试, 那么即使通过了“适用性测试”, 仍不能说其拥有整洁的嵌入式架构. 除非这个产品永远不需要迁移到其他硬件平台&lt;/li&gt;
&lt;li&gt;目标硬件瓶颈: 嵌入式开发面临的特有的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;整洁的嵌入式架构就是可测试的嵌入式架构&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目标硬件瓶颈解决方案&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分层&lt;/li&gt;
&lt;li&gt;硬件、固件、[操作系统]、软件&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;边界&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码与硬件: 边界比较清晰&lt;/li&gt;
&lt;li&gt;软件(操作系统)与固件&lt;/li&gt;
&lt;li&gt;硬件抽象层(HAL): 为软件提供服务, 隐藏硬件实现细节&lt;/li&gt;
&lt;li&gt;软件与操作系统&lt;/li&gt;
&lt;li&gt;操作系统抽象层(OSAL): 隐藏操作系统实现细节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;面向接口编程与可替代性&lt;/li&gt;
&lt;li&gt;模块之间定义接口进行通信&lt;/li&gt;
&lt;li&gt;每一个借口都为平台之外的测试提供替换点&lt;/li&gt;
&lt;li&gt;DRY 条件性编译命令&lt;/li&gt;
&lt;li&gt;问题: 如果程序中多次使用了重复的条件性编译命令来为不同平台启用/禁用一段代码&lt;/li&gt;
&lt;li&gt;方案: 使用硬件抽象层(HAL)隐藏硬件类型, 然后使用链接器或某种运行时加载器进行软硬件组合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第六部分 实现细节&lt;/h2&gt;
&lt;h3&gt;第 30 章 数据库只是实现细节&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据库不是数据模型, 而只是存储数据的工具&lt;/li&gt;
&lt;li&gt;依赖数据库表结构的代码应该被局限在系统架构的最外层的工具函数中&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库溯源: 优化磁盘存储&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件系统: 便于存储和检索文档, 但对文档内容难以关注&lt;/li&gt;
&lt;li&gt;数据库系统: 关注文档/记录的内容/属性&lt;/li&gt;
&lt;li&gt;存储的未来&lt;/li&gt;
&lt;li&gt;基于 RAM, 将数据组织成最合适的数据结构&lt;/li&gt;
&lt;li&gt;基于文件和表格(数据库)的形式被逐渐取代&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统架构不应关心数据在磁盘上如何存储这种实现细节&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;性能考量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能是系统架构的一个考量标准&lt;/li&gt;
&lt;li&gt;数据存储方面的性能是底层问题, 不需要与系统架构相关联&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 31 章 Web 是实现细节&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Web 的振荡式发展&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;将计算资源集中在服务器集群中, 浏览器保持简单&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Web2.0 用 Ajax 和 JavaScript 将很多计算挪到浏览器中执行&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;用 Nodejs 技术将 JavaScript 代码挪回到服务器中执行&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GUI 只是实现细节, 而 Web 是 GUI 中的一种&lt;/li&gt;
&lt;li&gt;作为软件架构师, 需要将其与核心业务逻辑进行隔离&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将 Web 应用抽象为设备无关架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;业务逻辑 -&gt; 一组用例&lt;/li&gt;
&lt;li&gt;用例 -&gt; 输入、处理、输出数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 32 章 应用程序框架是实现细节&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;框架的目的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决框架作者所侧重的一些问题, 而不是解决你的问题——只是这些问题有较大的重合性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单向约定&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发者需要遵守框架的一系列约定&lt;/li&gt;
&lt;li&gt;框架作者不需要遵守什么约定&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;风险&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;框架自身的架构设计可能不正确&lt;/li&gt;
&lt;li&gt;产品的演进可能超出框架提供的能力范围&lt;/li&gt;
&lt;li&gt;框架本身可能朝着我们不需要的方向演进, 被迫进行不必要的升级或悄悄改变了行为&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决方案&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将框架作为实现细节, 不要将其引入内圈&lt;/li&gt;
&lt;li&gt;不要基于框架的基类创建派生类, 可以创造一些代理类作为业务逻辑的插件&lt;/li&gt;
&lt;li&gt;根据依赖关系原则, 将框架作为核心代码的插件&lt;/li&gt;
&lt;li&gt;可以在最外层的 Main 组件中引入、依赖框架&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于不得不接受的框架依赖, 需要慎重决定&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 33 章 案例分析: 视频销售网站&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;识别系统中的各种角色和用例&lt;/li&gt;
&lt;li&gt;角色: 单一职责原则(SRP)&lt;/li&gt;
&lt;li&gt;角色作为系统变更的主要驱动力, 一个角色的变更需求不影响其他角色&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;构造组件架构图&lt;/li&gt;
&lt;li&gt;构建系统架构边界&lt;/li&gt;
&lt;li&gt;分割组件&lt;/li&gt;
&lt;li&gt;每个组件对应一个潜在的独立部署文件, 包含视图、展示器、交互器、控制器文件&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;独立部属&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个组件独立交付部属是否过于繁琐?&lt;/li&gt;
&lt;li&gt;将组件组合为多个交付单元来部属, 如交付为视图、展示器、交互器、控制器和工具类 5 个.jar 文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;依赖关系管理&lt;/li&gt;
&lt;li&gt;控制流: 从控制器输入数据, 经由交互器处理, 再由展示器格式化出结果, 最后由视图展示结果&lt;/li&gt;
&lt;li&gt;依赖关系: 与控制流方向相反, 由低层指向高层&lt;/li&gt;
&lt;li&gt;使用关系: 与控制流一致&lt;/li&gt;
&lt;li&gt;“继承”关系: 与控制流相反&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总结: 架构实现了两个维度上的隔离&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据单一职责原则隔离各个角色&lt;/li&gt;
&lt;li&gt;应用依赖关系原则&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 34 章 拾遗&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;代码结构设计&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;水平分层&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;层次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web 代码&lt;/li&gt;
&lt;li&gt;业务逻辑&lt;/li&gt;
&lt;li&gt;持久化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在项目初期合适, 不会过于复杂; 一旦软件规模扩展, 就需要进一步进行模块化&lt;/li&gt;
&lt;li&gt;问题: 无法展现具体的业务领域信息&lt;/li&gt;
&lt;li&gt;垂直切分&lt;/li&gt;
&lt;li&gt;按功能、业务概念或聚合根(DDD 术语)切分, 每一类放在一个包中, 以业务概念命名&lt;/li&gt;
&lt;li&gt;水平分层与垂直切分都很不好&lt;/li&gt;
&lt;li&gt;隔离业务领域与实现细节(数据库、框架等)&lt;/li&gt;
&lt;li&gt;端口和适配器模式&lt;/li&gt;
&lt;li&gt;六边形架构&lt;/li&gt;
&lt;li&gt;边界、控制器、实体&lt;/li&gt;
&lt;li&gt;按组件封装&lt;/li&gt;
&lt;li&gt;将一个粗粒度组件相关的所有类放入一个包, 类似于微服务架构, 将 UI 与粗粒度组件分离&lt;/li&gt;
&lt;li&gt;新的组件定义: 在一个执行环境（应用程序）中的、一个干净、良好的接口背后的一系列相关功能的集合&lt;/li&gt;
&lt;li&gt;优点: 一类业务的变更只需要修改一个粗粒度组件&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C4 软件架构模型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统由一个或多个容器组成(Web 应用、移动 App、数据库、独立应用、文件系统等)&lt;/li&gt;
&lt;li&gt;容器包含一个或多个组件&lt;/li&gt;
&lt;li&gt;组件包含一个或多个类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将代码分散到不同的代码树&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如端口与适配器架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例 1&lt;/li&gt;
&lt;li&gt;业务代码树: 所有技术和框架无关的代码&lt;/li&gt;
&lt;li&gt;Web 源代码树&lt;/li&gt;
&lt;li&gt;持久化源代码树&lt;/li&gt;
&lt;li&gt;例 2&lt;/li&gt;
&lt;li&gt;业务(Domain)代码(内部)&lt;/li&gt;
&lt;li&gt;基础设施(Infrastructure)代码(外部)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;中心思想: 要将架构设计映射到具体的代码结构上&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;思维导图&lt;/h2&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/3457995e0cfaad5f5403c78a3c1797c5/044d8/CleanArchitecture.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 877.2151898734178%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAACvCAYAAAD9hP67AAAACXBIWXMAABYlAAAWJQFJUiTwAAAL7ElEQVRo3p2byW9jWRXG8w/yHyDECtESEmpALVoNEmoJFggQYtMNGxatlrolFmzYsCmpKKqTqlSqkso820lsJ07iOGNVbOeg30194fj63jfE0tPz+L0zfGe45z5PmXvc3d09PL+5ubGjoyN7/vy5PXnyxJaWlh6+oyP1mIrBbm9v7fj4OJwHg4HNzc3Z/Py8ra2t2bt37yYunAT0V0Syq6urcFxcXIT3m81mkHB3d9dGo5HFvymU8P379+E8HA4D6OXlpS0sLNjLly/t9evXY1JmAf2H/EBS6AKrq6u2vr5um5ubpWpP+Q8BSv0AKbvdru3v71ur1QqS50ALATmw4+npqR0cHATHYM/r6+v6gHi51+s9eLvT6QQJ9d3aKgPEa9Q7Pz8PkuJlr25tCXnNAZXgZqPRsHa7XShlFhA15XXAdnZ2JhxWC5AzakIVSL21tTXmjFo25MyPUXVjY8MWFxcDYErCGHgq/kK/37fDw8Nw5oFD8O7y8nIgdxEHk4AAyCkKvbOzM9vb2wvSQh8+qyQhqgLIa9TjOaDXNzfBw2/fvg325AKVAPGsl5D3sSWgawtv7MWzp7Y8N2vX5/3HAfIgyfbPzqzTbln74MBOjrtmd6NqtPGAqIxj8DRx/PTpU/tuejo8L8rcWUBFCPaC1NiPoygxFALqPQDIMnAR2nCRyrHsAWVHUhdJAROQxX0JqCUhmRoQeEeUYE/Pv9IilXIK6sI/SgAxXcS/SrThNRlaYadwfJSEGB8JiWuqHsBlDkkCIoUyNXFMGUBtYlk5srKEeJHIIKHiXexIpkFC1MZBtSQEEDDvFC4Aod+8eRO8neqDsoDqa7wNkerFixc2Ozsb6klZwzQVtyEeEClPTk5CpJC2sGUtYntAnlNTcBLdwsrKSuCi93QtQG8GAMkySIvnK2ebGBDqAEQsA4aD4GURfbKASl/YDcqoOMW0qSwhgKirPpEIApxCFbcklQF5zSEK4RiaTryec04hINLde/o8SAh1VlZWC5vOQkBAhoNbs7uh9Xpntr6+asvLi2OOqyzhcDiy66tLa+4f29pWx96/u7T5xS3b3Dl8HG0Gw2Eol9uNI5ue24SRtrDStNXNzgcN0v3NBCB8+//iB1uNwvGfmXW7vb2x3EIpmxxIAKQugCEw+bDdbtnzl+t22uvZ+Xk/2NaTOyshgOQ/0QTHYAK4d3jYCrFMKeCieL8UEDoQt3pPVY5Ht3scihXgMQezgHxRgHBQgEiDpMo6hCIxXSphChCpSQq0I1qnkHEwR4o6WUCFHsCAUpOxn3rE1JqP81TcxyjNCxBvcsaz9DcAppa6Ok8AqrJ5CcVRdbG5Gj0hISlJxhagUhcqK8nCTZ6TfGXTJCAf8AMBUk/UZ6tQAaBSgPSYxBeuCUCWsV4V3gMYqaAOJtne3n6QKg7DMUDxTe8pJ95TiP5wEGyHhFwkps2EhAAqOQgQLl5fX9loROa+ZwFSxhImAbEXiWEMcDCwy4sL6/VO7fLqItjMr1R5jQZJlQHEVjGVyDBH/a71L/vWbDRtt7H70NVqLZ0ElPHj1VUfwONuoBTqojbtncidVRnAVNuLlGe9s1A+kYzwjPNhUkLAfNvrvYedkAw+Qps422QB43UKTiKxEnZ87h1R6mV+oEys9+Edh1IZ4CRaLiCnaAWblNDHJZJoDoYdcRgJljQGINLzfS5YCkhi0GupyHtIxXtabog+WS+rCVLQK/CRgs8pYnibJAKwilnWhlptqvPiNUCEJNwjHzJPpFiRSOIWeQwQG8WDIGUhqAL/dAFqTDytm5AQI2t+KAnVTaAmEpJUkcwnh2yRQkIBqpYAhnR4FvthO6SK2+Ksl1WL+YGWFeRIeRzpUoOgbHLwgH58iu0ARsp4bpNVGcbry77QQyVUxbMQ2mekwv6QsBMgQPwQMJGYuhxno0JARYUiBTA+A/jVq1fBMbmephTQdwwAshqF1IAWzbInCr0AUV02xBF4G3VrjVnwpPIcYFIbQIo8EkLsXOdVCqiRAaCEHaBk7CI7ToX0Hq44CchnSIkNSVN4OZ59ZfcC7h+DJCDSQRsSQlwiJiTsHF3Zf2da9t1sx+bmW2OAPCchkFUAo0gplrMqr2/17Ot/rNq3/9ywf/17wwaDcQmRiORA6qeW4OnS9XJKZeih1oStD3Z+SKylMweWWIMhqZ7QG48UVOOMM9T564K1I0U2hDYkV+/dyoA+23hAwo3pUm5uUyl9CZCEiqcBxcMKvdwCMpu+FClECcTG0+RDUhlSY9tSCQH02UaLR5IqjgEQMJWEFH0mnKK07wu7MrWSa2WVtUMh2mhcxYXUganU5ga8E2s93zlokKFRFapiS8DxeKnKHhApBKj1nXKh73kKVY4BeR+qMPyRDT1AqZcBiwE5QxVUlcPiKKlsQ79RiJQQXJWwUuh5wND5n50FABxA+kLSoiJfakN1rPCQXIiEtXYeU15GIp+ta6WvlA0htVapGpo/ClCbM1rNw0PUTk2UsgufmDbaXm+126Emtz7kw1QsJwHVunEGTJFysL9nSwvz1u20x5ZqpbGM3QAiqWrFHt67OLfBZd+ueyfW3Nm2xaWlQPTU/GtCQl0VW2nDkCXt5taWNZp71mg0g7cxjSd4FlC04DkHXsbD62trtry0FOjjy0BhcvCA8rI8jRlIW5A73rSuJKFqiwZBFCkOTU0qTTg9oCIFSSnwdF+EoPamKk3aYwl5jnTaBUJtldpcwZ8Y6sbtnEamHGGuHcVyIbFVi/0WEslBy7K70V29SNGQR14OlOl2A/+2dratc9h5qHpcyBM7uw3nOwceX3/zjX38y1/YJ7/5zH77+9/ZF19+EeoLCRdHxcu0iV0z1Q2d//K3v9pPvv89++lHP7Cff/qp/flPfwzl4NmzZ+Hs91kK73MQ4N+/+sp+9OMf2s8++dh+9evP7A+ffx5imX4RKVFbmQmBCgFHd6MQFUura7a2sWE7O9vWbrXs+OQkvI/X6R3ZpqN2E1WlEvK62WhY60PnoO1NfU8zxqSX45tPfBcGhagtbBiSvZWIK98r4m+G0qYh5J6ZmQmlIF5aJL2cAsTomhFCF27bmp6ertYs5VTmYDVKF0bjicq5nbNCp2iYRtdF0w6QRqqVQi8lIVSQZICidtGGYaENteDWIhy7oTpScqTuKihUWRFAHiRuVQIUJfEQvVRlzRCRDO8CCIhm2UhZWWVlb8jMAMOnfs24U01nqQ0BQTJIjR0VkinHVFIZUqd2bCuVgFhlDuzFOhknxLvftWOZcMOr2kuBMn7EUlpGU8TWBpdmX2VtcRZQo1E5BrpgSxyUmsZXIraGkjgG3iEhqhPbuXtvKqlM54AdOfwGTi1A3xJr1EL4xY6pzEONWUQfSE1i5eB5bRsqG0MdraY0rtKuRS0J/WBc42dyIcUdkkOf2qEnKQDEhiRYPKzdidLlbSqW1bSTbTQVye1+V6YNeU/jKoBT6+bS5KCBrqodHMQhmm7mJiOFd+pq51F21O2/mm/7SVSphL7vRsqLsPvYC3kRtXEO0tYC9Kpo3xQ70t9wruVl34Rqs1pnSI50qbVzKSBpjBhGVZziB261vayl2f2G63mQDC76DevKkaKVFD/EszgB+mhHPGfr0kjhPeii+4n9hK723c7qHFBXs2xAczu3lQo90qEqQCJ00ei50IZQRmQmdQFK4/6oqudvjdG9sCQIPP1oCXkOsCoeIVd2p+nE7dO+FdFOLWqzsKGli++STObD1GTEq0w+1ECt8k3yHlC00QoJQG2D4ByRvpDYfv6FWiKwkgP0wdsceDq3BTKVWh5oeKHRlWZiAAOopim78El1o7qNXzUYtfU/FdT2+wJJwNjQurruPyQ5aOfROyyrcuqvOVq6AqgtdSTTKiubsYsApT5gqO3Xxo8C5DV2pP2gc0Dl0n8u5ADlcTmETK12ruKu2SSgJAQU6SB30Z82soB+O5h4xsP6v1Rqw3+sSOUA/YYr0YPaiufcPDsLqCm7tjoAJ/w0vtcdLsmBZC5a5GkiRrfJoD7JlrLg+ZgFjNXW30k4lHRJDiJ4JRt6Y2sh7sMtFa4C/B8OhyBNRMOINgAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Clean Architecture 思维导图&quot;
        title=&quot;Clean Architecture 思维导图&quot;
        src=&quot;/static/3457995e0cfaad5f5403c78a3c1797c5/f058b/CleanArchitecture.png&quot;
        srcset=&quot;/static/3457995e0cfaad5f5403c78a3c1797c5/c26ae/CleanArchitecture.png 158w,
/static/3457995e0cfaad5f5403c78a3c1797c5/6bdcf/CleanArchitecture.png 315w,
/static/3457995e0cfaad5f5403c78a3c1797c5/f058b/CleanArchitecture.png 630w,
/static/3457995e0cfaad5f5403c78a3c1797c5/40601/CleanArchitecture.png 945w,
/static/3457995e0cfaad5f5403c78a3c1797c5/78612/CleanArchitecture.png 1260w,
/static/3457995e0cfaad5f5403c78a3c1797c5/044d8/CleanArchitecture.png 3366w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[GTD之二：实践要点]]></title><description><![CDATA[经过两个月的 GTD 实践，发现 GTD 其实并不是想象中那么高深和繁琐，只要能做到两个关键点，就可以使整个流程顺利执行下来。 关键点一：收集一切 GTD 的核心目的是解放大脑、提升效率，一旦决定使用 GTD…]]></description><link>https://hrayd.github.io/gtd-2/</link><guid isPermaLink="false">https://hrayd.github.io/gtd-2/</guid><pubDate>Thu, 20 May 2021 22:00:00 GMT</pubDate><content:encoded>&lt;p&gt;经过两个月的 GTD 实践，发现 GTD 其实并不是想象中那么高深和繁琐，只要能做到两个关键点，就可以使整个流程顺利执行下来。&lt;/p&gt;
&lt;h2&gt;关键点一：收集一切&lt;/h2&gt;
&lt;p&gt;GTD 的核心目的是解放大脑、提升效率，一旦决定使用 GTD 系统，就应该完全信赖它，将自己的一切想法第一时间纳入系统：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个新的工作任务&lt;/li&gt;
&lt;li&gt;一个新的学习计划&lt;/li&gt;
&lt;li&gt;一个待办事项&lt;/li&gt;
&lt;li&gt;一篇待阅读文章&lt;/li&gt;
&lt;li&gt;一个刚刚看到的待深入了解的新词汇&lt;/li&gt;
&lt;li&gt;一个学习或生活小窍门&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;就是两个字：一切。将一切想法和事务先放入收集篮并释放大脑，集中精力于当前事务。&lt;/p&gt;
&lt;h2&gt;关键点二：每周回顾&lt;/h2&gt;
&lt;p&gt;这是整个 GTD 系统中唯一需要花费一整段时间的步骤，需要做的有三点（详情参照《GTD 之一：GTD 的理论笔记》）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;清空 &lt;strong&gt;收集篮&lt;/strong&gt;：将收集篮中的事务逐个理清，纳入系统；&lt;/li&gt;
&lt;li&gt;回顾未完成的 &lt;strong&gt;日程表&lt;/strong&gt; 和 &lt;strong&gt;下一步行动清单&lt;/strong&gt;，重新纳入系统；&lt;/li&gt;
&lt;li&gt;回顾 &lt;strong&gt;将来/也许清单&lt;/strong&gt;，决定是否将其纳入系统并开始执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于我个人来说，每周的收集篮大约新增 10 条左右，逐条进行分解和规划，一般在一个小时左右处理完毕，处理完毕后基本上也就将下周任务规划好了。&lt;/p&gt;
&lt;h2&gt;关于工具&lt;/h2&gt;
&lt;p&gt;我个人认为选择工具（此处特指 APP）有以下要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;覆盖个人的全平台；&lt;/li&gt;
&lt;li&gt;APP 数量尽可能少，尽可能集中在三个 APP 以内：如一个清单类、一个导图类、一个笔记类；&lt;/li&gt;
&lt;li&gt;支持标签系统，根据所处场景可以快速找到当前可执行任务&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;标签系统示例&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;地点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;办公室&lt;/li&gt;
&lt;li&gt;家中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时长：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;10 分钟&lt;/li&gt;
&lt;li&gt;30 分钟&lt;/li&gt;
&lt;li&gt;1 小时&lt;/li&gt;
&lt;li&gt;3 小时&lt;/li&gt;
&lt;li&gt;1 天&lt;/li&gt;
&lt;li&gt;3 天&lt;/li&gt;
&lt;li&gt;1 周&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动作类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阅读&lt;/li&gt;
&lt;li&gt;代码&lt;/li&gt;
&lt;li&gt;思考&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[GTD之一：GTD的理论笔记]]></title><description><![CDATA[引言 网络上关于 GTD 系统的文章琳琅满目，但大多都经过了作者的主观简化或加工，本人在最初学习 GTD 时参考了大量的知乎问答和博客专栏，但总是不得要领，没多久 GTD 就变成了单纯的 Todo…]]></description><link>https://hrayd.github.io/gtd-1/</link><guid isPermaLink="false">https://hrayd.github.io/gtd-1/</guid><pubDate>Tue, 09 Mar 2021 22:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;引言&lt;/h2&gt;
&lt;p&gt;网络上关于 GTD 系统的文章琳琅满目，但大多都经过了作者的主观简化或加工，本人在最初学习 GTD 时参考了大量的知乎问答和博客专栏，但总是不得要领，没多久 GTD 就变成了单纯的 Todo 清单，接着就是未完成事项越攒越多，被催促的焦虑感越来越强，最终系统“爆炸”、崩溃。&lt;/p&gt;
&lt;p&gt;在若干次失败之后，决定从头开始把 GTD 作为一门科学的方法论认真学习一遍。“GTD”系统源于一本书籍——《Getting Things Done》，中文书名《搞定》，本文系本书的读书笔记。&lt;/p&gt;
&lt;h2&gt;读书笔记&lt;/h2&gt;
&lt;p&gt;阅读本书用时约 6 小时，本书分为三个部分，Part1 部分的前三章为全书理论核心，基本囊括了 GTD 系统的所有知识；Part2 部分从第 4 章至第 10 章，是将 GTD 每个阶段的具体做法详细讲述了一遍；Part3 部分对 GTD 进行了总结和评价。&lt;/p&gt;
&lt;h3&gt;8 个容器&lt;/h3&gt;
&lt;p&gt;所谓容器，就是事务清单，可以是记录在随身笔记本上的纸质清单，可以是简单便携的手机备忘录，也可以是专业的 GTD 软件产品。&lt;/p&gt;
&lt;p&gt;GTD 系统总的来说是一套周期性流水线式的事务管理方法论，其中涉及 8 个清单，一般的专业 GTD 工具也就是能将以下容器有机结合起来的软件，个人推荐新手使用纸质清单+手机日历的方式来熟悉和执行 GTD。&lt;/p&gt;
&lt;p&gt;8 个容器列举如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;收集篮：未经处理过的原始“材料”，定期清空&lt;/li&gt;
&lt;li&gt;项目清单：决定执行、且需要多步执行的事务清单&lt;/li&gt;
&lt;li&gt;项目计划本：对项目清单中每个项目的行动方案规划&lt;/li&gt;
&lt;li&gt;也许/将来清单：以后可能执行的事务清单&lt;/li&gt;
&lt;li&gt;日程表：记录指定日期或时间需要执行或提醒执行的事务&lt;/li&gt;
&lt;li&gt;下一步行动清单：可执行的待办事项清单&lt;/li&gt;
&lt;li&gt;等待清单：需要等待他人完成才能继续执行的待办事项清单&lt;/li&gt;
&lt;li&gt;参考资料库：个人资料库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在实际的执行中，这 8 个清单也可以进行简化处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;收集篮需要随身携带随手记录，可以用随身小本或手机备忘录作为载体；&lt;/li&gt;
&lt;li&gt;项目清单、项目计划本、也许/将来清单、等待清单都是在每周回顾中对事务进行分析和规划，可以使用一个笔记本或电子版的思维导图或树状清单来实现；&lt;/li&gt;
&lt;li&gt;日程表可以直接使用手机自带日历或全平台的日历 APP(如 outlook)；&lt;/li&gt;
&lt;li&gt;下一步行动清单即传统的待办事项，任何一个有提醒功能的待办事项 APP 都可以；&lt;/li&gt;
&lt;li&gt;参考资料库其实是 GTD 系统之外的个人知识库，可以使用任何带标签和搜索功能的笔记 APP 来实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;事务的横向管理&lt;/h3&gt;
&lt;p&gt;事务的横向管理即对多个事务的并行管理，是 GTD 系统的核心。其流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;收集：收集一切未竟之事加入【收集篮】，清空大脑&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;理清：抽出两个小时以上的时间块，对【收集篮】的事务挨个执行以下述流程进行清空：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;想清楚事情具体是什么，一个目标？一项工作？一次活动？一些资料？&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;事情需要采取行动吗？是转 3，否转 9；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;需要多步行动才能完成吗？若是，加入【项目清单】转 4，否转 5；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;将事务划分为有序或无序的多步行动计划，加入【项目计划本】，转 5；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;明确下一步行动，写入【下一步行动清单】，转 6；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;下一步行动是否可以在两分钟内完成？若是，立即执行，然后继续下一步行动，若否转 7；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;下一步行动是否需要等待他人完成？若是，加入【等待列表】，并在【日程表】中设定下一次跟进时间，若否转 8；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;下一步行动是否在指定日期或时间完成？若是，加入【日程表】；若否，加入【也许/将来清单】；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;是否希望在将来采取行动？若是，加入【也许/将来清单】，若否转 10；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;是否是有意义的参考资料？若是，加入【参考资料库】；若否，扔进垃圾箱。&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每周回顾：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;执行整个理清流程，清空收集篮，更新各清单容器&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;回顾未完成的【日程表】和【下一步行动清单】，重新纳入系统&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;回顾【也许/将来清单】，决定是否开始执行&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;依据场景（办公室、家中）、时间约束、个人状态、重要性等来选择执行&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;可以通过事先给项目、行动打标签的形式来筛选&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;优先执行当日【日程表】、【下一步行动清单】与其他突发紧急事件&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;事务的纵向管理&lt;/h3&gt;
&lt;p&gt;所谓纵向管理，即对单个事务流程的管理，由于每个人的事务所处的领域、规模、专业程度等因素天差地别，很难总结出一套通用的方法，而 GTD 对于事务纵向管理的描述我个人认为过于泛泛而谈，意义有限。但还是将书中内容记录如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务纵向管理的目标：将事务纳入 GTD 系统，清空大脑。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;哪些事务需要计划？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;80%简单的事务：直接列出行动清单，概括预期结果与各阶段行动步骤；&lt;/li&gt;
&lt;li&gt;15%复杂的事务：运用参考资料或辅助工具规划事务；&lt;/li&gt;
&lt;li&gt;5%需要认真权衡的事务：实施如下 &lt;strong&gt;自然计划法&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;自然计划法&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;定义目标与限定条件&lt;/li&gt;
&lt;li&gt;展望成功场景或结果&lt;/li&gt;
&lt;li&gt;头脑风暴/集思广益&lt;/li&gt;
&lt;li&gt;组织整理，将事务划分为有序或无序的若干步骤&lt;/li&gt;
&lt;li&gt;明确 &lt;strong&gt;下一步行动&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;GTD 的执行方案建议&lt;/h2&gt;
&lt;p&gt;首先需要牢记 GTD 的目标：&lt;strong&gt;将一切事务纳入 GTD 系统，清空大脑&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为了达到这一点，一个可随取随用的 &lt;strong&gt;收集篮&lt;/strong&gt; 至关重要，可以选择随身手帐、手机备忘录或其他 APP，我的建议是选择一个全平台的清单应用，当然这个“全平台”是相对个人来说的，我自己日常平台 Mac+iPhone+iPad，收集篮就用 iOS 自带备忘录来做（后来改成了 Things3）。&lt;/p&gt;
&lt;p&gt;另一个重要容器是 &lt;strong&gt;下一步行动清单&lt;/strong&gt; ，理论上任何 Todo 类应用都符合要求，但我建议选择全平台（同收集篮）、支持标签、支持设定开始和截止时间、支持三层以上嵌套的树形清单，如果能支持同步到日历就更好了，可以把 &lt;strong&gt;日程表&lt;/strong&gt; 也合并到一起了。我之前使用 iOS 自带待办事项，但功能上还是过于简陋，就选择了很久以前买的 Things3 来用，一些优秀的待办事项 APP 如 Microsoft ToDo、滴答清单、Any.do、Sorted 等都可以满足要求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;也许/将来清单&lt;/strong&gt;和&lt;strong&gt;等待清单&lt;/strong&gt;也可以合并到待办事项 APP 中，与下一步行动清单的区别是，它们处于等待执行的状态，在每周回顾中进行重新思考，决定执行时再将其转移到项目清单或下一步行动清单中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;项目清单&lt;/strong&gt;、&lt;strong&gt;项目计划本&lt;/strong&gt; 我是使用思维导图来做的，它们的主要任务是在每周回顾中对项目进行规划和分解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料库&lt;/strong&gt; 使用任何笔记类软件都可以，我个人是印象笔记长期用户，也可以选择 OneNote、语雀、Notion 等，我的建议是：至少要支持标签系统、全局搜索和本地数据库。&lt;/p&gt;
&lt;p&gt;当然，在对 GTD 系统熟悉和进阶到一定程度后，也可以选择更为专业的 Omnifocus 神器，我在 Mac 端试用过一段时间，相当满意，但全平台的价格劝退了我。。等以后觉得这套 GTD 系统值得了再做考虑吧。&lt;/p&gt;</content:encoded></item></channel></rss>