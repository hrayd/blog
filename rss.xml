<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[按太阳穴轮刮眼眶]]></title><description><![CDATA[佚树的个人博客]]></description><link>https://hrayd.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Sun, 19 Sep 2021 14:05:52 GMT</lastBuildDate><item><title><![CDATA[ES6+新特性扫盲]]></title><description><![CDATA[ES2021 逻辑赋值运算符 类似于   等运算符:    数字分隔符 允许在数字中间添加下划线  增强可读性. 不允许出现在数字的首尾位置. 如:  注意: 带下划线的 String 类型的数字无法正常转换: Promise.any() 接收一个 Promise…]]></description><link>https://hrayd.github.io/es6+/</link><guid isPermaLink="false">https://hrayd.github.io/es6+/</guid><pubDate>Sat, 11 Sep 2021 22:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;ES2021&lt;/h2&gt;
&lt;h3&gt;逻辑赋值运算符&lt;/h3&gt;
&lt;p&gt;类似于 &lt;code class=&quot;language-text&quot;&gt;+=&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;*=&lt;/code&gt; 等运算符:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;??=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;amp;&amp;amp;=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;||=&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;
a &lt;span class=&quot;token operator&quot;&gt;??=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;flag&quot;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// a = a ?? &quot;flag&quot;&lt;/span&gt;
a &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;flag&quot;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// a = a &amp;amp;&amp;amp; &quot;flag&quot;&lt;/span&gt;
a &lt;span class=&quot;token operator&quot;&gt;||=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;falg&quot;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// a = a || &quot;flag&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;数字分隔符&lt;/h3&gt;
&lt;p&gt;允许在数字中间添加下划线 &lt;code class=&quot;language-text&quot;&gt;_&lt;/code&gt; 增强可读性.&lt;/p&gt;
&lt;p&gt;不允许出现在数字的首尾位置.&lt;/p&gt;
&lt;p&gt;如: &lt;code class=&quot;language-text&quot;&gt;1_000_000&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意: 带下划线的 String 类型的数字无法正常转换:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token function&quot;&gt;Number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1_000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 1000&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;Number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;1_000&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// NaN&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Promise.any()&lt;/h3&gt;
&lt;p&gt;接收一个 Promise 数组, 返回第一个 &lt;code class=&quot;language-text&quot;&gt;fulfilled&lt;/code&gt; 的 Promise 返回值.&lt;/p&gt;
&lt;p&gt;当所有的 Promise 都 &lt;code class=&quot;language-text&quot;&gt;rejected&lt;/code&gt; 时, 进入 &lt;code class=&quot;language-text&quot;&gt;catch&lt;/code&gt; 块并返回 &lt;code class=&quot;language-text&quot;&gt;AggregateError&lt;/code&gt; 类型的错误.&lt;/p&gt;
&lt;p&gt;对比 Promise.race() 是返回第一个 &lt;code class=&quot;language-text&quot;&gt;fulfilled&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;rejected&lt;/code&gt; 的 Promise 返回值.&lt;/p&gt;
&lt;h3&gt;String.replaceAll()&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;String.replace()&lt;/code&gt; 只替换第一次匹配的字符&lt;/p&gt;
&lt;h3&gt;WeakRefs 与 FinalizationRegistry&lt;/h3&gt;
&lt;p&gt;WeakRefs 为对象创建一个弱引用, 弱引用不会组织 JS 引擎垃圾回收期的回收, 一般很少使用.&lt;/p&gt;
&lt;p&gt;使用 FinalizationRegistry 对象可以在垃圾回收器回收对象时, 执行回调函数:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 构建监听对象被垃圾回收器清除的回调&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; registry &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;FinalizationRegistry&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;heldValue&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;----&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; heldValue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; obj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; token &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 注册监听&lt;/span&gt;
registry&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;obj&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;obj deleted!&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; token&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 取消监听&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// registry.unregister(token);&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 可能很久以后，回调执行&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// ---- obj deleted!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;ES 2020&lt;/h2&gt;
&lt;h3&gt;链式判断运算符 &lt;code class=&quot;language-text&quot;&gt;?.&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;支持 &lt;code class=&quot;language-text&quot;&gt;obj?.a?.b?.c&lt;/code&gt; 运算, 当中间某个属性为 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt; 时, 直接返回 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;同时支持 &lt;code class=&quot;language-text&quot;&gt;obj?.[expr]&lt;/code&gt; 方括号形式与 &lt;code class=&quot;language-text&quot;&gt;fun?.(...args)&lt;/code&gt; 函数调用形式.&lt;/p&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;??&lt;/code&gt; 运算符&lt;/h3&gt;
&lt;p&gt;类似于 &lt;code class=&quot;language-text&quot;&gt;||&lt;/code&gt; , 但只有运算符左侧值为 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt; 时才返回右侧值.&lt;/p&gt;
&lt;p&gt;如 &lt;code class=&quot;language-text&quot;&gt;const username = list?.info?.base?.username ?? &amp;#39;user&amp;#39;;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;而 &lt;code class=&quot;language-text&quot;&gt;||&lt;/code&gt; 运算符在左侧为 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;&amp;#39;&amp;#39;&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;0&lt;/code&gt; 时都会返回右侧值.&lt;/p&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;import()&lt;/code&gt; 函数&lt;/h3&gt;
&lt;p&gt;之前的 &lt;code class=&quot;language-text&quot;&gt;import&lt;/code&gt; 只能用在模块顶层, 无法支持动态加载或条件导入模块.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;import()&lt;/code&gt; 函数支持动态加载模块, 返回一个 &lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt; :&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;page &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;home&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;./home.js&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; export1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; export2 &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// 加载成功&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// 加载失败&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;适用于:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按需加载(如点击某按钮)&lt;/li&gt;
&lt;li&gt;条件加载&lt;/li&gt;
&lt;li&gt;动态的模块路径&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;export * as xx from &amp;quot;someModule&amp;quot;&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;相当于以下两个语句:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;import * as xx from &amp;quot;someModule&amp;quot;;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;export {xx};&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;BigInt 类型&lt;/h3&gt;
&lt;p&gt;可精确表示任意位数的整数, BigInt 类型的数据需要添加后缀 &lt;code class=&quot;language-text&quot;&gt;n&lt;/code&gt; .&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; n &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;34242345425325n&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; n &lt;span class=&quot;token comment&quot;&gt;// &quot;bigint&quot;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 作为构造函数&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;BigInt&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3243&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 3243n&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;BigInt&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;324&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 324n&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;BigInt&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 0n&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;BigInt&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 1n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Promise.allSettled()&lt;/h3&gt;
&lt;p&gt;接收一组 Promise 实例作为参数, 当这些 Promise 都返回结果, 无论是 &lt;code class=&quot;language-text&quot;&gt;fulfilled&lt;/code&gt; 还是 &lt;code class=&quot;language-text&quot;&gt;rejected&lt;/code&gt; , 状态都会变为 &lt;code class=&quot;language-text&quot;&gt;fulfilled&lt;/code&gt; , 返回 &lt;code class=&quot;language-text&quot;&gt;[{ status: &amp;quot;fulfilled&amp;quot; | &amp;quot;rejected&amp;quot;, value?: any, reason?: any }]&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; resolved &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Promise&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; rejected &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Promise&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;reject&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; allSettledPromise &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Promise&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;allSettled&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;resolved&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; rejected&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

allSettledPromise&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;results&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// [&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//    { status: &apos;fulfilled&apos;, value: 42 },&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//    { status: &apos;rejected&apos;, reason: -1 }&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://www.notion.so/0c758a80f21045159ebd28652c288c05&quot;&gt;Promise.allSettled(), Promise.all(), Promise.race()&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;String.matchAll()&lt;/h3&gt;
&lt;p&gt;返回一个正则表达式在当前字符串中的所有匹配.&lt;/p&gt;
&lt;p&gt;返回一个迭代器, 可以使用 &lt;code class=&quot;language-text&quot;&gt;for..of&lt;/code&gt; 遍历或使用 &lt;code class=&quot;language-text&quot;&gt;Array.from()&lt;/code&gt; 转为数组遍历.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; regex &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token regex&quot;&gt;&lt;span class=&quot;token regex-delimiter&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token regex-source language-regex&quot;&gt;t(e)(st(\d?))&lt;/span&gt;&lt;span class=&quot;token regex-delimiter&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token regex-flags&quot;&gt;g&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; string &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;test1test2test3&quot;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; r &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; string&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;matchAll&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;regex&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
Array&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;r&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// [[&quot;test1&quot;, &quot;e&quot;, &quot;str1&quot;, &quot;1&quot;],&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//  [&quot;test2&quot;, &quot;e&quot;, &quot;str2&quot;, &quot;2&quot;],&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//  [&quot;test3&quot;, &quot;e&quot;, &quot;str3&quot;, &quot;3&quot;]]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;globalThis&lt;/h3&gt;
&lt;p&gt;全局属性 &lt;code class=&quot;language-text&quot;&gt;globalThis&lt;/code&gt; 包含全局的 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt; 对象.&lt;/p&gt;
&lt;p&gt;以前在不同环境下获取全局 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt; 对象的方法各不相同, 如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Web 中通过 &lt;code class=&quot;language-text&quot;&gt;window&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;self&lt;/code&gt; 获取 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在 WebWorkers 中只能通过 &lt;code class=&quot;language-text&quot;&gt;self&lt;/code&gt; 获取 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在 Nodejs 中需要使用 &lt;code class=&quot;language-text&quot;&gt;global&lt;/code&gt; 获取 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要通过判断各种对象是否存在来获取 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;, 较为繁琐.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;globalThis&lt;/code&gt; 提供了一个标准方式来获取全局 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt; , 在各种环境下都适用.&lt;/p&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;for..in&lt;/code&gt; 定义了明确的顺序&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;for (x in y)&lt;/code&gt; 语句将以规定的顺序执行.&lt;/p&gt;
&lt;h3&gt;import.meta&lt;/h3&gt;
&lt;p&gt;返回带有 &lt;code class=&quot;language-text&quot;&gt;url&lt;/code&gt; 属性的对象, 可获取模块的基础 URL.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;script&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;module&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;module.js&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;script&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;meta&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// { url: &quot;file:///home/user/module.js&quot; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;ES 2019&lt;/h2&gt;
&lt;h3&gt;String.trimStart() / String.trimEnd()&lt;/h3&gt;
&lt;p&gt;单独去掉 String 头或尾部的空白字符.&lt;/p&gt;
&lt;h3&gt;Object.fromEntries()&lt;/h3&gt;
&lt;p&gt;即 &lt;code class=&quot;language-text&quot;&gt;Object.entries()&lt;/code&gt; 的逆过程, 将 &lt;code class=&quot;language-text&quot;&gt;[[key, value]]&lt;/code&gt; 形式的键值对转为对象结构:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; obj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; a&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;aa&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;40&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; entries &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;entries&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;obj&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
entries &lt;span class=&quot;token comment&quot;&gt;// [[&quot;a&quot;, &quot;aa&quot;], [&quot;b&quot;, 40]]&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; obj1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;fromEntries&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;entries&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
obj1 &lt;span class=&quot;token comment&quot;&gt;// {a: &quot;aa&quot;, b: 40}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Array.flat() / Array.flatMap()&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Array.flat([depth = 1]) 按照指定深度展开/铺平数组, 默认深度为 1&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; arr1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
arr1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;flat&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// [1,2,3,4]&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; arr2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
arr2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;flat&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// [1,2,[3,4]]&lt;/span&gt;
arr2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;flat&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// [1,2,3,4]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Array.flatMap() 即 &lt;code class=&quot;language-text&quot;&gt;Array.map()&lt;/code&gt; + &lt;code class=&quot;language-text&quot;&gt;Array.flat(1)&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; arr1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;it&apos;s Sunny in&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;California&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;

arr1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// [[&quot;it&apos;s&quot;,&quot;Sunny&quot;,&quot;in&quot;],[&quot;&quot;],[&quot;California&quot;]]&lt;/span&gt;

arr1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// [&quot;it&apos;s&quot;,&quot;Sunny&quot;,&quot;in&quot;, &quot;&quot;, &quot;California&quot;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;catch 参数可省略&lt;/h3&gt;
&lt;p&gt;支持语法 &lt;code class=&quot;language-text&quot;&gt;try {...} catch {...}&lt;/code&gt; .&lt;/p&gt;
&lt;h3&gt;Symbol.description&lt;/h3&gt;
&lt;p&gt;获取 Symbol 对象创建时的描述信息:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; symbol &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Symbol&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;This is a symbol&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
symbol &lt;span class=&quot;token comment&quot;&gt;// Symbol(This is a symbol)&lt;/span&gt;
symbol&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;description &lt;span class=&quot;token comment&quot;&gt;// &quot;This is a symbol&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;加强 JSON.parse() 与 JSON.stringify()&lt;/h3&gt;
&lt;p&gt;之前 JSON 字符串中包含行分隔符 &lt;code class=&quot;language-text&quot;&gt;\u2028&lt;/code&gt; 或 段落分隔符 &lt;code class=&quot;language-text&quot;&gt;\u2029&lt;/code&gt; 时, 调用 &lt;code class=&quot;language-text&quot;&gt;JSON.parse()&lt;/code&gt; 解析会报错, 修复了这个错误.&lt;/p&gt;
&lt;p&gt;之前对于无效的 UTF-16 字符编码, &lt;code class=&quot;language-text&quot;&gt;JSON.stringify()&lt;/code&gt; 会被替换为无意义的特殊字符, 现在修复了这个错误:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token constant&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;stringify&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;\uD83D&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 之前: &apos;&quot;�&quot;&apos;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 目前: &apos;&quot;\\ud83d&quot;&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Array.sort()更加稳定&lt;/h3&gt;
&lt;p&gt;之前的规范允许不稳定的排序算法如快排, 目前主流浏览器都使用稳定的排序算法, 对于传入的比较算法计算结果等于 0 的情况也能保持顺序稳定.&lt;/p&gt;
&lt;h3&gt;Function.toString() 重新修订&lt;/h3&gt;
&lt;p&gt;之前的 &lt;code class=&quot;language-text&quot;&gt;Function.toString()&lt;/code&gt; 只返回函数主体, 丢失了原始的注释和空格等信息.&lt;/p&gt;
&lt;p&gt;现在 &lt;code class=&quot;language-text&quot;&gt;Function.toString()&lt;/code&gt; 返回的结果与函数编写的一致.&lt;/p&gt;
&lt;h2&gt;ES 2018&lt;/h2&gt;
&lt;h3&gt;for await…of&lt;/h3&gt;
&lt;p&gt;用于遍历异步可迭代对象(也可遍历同步可迭代对象).&lt;/p&gt;
&lt;p&gt;需要放在 &lt;code class=&quot;language-text&quot;&gt;async function&lt;/code&gt; 内部.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 一个异步可迭代对象&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; asyncIterable &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;Symbol&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;asyncIterator&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      i&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; Promise&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; value&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; done&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; Promise&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; done&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 遍历异步可迭代对象&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;n &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; asyncIterable&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;n&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Promise.finally()&lt;/h3&gt;
&lt;p&gt;当 Promise 执行结束时, 无论结果是 fulfilled 还是 rejected, 都会执行 finally 回调.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Promise&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;finally&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Object Rest Properties&lt;/h3&gt;
&lt;p&gt;对象剩余属性:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; obj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; a&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;aa&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; c&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; d&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;others &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; obj
a &lt;span class=&quot;token comment&quot;&gt;// &quot;aa&quot;&lt;/span&gt;
b &lt;span class=&quot;token comment&quot;&gt;// 30&lt;/span&gt;
others &lt;span class=&quot;token comment&quot;&gt;// { c: true, d: &quot;&quot; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;New RegExp Features&lt;/h3&gt;
&lt;p&gt;新增 4 个 RegExp 新特性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Unicode 属性转义 &lt;code class=&quot;language-text&quot;&gt;\p{...}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;后行断言(lookbehind assertion) &lt;code class=&quot;language-text&quot;&gt;(?&amp;lt;=...)&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;(?&amp;lt;!)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可命名捕获组 &lt;code class=&quot;language-text&quot;&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;s (dotAll) Flag, 使用 &lt;code class=&quot;language-text&quot;&gt;s&lt;/code&gt; 标志激活 &lt;code class=&quot;language-text&quot;&gt;.&lt;/code&gt; 字符匹配任意一个字符(dotAll 模式)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;ES 2017&lt;/h2&gt;
&lt;h3&gt;String Padding&lt;/h3&gt;
&lt;p&gt;使用另一个字符串(重复)填充当前字符串, 以达到指定长度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;padStart&lt;/code&gt; 左侧填充&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;padEnd&lt;/code&gt; 右侧填充&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token string&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;padStart&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &quot;       abc&quot;, 默认填充空格&lt;/span&gt;
&lt;span class=&quot;token string&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;padEnd&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &quot;abc       &quot;, 右侧填充&lt;/span&gt;
&lt;span class=&quot;token string&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;padStart&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &quot;foofoofabc&quot;, 用指定字符重复填充&lt;/span&gt;
&lt;span class=&quot;token string&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;padStart&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;12345&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &quot;12abc&quot;, 多余字符丢弃&lt;/span&gt;
&lt;span class=&quot;token string&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;padStart&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &quot;abc&quot;, 若长度小于当前字符串则不变&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Object.entries()&lt;/h3&gt;
&lt;p&gt;返回对象自身(不包括原型链)可枚举属性的键值对数组:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; o &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; a&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;aaa&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;entries&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;o&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// [[&apos;a&apos;, &apos;aaa&apos;], [&apos;b&apos;, 20]]&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; value&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; Object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;entries&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;o&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;key&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;: &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;value&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与 &lt;code class=&quot;language-text&quot;&gt;for..in&lt;/code&gt; 循环的顺序一致, 但 &lt;code class=&quot;language-text&quot;&gt;for..in&lt;/code&gt; 循环会枚举原型链中的属性.&lt;/p&gt;
&lt;h3&gt;Object.values()&lt;/h3&gt;
&lt;p&gt;返回对象自身的所有可枚举属性值的数组:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; o &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; a&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;aaa&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;o&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// [&quot;aaa&quot;, 20]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Async Functions&lt;/h3&gt;
&lt;p&gt;使用 &lt;code class=&quot;language-text&quot;&gt;async&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;await&lt;/code&gt; 关键字更简洁地书写基于 &lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt; 的异步行为.&lt;/p&gt;
&lt;h3&gt;Object.getOwnPropertyDescriptor()&lt;/h3&gt;
&lt;p&gt;获取对象的一个自有属性的属性描述符:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; obj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; a&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;aaa&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
Object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getOwnPropertyDescriptor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;obj&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// {value: &apos;aaa&apos;, writable: true, enumerable: true, configurable: true}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;函数参数列表中的尾随逗号&lt;/h3&gt;
&lt;p&gt;允许在函数声明和函数调用的参数列表中使用尾随逗号:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;v1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; v2&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;t1&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;t2&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同时也支持对象字面量和数组字面量后的逗号.&lt;/p&gt;
&lt;h3&gt;SharedArrayBuffer 和 Atomics&lt;/h3&gt;
&lt;p&gt;WebWorkers 可以创建多线程程序, 使用 &lt;code class=&quot;language-text&quot;&gt;SharedArrayBuffer&lt;/code&gt; 创建共享数组缓冲区, 使得多个 workers 和主线程之间可以共享数据.&lt;/p&gt;
&lt;p&gt;全局对象 &lt;code class=&quot;language-text&quot;&gt;Atomics&lt;/code&gt; 提供了一组静态方法对 &lt;code class=&quot;language-text&quot;&gt;SharedArrayBuffer&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;ArrayBuffer&lt;/code&gt; 进行原子操作, 使得多个线程可以按规定顺序安全地读写同一位置的数据.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了防止 Spectre 漏洞, 所有主流浏览器默认禁用 SharedArrayBuffer .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;ES 2016&lt;/h2&gt;
&lt;h3&gt;求幂运算符 **&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;let x = 2 ** 5;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;等价于 &lt;code class=&quot;language-text&quot;&gt;Math.pow(x, y)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;“幂等”运算符 &lt;code class=&quot;language-text&quot;&gt;**=&lt;/code&gt; , 如:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;python&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;let x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
x &lt;span class=&quot;token operator&quot;&gt;**=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;//&lt;/span&gt; 相当于x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Array.includes()&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;python&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;let arr &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;3&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
arr&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;includes&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;token operator&quot;&gt;//&lt;/span&gt; true
arr&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;includes&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;4&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;token operator&quot;&gt;//&lt;/span&gt; false&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;ES6 (ES2015)&lt;/h2&gt;
&lt;h3&gt;关键字和类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt; 与 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt; 声明&lt;/li&gt;
&lt;li&gt;箭头函数&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;for/of&lt;/code&gt; 遍历可迭代的数据结构: Array, String, Map, NodeList 等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;区分 &lt;code class=&quot;language-text&quot;&gt;for/in&lt;/code&gt; : 遍历所有可枚举属性, 适用于遍历 Object 属性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Map&lt;/code&gt; 对象&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Set&lt;/code&gt; 对象&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;class&lt;/code&gt; “面向对象”相关方法实现&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Symbol&lt;/code&gt; 基本类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Function&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Function 参数默认值 &lt;code class=&quot;language-text&quot;&gt;function fn(x = 2){...}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Function 剩余参数 &lt;code class=&quot;language-text&quot;&gt;function fn(a, b, ...others) {...}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;String&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;String.includes()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;String.startsWith()&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;String.endsWith()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Array&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.from()&lt;/code&gt; 从具有长度或可迭代的对象创建数组, 如 Set, String 等&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.keys()&lt;/code&gt; 返回数组的索引迭代器&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.find()&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;Array.findIndex()&lt;/code&gt; 返回满足测试函数的第一个元素 / 元素索引.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Math&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Math.trunc()&lt;/code&gt; 截取整数部分&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Math.sign()&lt;/code&gt; 返回数字的符号, 取值: 1, -1, 0, -0, NaN, 传入参数会被隐式转换为数字.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Math.cbrt()&lt;/code&gt; 立方根&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Math.log2()&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;Math.log10()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Number&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Number.EPSILON&lt;/code&gt; 最小精度值, 两数之差小于此值可认为两数相等.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Number.MIN_SAFE_INTEGER&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt; 安全整数范围&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Number.isInteger()&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;Number.isSafeInteger()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Global Methods&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;isFinite()&lt;/code&gt; 参数为 &lt;code class=&quot;language-text&quot;&gt;Infinity&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;NaN&lt;/code&gt; 是返回 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;, 其他情况为 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;isNaN()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Object&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Object.entries()&lt;/code&gt; 返回对象可枚举属性的键值对数组&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const o = { a: &amp;quot;aa&amp;quot;, b: 2 };
console.log(Object.entries(o));  // [[&amp;quot;a&amp;quot;, &amp;quot;aa&amp;quot;], [&amp;quot;b&amp;quot;, 2]]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;JavaScript Modules&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules&quot;&gt;JavaScript modules - JavaScript | MDN&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[HTTP之三：安全的HTTPS]]></title><description><![CDATA[HTTP 不安全: 明文传输, 任何人都能在链路中截取修改, 伪造请求/响应报文. 安全 的四个特性: 机密性: 非可信人不可见 完整性: 传输过程无窜改丢失 身份认证: 确保消息只能发送给指定身份 不可否认: 保证事务的真实性 HTTPS 为 HTTP…]]></description><link>https://hrayd.github.io/http-3/</link><guid isPermaLink="false">https://hrayd.github.io/http-3/</guid><pubDate>Wed, 25 Aug 2021 22:00:00 GMT</pubDate><content:encoded>&lt;p&gt;HTTP 不安全: 明文传输, 任何人都能在链路中截取修改, 伪造请求/响应报文.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全&lt;/strong&gt; 的四个特性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;机密性: 非可信人不可见&lt;/li&gt;
&lt;li&gt;完整性: 传输过程无窜改丢失&lt;/li&gt;
&lt;li&gt;身份认证: 确保消息只能发送给指定身份&lt;/li&gt;
&lt;li&gt;不可否认: 保证事务的真实性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;HTTPS&lt;/strong&gt; 为 HTTP 添加了以上四个安全特性.&lt;/p&gt;
&lt;p&gt;HTTPS 除了协议名与默认端口 443, 协议的具体内容结构完全沿用 HTTP.&lt;/p&gt;
&lt;p&gt;HTTPS 中的”S”表示将 HTTP 下层的传输协议由 &lt;strong&gt;TCP/IP&lt;/strong&gt; 换成了 &lt;strong&gt;SSL/TLS&lt;/strong&gt; , 收发报文不再使用 Socket API, 而是调用专门的安全接口.&lt;/p&gt;
&lt;h2&gt;SSL/TLS 常识&lt;/h2&gt;
&lt;p&gt;SSL(Secure Sockets Layer)由网景公司发明, 在 v3 版本时被正式标准化并更名为 TLS(Transport Layer Security). TLS1.0 即 SSLv3.1&lt;/p&gt;
&lt;p&gt;TLS 已发布了 1.1(2006), 1.2(2008)和 1.3(2018)三个版本, 目前使用最广泛的是 TLS1.2.&lt;/p&gt;
&lt;p&gt;TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成， 综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。&lt;/p&gt;
&lt;p&gt;客户端和服务器各自都支持很多加密算法组合, 这些算法组合称为 &lt;strong&gt;密码套件(cipher suite)&lt;/strong&gt; .&lt;/p&gt;
&lt;p&gt;密码套件由特定顺序的算法名称构成, 格式为 &lt;code class=&quot;language-text&quot;&gt;密钥交换算法-签名算法-对称加密算法-摘要算法&lt;/code&gt;. 如:&lt;/p&gt;
&lt;p&gt;密码套件 &lt;code class=&quot;language-text&quot;&gt;ECDHE-RSA-AES256-GCM-SHA384&lt;/code&gt; 表示 “握手时使用 &lt;code class=&quot;language-text&quot;&gt;ECDHE&lt;/code&gt; 算法进行密钥交换，用 &lt;code class=&quot;language-text&quot;&gt;RSA&lt;/code&gt; 签名和身份认证，握手后的通信使用 &lt;code class=&quot;language-text&quot;&gt;AES&lt;/code&gt; 对称算法，密钥长度 256 位，分组模式是 &lt;code class=&quot;language-text&quot;&gt;GCM&lt;/code&gt;，摘要算法 &lt;code class=&quot;language-text&quot;&gt;SHA384&lt;/code&gt; 用于消息认证和 产生随机数”.&lt;/p&gt;
&lt;p&gt;在客户端和服务器使用 TLS 建立连接时, 会进行协商, 选择一组恰当的密码套件来进行安全通信.&lt;/p&gt;
&lt;h3&gt;OpenSSL&lt;/h3&gt;
&lt;p&gt;开源的密码学程序库和工具包, 是 SSL/TLS 的具体实现. 几乎支持所有公开的加密算法和协议, 是事实上的标准.&lt;/p&gt;
&lt;p&gt;Nginx, Apache 等常用服务器和软件都使用 OpenSSL 实现 TLS 功能.&lt;/p&gt;
&lt;h2&gt;机密性: 对称加密与非对称加密&lt;/h2&gt;
&lt;h3&gt;对称加密&lt;/h3&gt;
&lt;p&gt;指加密和解密使用同一个密钥&lt;/p&gt;
&lt;p&gt;TLS 中常用的对称加密算法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AES: 应用最广泛的对称加密算法, 密钥长度可以 128,192 或 256 位, 安全性和性能都高&lt;/li&gt;
&lt;li&gt;ChaCha20: Google 设计, 密钥长度固定 256 位, 纯软件性能优于 AES, 但 AES 具有硬件优化, 所以目前相比 AES 不具有明显优势.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分组模式: 使算法可以用固定长度的密钥加密任意长度的明文, 最新的分组模式称为 &lt;strong&gt;AEAD&lt;/strong&gt; , 加密的同时添加了认证功能, 常用的有: &lt;code class=&quot;language-text&quot;&gt;GCM&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;CCM&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;Poly1305&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;对称加密算法 + 分组模式构成了 TLS 密码套件中定义的对称加密算法, 如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;AES128-GCM&lt;/code&gt; 128 位密钥长度的 AES 算法, 分组模式是 GCM&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;ChaCha20-Poly1305&lt;/code&gt; ChaCha20 算法, 分组模式是 Poly1305&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;非对称加密&lt;/h3&gt;
&lt;p&gt;对称加密的问题: 密钥交换过程难以保障机密性.&lt;/p&gt;
&lt;p&gt;非对称加密: 具有公钥和私钥, 公钥加密只能私钥解密, 私钥加密只能公钥解密.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公钥: 可以公开给任何人, 任何人都可以加密&lt;/li&gt;
&lt;li&gt;私钥: 必须严格保密, 用于解密&lt;/li&gt;
&lt;li&gt;私钥加密公钥解密用于后文的 &lt;strong&gt;数字签名&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非对称加密算法设计比对称算法难得多, TLS 只有少数几种, 常用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RSA: 最有名的对称加密算法, 基于”整数分解”数学难题, 使用两个超大素数乘积作为生成密钥的材料, 推荐长度 1024, 目前普遍认为至少 2048 位.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ECC: 基于”椭圆曲线离散对数”, 用特定的曲线方程和基点生成公私钥, 在安全强度和性能上都明显就优于 RSA, 160 位 ECC 相当于 1024 位 RSA, 密钥短意味着计算量和所需内存带宽就少. 常用曲线:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;P-256: NIST 和 NSA 推荐使用, 密码学界不信任&lt;/li&gt;
&lt;li&gt;x25519: 被认为是最安全最快速的曲线&lt;/li&gt;
&lt;li&gt;secp256k1: 比特币, 以太坊灯区块链技术中使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;混合加密&lt;/h3&gt;
&lt;p&gt;非对称加密虽然没有”密钥交换”问题, 但运算速度通常比对称加密慢好几个数量级, 经试验 ECC 比 AES 慢了好几百倍.&lt;/p&gt;
&lt;p&gt;TLS 中使用的 &lt;strong&gt;混合加密&lt;/strong&gt; : 通信开始时使用非对称加密进行密钥交换, 之后使用对称加密.&lt;/p&gt;
&lt;h2&gt;完整性和身份认证&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;完整性问题: 如何保证接收到的消息没有被篡改?&lt;/li&gt;
&lt;li&gt;身份认证: 如何确保通信双方身份真实可信?&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;完整性: 摘要算法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;摘要算法&lt;/strong&gt;: 即散列/哈希函数, 将任意长度数据压缩成固定长度且唯一的字符串.&lt;/p&gt;
&lt;p&gt;单向算法, 无法解密逆推原文.&lt;/p&gt;
&lt;p&gt;常用摘要算法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MD5, SHA-1, 安全强度较低, 在 TLS 已禁用&lt;/li&gt;
&lt;li&gt;SHA-2: TLS 推荐使用, 是六种摘要算法的统称, 常用: &lt;code class=&quot;language-text&quot;&gt;SHA224&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;SHA256&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;SHA384&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完整性校验: 原文+摘要, 通过原文计算摘要并进行对比.&lt;/p&gt;
&lt;p&gt;摘要算法不具备机密性, 建立在机密性之上的完整性: 用会话密钥加密消息和摘要.&lt;/p&gt;
&lt;h3&gt;身份认证: 数字签名&lt;/h3&gt;
&lt;p&gt;签名: 使用非对称加密的 &lt;strong&gt;私钥&lt;/strong&gt; 来加密 &lt;strong&gt;摘要&lt;/strong&gt; , 得到 &lt;strong&gt;数字签名&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;验签: 数字签名与公钥一样公开, 只有与私钥对应的公钥才能解密得到摘要, 再对比原文验证完整性, 就可以确保通信双方身份和通信内容正确.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一般可以用时间戳和随机数结合做不可逆签名, 避免请求被拦截并重复发送.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;公钥的可信性: 数字证书&lt;/h3&gt;
&lt;p&gt;如何确保得到的公钥就是指定通信方的公钥? 只能通过第三方构建公钥的信任链.&lt;/p&gt;
&lt;p&gt;这个第三方就是 &lt;strong&gt;CA&lt;/strong&gt;, 即 Certificate Authority, 证书认证机构.&lt;/p&gt;
&lt;p&gt;CA 对各公钥进行签名, 用自己的信誉保证公钥可信. CA 机构有: DigiCert、VeriSign、Entrust、Let’s Encrypt 等.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Let’s Encrypt 可颁发免费的 90 天的 DV 证书, 可以用 Certbot 自动续订.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CA 将公钥,序列表,用途,颁发者,有效时间等公钥关联信息打包并签名, 形成 &lt;strong&gt;数字证书&lt;/strong&gt; .&lt;/p&gt;
&lt;p&gt;证书分类:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DV: 可信度最低, 域名级可信&lt;/li&gt;
&lt;li&gt;OV: 可信度在中间&lt;/li&gt;
&lt;li&gt;EV: 可信度最高, 经过法律和审计的核查可证明网站拥有者身份, 浏览器地址栏会显示公司名称&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CA 的信任链: 小的 CA 通过大 CA 进行签名认证, 但最终的 &lt;strong&gt;Root CA&lt;/strong&gt; 只能通过 &lt;strong&gt;自签名证书&lt;/strong&gt; 或 &lt;strong&gt;根证书&lt;/strong&gt; 自己证明自己.&lt;/p&gt;
&lt;p&gt;操作系统和浏览器内置了各大 CA 的根证书, 对于服务器发送的证书, 可以顺着证书链层层校验直到找到根证书, 就能够确定证书可信.&lt;/p&gt;
&lt;p&gt;证书体系(PKI)弱点: 如果 CA 主动或被动颁发了错误证书, 如何弥补?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CRL: Certificate revocation list, 证书吊销列表&lt;/li&gt;
&lt;li&gt;OCSP: Online certificate status protocol, 在线证书状态协议&lt;/li&gt;
&lt;li&gt;终止信任: 直接从操作系统或浏览器中撤销对根 CA 的信任&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;TLS1.2 的握手过程&lt;/h2&gt;
&lt;h3&gt;基于 ECDHE 密钥交换算法的握手过程&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;ECDHE: 使用椭圆曲线增强的非对称加密 DH 算法, 公钥私钥都是临时生成的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;客户端向服务器发送 “Client Hello” 消息:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Version&lt;/code&gt; 客户端 TLS 版本号 &lt;code class=&quot;language-text&quot;&gt;TLS 1.2 (0x0303)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Random&lt;/code&gt; 客户端随机数, 用于后续生成会话秘钥&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Cipher Suites&lt;/code&gt; 客户端支持的密码套件列表&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 抓包数据
Handshake Protocol: Client Hello
   Version: TLS 1.2 (0x0303)
   Random: 1cbf803321fd2623408dfe...
   Cipher Suites (17 suites)
       Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)
       Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器向客户端返回 “Server Hello” 消息:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Version&lt;/code&gt; 确认 TLS 版本号&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Random&lt;/code&gt; 服务器随机数&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Cipher Suite&lt;/code&gt; 从客户端的密码套件列表中选择一项作为本次通信使用的密码套件&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Server Certificate&lt;/code&gt; 服务器证书&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Server Params&lt;/code&gt; 密钥交换算法参数 + 私钥签名认证&lt;/li&gt;
&lt;li&gt;“Server Hello Done”&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 抓包数据
Handshake Protocol: Server Hello
	Version: TLS 1.2 (0x0303)
 Random: 0e6320f21bae50842e96...
 Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)
Handshake Protocol: Server Key Exchange
	EC Diffie-Hellman Server Params
	Curve Type: named_curve (0x03)
	Named Curve: x25519 (0x001d)
	Pubkey: 3b39deaf00217894e...
	Signature Algorithm: rsa_pkcs1_sha512 (0x0601)
	Signature: 37141adac38ea4...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端通过证书链确认证书的真实性, 再用证书公钥验证签名, 得到 &lt;code class=&quot;language-text&quot;&gt;Server Params&lt;/code&gt;. 同时客户端也生成一个 &lt;code class=&quot;language-text&quot;&gt;Client Params&lt;/code&gt; (密钥交换算法参数)发送给服务器:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Handshake Protocol: Client Key Exchange
	EC Diffie-Hellman Client Params
		Pubkey: 8c674d0e08dc27b5eaa...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时客户端和服务器都得到了密钥交换算法的两个参数 &lt;code class=&quot;language-text&quot;&gt;Client Params&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;Server Params&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;客户端和服务端各自利用这两个参数经密钥交换算法(ECDHE)计算得到随机数 &lt;code class=&quot;language-text&quot;&gt;Pre-Master&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;再将得到的三个随机数 &lt;code class=&quot;language-text&quot;&gt;Client Random&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;Server Random&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;Pre-Master&lt;/code&gt; 作为参数, 通过密码套件中的伪随机函数计算得到加密会话的 48 字节的主秘钥 &lt;code class=&quot;language-text&quot;&gt;Master Secret&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;再通过 &lt;code class=&quot;language-text&quot;&gt;PRF&lt;/code&gt; 扩展出 &lt;code class=&quot;language-text&quot;&gt;client_write_key&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;server_write_key&lt;/code&gt; 等会话秘钥.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端再次向服务器发送两个消息:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Change Cipher Spec&lt;/code&gt; 通知服务器之后改用会话秘钥加密通信&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Finished&lt;/code&gt; 之前的所有握手数据进行摘要加密, 发送给服务器进行确认&lt;/li&gt;
&lt;li&gt;使用 ECDHE 实现密钥交换算法时, 此时可以将 HTTP 请求一同发送&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器验证握手数据摘要, 并发送消息进行确认:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Change Cipher Spec&lt;/code&gt; 之后改用会话秘钥加密通信&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Finished&lt;/code&gt; 所有握手数据的摘要&lt;/li&gt;
&lt;li&gt;使用 ECDHE 时可一同发送 HTTP 响应&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;握手正式结束, 之后收发加密的 HTTP 请求和响应.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;传统的基于 RSA 的握手过程&lt;/h3&gt;
&lt;p&gt;与基于 ECDHE 的握手过程类似, 只是 &lt;code class=&quot;language-text&quot;&gt;Pre-Master&lt;/code&gt; 不需要通过算法生成, 而是由客户端直接生成随机数, 经服务器公钥加密后通过 “Client Key Exchange” 消息发给服务器, 服务器用私钥解密后双方就实现了共享三个随机数, 生成主秘钥.&lt;/p&gt;
&lt;h3&gt;双向认证&lt;/h3&gt;
&lt;p&gt;TLS 握手只认证了服务器的身份, 之后可以通过账号, 密码, 验证码等进行客户端身份认证.&lt;/p&gt;
&lt;p&gt;对于高安全性场景下, 会使用 U 盾给用户颁发客户端证书, 实现 &lt;strong&gt;双向认证&lt;/strong&gt; .&lt;/p&gt;
&lt;p&gt;双向认证是在 TLS 握手的 “Server Hello Done” 和 “Client Key Exchange” 之间, 由客户端向服务器发送 “Client Certificate” 消息, 服务器收到证书后根据证书链验证客户端身份.&lt;/p&gt;
&lt;h2&gt;TLS1.3&lt;/h2&gt;
&lt;p&gt;TLS1.3 的主要改进目标: 兼容、安全、性能.&lt;/p&gt;
&lt;p&gt;目前各大浏览器和服务器都支持了 TLS1.3&lt;/p&gt;
&lt;h3&gt;兼容性&lt;/h3&gt;
&lt;p&gt;在早期试验中, 一旦将 TLS 头字段中的 &lt;code class=&quot;language-text&quot;&gt;Version&lt;/code&gt; 改为 TLS1.3(0x304), 会导致大量服务器、网关无法处理, 导致 TLS 握手失败.&lt;/p&gt;
&lt;p&gt;为了兼容性, TLS1.3 仍然使用 TLS1.2 的格式, 通过在记录末尾添加一系列扩展字段来增加新功能, 如在握手的 “Hello” 消息后必须有 &lt;code class=&quot;language-text&quot;&gt;supported_versions&lt;/code&gt; 字段来标记 TLS 版本号:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;Handshake Protocol&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Client Hello
    Version&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;TLS&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1.2&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0x0303&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    Extension&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;supported_versions&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;len&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        Supported Version&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;TLS&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1.3&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0x0304&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        Supported Version&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;TLS&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1.2&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0x0303&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TLS1.3 的很多功能都是通过扩展字段实现的, 见下文的 &lt;strong&gt;性能&lt;/strong&gt; 部分.&lt;/p&gt;
&lt;h3&gt;安全&lt;/h3&gt;
&lt;p&gt;TLS1.3 修补了 TLS1.2 中的很多不安全因素, 升级了一些加密算法, 也废除了很多被证明不安全的算法, 最终只保留了:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对称加密算法: AES、ChaCha20&lt;/li&gt;
&lt;li&gt;分组模式: AEAD 的 GCM、CCM 和 Poly1305&lt;/li&gt;
&lt;li&gt;摘要算法: SHA256、SHA384&lt;/li&gt;
&lt;li&gt;密钥交换算法: ECDHE、DHE&lt;/li&gt;
&lt;li&gt;椭圆曲线: P-256、x25519 等 5 种&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;加密套件也只有 5 个, 有利于客户端和服务器的选择.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 ECDHE 替代 RSA 的原因: RSA 不具备“前项安全”, 一旦拿到了私钥, 就能够破解之前所有的密文. 而 ECDHE 每次握手都生成临时的公私钥, 就算被破解, 也只是一次通信.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;性能&lt;/h3&gt;
&lt;p&gt;将 TLS1.2 的 两个消息往返减少为 1 个(1-RTT), 效率提升了一倍.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TLS1.3 的握手过程中, 客户端在 “Client Hello”中直接在扩展字段 “supported&lt;em&gt;groups” 中写明支持的曲线, 并在 “key&lt;/em&gt;share” 中附带曲线对应的客户端公钥参数, 用 “signature&lt;em&gt;algorithms“ 带上签名算法; 服务器收到后选定一个曲线和参数, 再用 “key&lt;/em&gt;share” 返回服务器的公钥参数, 就实现了密钥交换. 之后的流程与 TLS1.2 相同.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除此之外, TLS1.3 还引入了 “0-RTT” 握手, 满足一些条件时可以在 TCP 连接后立即建立安全连接发送加密消息.&lt;/p&gt;
&lt;h2&gt;HTTPS 的性能优化&lt;/h2&gt;
&lt;h3&gt;影响 HTTPS 性能的主要因素&lt;/h3&gt;
&lt;p&gt;分析 TLS 握手过程可知, HTTPS 中较为影响性能的过程有:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比 HTTP 增加的 TLS 握手过程, 两个消息往返即 2-RTT;&lt;/li&gt;
&lt;li&gt;产生(计算)用于密钥交换的临时公私钥对;&lt;/li&gt;
&lt;li&gt;验证证书过程: 访问 CA 获取 CRL 或 OCSP;&lt;/li&gt;
&lt;li&gt;非对称加解密(计算) “Pre-Master”.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;硬件优化&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;HTTPS 连接是计算密集型而非 I/O 密集型, 所以提升网卡、带宽和存储作用不大.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更快的 CPU, 可内建 AES 优化来加速握手和传输;&lt;/li&gt;
&lt;li&gt;SSL 加速卡, 使用专门的硬件做非对称加解密;&lt;/li&gt;
&lt;li&gt;SSL 加速服务器, 专用于 TLS 加解密计算的服务器集群, 性能强大.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;软件升级&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;升级 Linux 内核、Nginx、OpenSSL 版本等;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;协议优化&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;尽量采用 TLS1.3, 完全握手只需 1-RTT;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若只能用 TLS1.2, 可在服务器中配置:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽量选用椭圆曲线的 ECDHE 算法, 把握手过程减少到 1-RTT;&lt;/li&gt;
&lt;li&gt;椭圆曲线可选择高性能的 x25519 曲线;&lt;/li&gt;
&lt;li&gt;对称加密算法可采用“AES&lt;em&gt;128&lt;/em&gt;GCM”.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;证书优化&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;证书传输过程: 可以使用 ECDSA 证书而非 RSA 证书, 节约带宽;&lt;/li&gt;
&lt;li&gt;证书验证过程: 可以使用 “OCSP Stapling”是服务器预先访问 CA 获取 OCSP 响应并发给客户端, 免去客户端连接 CA 验证证书的过程.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;会话复用(Session Ticket)&lt;/h3&gt;
&lt;p&gt;HTTPS 建立连接时, 先是 TCP 三次握手, 再是 TLS 一次握手, 同时每次连接都要重新计算主密钥, 很影响性能. 可以通过 &lt;strong&gt;会话复用&lt;/strong&gt; 在一次会话中缓存主密钥.&lt;/p&gt;
&lt;p&gt;会话复用分为两种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Session ID&lt;/strong&gt;: 客户端和服务器首次连接后各自保存一个会话 ID, 并存储主密钥和其他信息; 当再次连接时可以用主密钥恢复会话状态, 跳过证书验证和密钥交换, 用一个消息往返建立安全通信.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缺点: 对于超大用户量级别的网站来说, 服务器负担过大.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Session Ticket&lt;/strong&gt;: 服务端向客户端发送 “New Session Ticket”, 由客户端保存; 再次连接时, 客户端使用 “session_ticket” 发送 “Ticket”, 有服务器解密验证后可以恢复会话开始加密通信.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要一个固定的密钥文件来加密 Ticket, 为了保证前向安全, 此密钥文件需要定期轮换.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;预共享密钥(Pre-shared Key)&lt;/h3&gt;
&lt;p&gt;原理与 &lt;strong&gt;Session Ticket&lt;/strong&gt; 类似, 发送 Ticket 时会同时带上 &lt;strong&gt;Early Data&lt;/strong&gt; , 从而实现“0-RTT”.&lt;/p&gt;
&lt;p&gt;但牺牲了安全性, 权衡方案是只允许安全的 GET/HEAD 方法, 并在消息中加入时间戳、“nonce”验证或“一次性票证”.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[HTTP之二：HTTP Headers]]></title><description><![CDATA[数据类型与编码 MIME type 全称“多用途互联网邮件扩展”(Multipurpose Internet Mail Extensions), 用于标记 body 的数据类型, 形式是  的字符串, 常用的有: text:    image:    audio/video…]]></description><link>https://hrayd.github.io/http-2/</link><guid isPermaLink="false">https://hrayd.github.io/http-2/</guid><pubDate>Tue, 10 Aug 2021 22:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;数据类型与编码&lt;/h2&gt;
&lt;h3&gt;MIME type&lt;/h3&gt;
&lt;p&gt;全称“多用途互联网邮件扩展”(Multipurpose Internet Mail Extensions), 用于标记 body 的数据类型, 形式是 &lt;code class=&quot;language-text&quot;&gt;type/subtype&lt;/code&gt; 的字符串, 常用的有:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;text: &lt;code class=&quot;language-text&quot;&gt;text/html&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;text/css&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;text/plain&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;image: &lt;code class=&quot;language-text&quot;&gt;image/gif&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;image/jpeg&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;image/png&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;audio/video: &lt;code class=&quot;language-text&quot;&gt;audio/mpeg&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;video/mp4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;application: &lt;code class=&quot;language-text&quot;&gt;application/json&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;application/javascript&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;application/pdf&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;application/octet-stream&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;数据编码/压缩&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;gzip: GNU zip, 对于文本数据通常超过 60%压缩率&lt;/li&gt;
&lt;li&gt;deflate: zlib&lt;/li&gt;
&lt;li&gt;br: 专为 HTTP 优化的新压缩算法 Brotli, 通常比 gzip 还好&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;数据类型相关 Headers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;请求头: 客户端声明希望/能够接收的数据类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Accept: text/html, application/json, image/png, image/webp&lt;/li&gt;
&lt;li&gt;Accept-Encoding: gzip, deflate, br&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;响应头: 服务端告知实际发送的数据类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Content-Type: text/html&lt;/li&gt;
&lt;li&gt;Content-Encoding: gzip&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;国际化 i18n&lt;/h2&gt;
&lt;p&gt;主要分为语言和字符集:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;请求头&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Accept-Language: zh-CN, zh, en&lt;/li&gt;
&lt;li&gt;Accept-Charset: utf-8, gbk&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;响应头&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Content-Language: zh-CN&lt;/li&gt;
&lt;li&gt;Content-Type: text/html; charset=utf-8&lt;/li&gt;
&lt;li&gt;字符集在响应头中没有单独的字段, 而是作为 Content-Type 的后半部分&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Accept-Charset&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;Content-Language&lt;/code&gt; 通常不会发送.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;优先级&lt;/h3&gt;
&lt;p&gt;可以在 &lt;code class=&quot;language-text&quot;&gt;Accept&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;Accept-Encoding&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;Accept-Language&lt;/code&gt; 等请求头字段中的内容中添加 &lt;code class=&quot;language-text&quot;&gt;q&lt;/code&gt; 参数来设定优先级, 如 &lt;code class=&quot;language-text&quot;&gt;Accept: text/html, application/xml;q=0.9&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;优先级默认以及最大为 1, 最小为 0.01.&lt;/p&gt;
&lt;p&gt;注: 在此处 &lt;code class=&quot;language-text&quot;&gt;;&lt;/code&gt; 的断句小于 &lt;code class=&quot;language-text&quot;&gt;,&lt;/code&gt; , 表示仅作用于分号之前的一个内容.&lt;/p&gt;
&lt;h3&gt;响应头中的 Vary&lt;/h3&gt;
&lt;p&gt;表示服务器在内容协商时参考的请求头字段, 如:&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Vary: Accept-Encoding,User-Agent,Accept&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;请求头变化时, Vary 也可能变化, 主要用于在传输链路中间的代理服务器实现缓存服务, 后文 &lt;strong&gt;缓存代理&lt;/strong&gt; 部分详述.&lt;/p&gt;
&lt;h2&gt;大文件传输&lt;/h2&gt;
&lt;h3&gt;分块传输/Transfer-Encoding&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;响应头: &lt;code class=&quot;language-text&quot;&gt;Transfer-Encoding: chunked&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与 &lt;code class=&quot;language-text&quot;&gt;Content-Length&lt;/code&gt; 字段互斥, 要么长度已知, 要么是 chunked(长度未知).&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Transfer-Encoding&lt;/code&gt; 字段值可以是 &lt;code class=&quot;language-text&quot;&gt;gzip&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;deflate&lt;/code&gt; 等, 表示压缩编码; 与 &lt;code class=&quot;language-text&quot;&gt;Content-Encoding&lt;/code&gt; 相比, &lt;code class=&quot;language-text&quot;&gt;Transfer-Encoding&lt;/code&gt; 在传输后将被自动解码.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个分块内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;length + CRLF&lt;/li&gt;
&lt;li&gt;chunked data + CRLF&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分块末尾&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 + CRLF (length 为 0)&lt;/li&gt;
&lt;li&gt;CRLF (空行结尾)&lt;/li&gt;
&lt;li&gt;末尾允许有拖尾数据 &lt;code class=&quot;language-text&quot;&gt;Trailer&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;范围请求/Range&lt;/h3&gt;
&lt;p&gt;获取文件的一部分, 如视频进度拖拽、多线程并发下载、断点续传.&lt;/p&gt;
&lt;p&gt;服务器在响应头中添加 &lt;code class=&quot;language-text&quot;&gt;Accept-Ranges: bytes&lt;/code&gt; 来告知客户端支持范围请求.&lt;/p&gt;
&lt;p&gt;客户端在请求头中添加 &lt;code class=&quot;language-text&quot;&gt;Range: bytes=x-y&lt;/code&gt; 来进行范围请求.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x、y 表示从 0 开始的偏移量&lt;/li&gt;
&lt;li&gt;x、y 可省略其中之一, 但 &lt;code class=&quot;language-text&quot;&gt;-&lt;/code&gt; 不能省略, 如: &lt;code class=&quot;language-text&quot;&gt;bytes=10-&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;bytes=-20&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;服务器接收到 &lt;code class=&quot;language-text&quot;&gt;Range&lt;/code&gt; 字段后,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检查范围是否合法, 不合法返回 416;&lt;/li&gt;
&lt;li&gt;若范围合法, 根据 Range 头偏移量读取文件片段, 确定状态码 206(Partial Content);&lt;/li&gt;
&lt;li&gt;服务器添加响应头字段 &lt;code class=&quot;language-text&quot;&gt;Content-Range: bytes x-y/length&lt;/code&gt; , length 表示总长度;&lt;/li&gt;
&lt;li&gt;通过 TCP 发送数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Range 是针对原文件的范围, 而不是压缩后的文件范围(除非原文件就是 gzip 的).&lt;/p&gt;
&lt;p&gt;条件范围请求 &lt;code class=&quot;language-text&quot;&gt;If-Range&lt;/code&gt; 在后文详述.&lt;/p&gt;
&lt;h3&gt;多段数据&lt;/h3&gt;
&lt;p&gt;在 &lt;code class=&quot;language-text&quot;&gt;Range&lt;/code&gt; 请求头中添加逗号分隔的多段范围, 如: &lt;code class=&quot;language-text&quot;&gt;Range: bytes=0-9, 20-29&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;响应头中多段数据得到的数据 MIME 类型为 &lt;code class=&quot;language-text&quot;&gt;multipart/byteranges&lt;/code&gt; , 同时需要给出段之间的 &lt;code class=&quot;language-text&quot;&gt;boundary=xxx&lt;/code&gt; , 如: &lt;code class=&quot;language-text&quot;&gt;Content-Type: multipart/byterange; boundary=00000000001&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;具体的数据如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以双“-”开头的分隔符: &lt;code class=&quot;language-text&quot;&gt;--{boundary}&lt;/code&gt; + CRLF&lt;/li&gt;
&lt;li&gt;数据类型: &lt;code class=&quot;language-text&quot;&gt;Content-Type: type/subtype&lt;/code&gt; + CRLF&lt;/li&gt;
&lt;li&gt;Range: &lt;code class=&quot;language-text&quot;&gt;Content-Range: types x-y/length&lt;/code&gt; + CRLF&lt;/li&gt;
&lt;li&gt;空行 CRLF&lt;/li&gt;
&lt;li&gt;分段数据 multipart data + CRLF&lt;/li&gt;
&lt;li&gt;(下一段数据)分隔符: &lt;code class=&quot;language-text&quot;&gt;--{boundary}&lt;/code&gt; + CRLF&lt;/li&gt;
&lt;li&gt;…其他数据&lt;/li&gt;
&lt;li&gt;分段结束: &lt;code class=&quot;language-text&quot;&gt;--{boundary}--&lt;/code&gt; + CRLF&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;连接管理/Connection&lt;/h2&gt;
&lt;h3&gt;短连接和长连接&lt;/h3&gt;
&lt;p&gt;HTTP 0.9/1.0 使用短连接, 收到响应后立刻关闭连接, 效率很低:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP 三次握手建立连接 → 请求 → 响应 → TCP 四次握手断开连接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTP/1.1 默认使用长连接, 在一次连接中收发多个请求-响应.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求头和响应头加 &lt;code class=&quot;language-text&quot;&gt;Connection: keep-alive&lt;/code&gt; 表示支持长连接&lt;/li&gt;
&lt;li&gt;请求头和响应头加 &lt;code class=&quot;language-text&quot;&gt;Connection: close&lt;/code&gt; 告知对方本次通信后关闭连接&lt;/li&gt;
&lt;li&gt;请求头和响应头加 &lt;code class=&quot;language-text&quot;&gt;Keep-Alive: timeout=value&lt;/code&gt; 限定超时时间(约束力不强,可能不遵守)&lt;/li&gt;
&lt;li&gt;Nginx 可以设置 &lt;code class=&quot;language-text&quot;&gt;keepalive_timeout&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;keepalive_request&lt;/code&gt; 规定一次连接的超时时间和最大请求数&lt;/li&gt;
&lt;li&gt;Connection 的另一个值 &lt;code class=&quot;language-text&quot;&gt;Upgrade&lt;/code&gt; 配合状态码 101, 表示协议升级, 如 HTTP 升级为 WebSocket&lt;/li&gt;
&lt;li&gt;HTTP 还有第三种连接方式 “pipeline”, 但主流浏览器都未实现, 事实上“废弃”了.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;队首阻塞问题&lt;/h3&gt;
&lt;p&gt;HTTP 规定的“请求-响应”模型是先进先出的串行队列, 即 &lt;strong&gt;同域名&lt;/strong&gt; 下收到前一次的响应后才能发起新请求, 一次收发过慢时会导致后续所有请求被阻塞.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用 HTTP 长连接特性对服务器发起大量请求, 导致服务器耗尽资源, 就是 &lt;strong&gt;DDoS&lt;/strong&gt; .&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于 HTTP/1.1 的“请求-应答”模型不能变, 只能通过数量来暂时“解决”质量问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并发连接数: 浏览器支持 6~8 个同域并发长连接&lt;/li&gt;
&lt;li&gt;域名分片: 使用多个域名指向同一台服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;重定向和跳转/Location&lt;/h2&gt;
&lt;p&gt;当状态码 301/302 时为重定向, 响应头 &lt;code class=&quot;language-text&quot;&gt;Location&lt;/code&gt; 标记重定向 URL.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Location&lt;/code&gt; 支持绝对和相对 URI, 如 &lt;code class=&quot;language-text&quot;&gt;Location: /index.html&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;循环跳转: 几个 URI 连续重定向导致无限循环, 浏览器可以检测循环跳转并提示失败.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Refresh&lt;/code&gt; 延时重定向, 如 &lt;code class=&quot;language-text&quot;&gt;Refresh: 5; url=xxx&lt;/code&gt; 表示 5 秒后跳转.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Referer&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;Referrer-Policy&lt;/code&gt; 表示浏览器跳转来源, 用于统计分析或防盗链.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;3xx&lt;/code&gt; 状态码重定向由浏览器执行, 对于服务器来说是“外部重定向”, 服务器的“内部重定向”是在服务器中直接跳转 URI.&lt;/p&gt;
&lt;h3&gt;重定向相关状态码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;301: 永久重定向, 会更新浏览器历史记录和书签;&lt;/li&gt;
&lt;li&gt;302: 临时重定向, 仅本次访问有效;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他状态码, 浏览器和服务器不一定支持:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;303 See Other: 类似 302, 但要改为 &lt;code class=&quot;language-text&quot;&gt;GET&lt;/code&gt; 方法避免重复操作;&lt;/li&gt;
&lt;li&gt;307 Temporary Redirect: 类似 302, 要求重定向后的方法和实体不变;&lt;/li&gt;
&lt;li&gt;308 Permanent Redirect: 301 + 307, 永久重定向且方法和实体不变.&lt;/li&gt;
&lt;li&gt;300 Multiple Choices: 返回一个有多个链接选项的页面, 用户自行选择跳转&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Cookie&lt;/h2&gt;
&lt;p&gt;服务器在响应头添加 &lt;code class=&quot;language-text&quot;&gt;Set-Cookie: key=value&lt;/code&gt; , 给予客户端身份标识, 响应头可具有多个 &lt;code class=&quot;language-text&quot;&gt;Set-Cookie&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;客户端保存 Cookie 并在之后的请求头中添加 &lt;code class=&quot;language-text&quot;&gt;Cookie: key1=value1; key2=value2&lt;/code&gt; , 请求头的 &lt;code class=&quot;language-text&quot;&gt;Cookie&lt;/code&gt; 将多个 Cookie 合并为 &lt;code class=&quot;language-text&quot;&gt;;&lt;/code&gt; 分隔的形式.&lt;/p&gt;
&lt;p&gt;Cookie 最大 4K.&lt;/p&gt;
&lt;p&gt;Cookie 不属于 HTTP 标准, 所以语法上与别的属性不一致(分隔符是分号而非逗号).&lt;/p&gt;
&lt;h3&gt;Cookie 属性&lt;/h3&gt;
&lt;p&gt;一个真实 Cookie: &lt;code class=&quot;language-text&quot;&gt;Set-Cookie: favorite=humburger; Max-Age=10; Expires=Fri, 07-Jun-19 08:19:00 GMT; Domain=www.xxx.com; Path=/; HttpOnly; SameSite=Strict&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;有效期:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Expires&lt;/code&gt; 过期的时间点&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Max-Age&lt;/code&gt; 有效时间(秒数)&lt;/li&gt;
&lt;li&gt;浏览器优先采用 &lt;code class=&quot;language-text&quot;&gt;Max-Age&lt;/code&gt; , 如果不指定有效期, 则为会话 Cookie 关闭失效.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作用域:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Domain&lt;/code&gt; 域名&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Path&lt;/code&gt; 路径, 使用 &lt;code class=&quot;language-text&quot;&gt;/&lt;/code&gt; 表示该域名下任意路径&lt;/li&gt;
&lt;li&gt;浏览器会进行对比, 如果请求 URI 不相符则不会发送 Cookie.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;安全性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;HttpOnly&lt;/code&gt; 禁止非 HTTP 协议方式访问,禁用 &lt;code class=&quot;language-text&quot;&gt;document.cookie&lt;/code&gt; 相关 API.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;SameSite&lt;/code&gt; 防范“跨站请求伪造”(XSRF)攻击&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;SameSite=Strict&lt;/code&gt; 限定 Cookie 不能随着跳转链接跨站发送&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;SameSite=Lax&lt;/code&gt; 允许 GET/HEAD 等安全方法, 禁止 POST 跨站发送&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Secure&lt;/code&gt; 该 Cookie 只能用 HTTPS 协议加密传输, 但 Cookie 本身在浏览器中还是明文存在&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;防范 XSS(跨站脚本攻击): &lt;code class=&quot;language-text&quot;&gt;HttpOnly&lt;/code&gt; 禁止 JS 脚本访问 Cookie; &lt;code class=&quot;language-text&quot;&gt;Secure&lt;/code&gt; 只在 HTTPS 时加密传输 Cookie.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Cookie 应用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;身份识别: 登录信息、会话事务等&lt;/li&gt;
&lt;li&gt;广告追踪: 用户被广告商加上 Cookie, 实现精准推送&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Cache-Control&lt;/h2&gt;
&lt;h3&gt;服务器端的缓存控制&lt;/h3&gt;
&lt;p&gt;服务器在响应头中添加 &lt;code class=&quot;language-text&quot;&gt;Cache-Control&lt;/code&gt; 控制浏览器缓存资源, 如 &lt;code class=&quot;language-text&quot;&gt;Cache-Control: max-age=30&lt;/code&gt; .&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;max-age&lt;/code&gt; 有效期(秒), 从响应报文的创建时刻开始计算.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;no_store&lt;/code&gt; 不允许缓存&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;no_cache&lt;/code&gt; (语义相反)可以缓存, 需在服务器验证缓存是否有新版本&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相当于 &lt;code class=&quot;language-text&quot;&gt;max-age=0, must_revalidate&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;must-revalidate&lt;/code&gt; 缓存未过期可使用, 过期需验证&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;浏览器端的缓存控制&lt;/h3&gt;
&lt;p&gt;不使用缓存数据:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;刷新按钮: 浏览器在请求头中添加 &lt;code class=&quot;language-text&quot;&gt;Cache-Control: max-age=0&lt;/code&gt; , 表示越过缓存获取新数据;&lt;/li&gt;
&lt;li&gt;强制刷新(Ctrl+F5 或 Command+R): 请求头添加 &lt;code class=&quot;language-text&quot;&gt;Cache-Control: no-cache&lt;/code&gt; , 通常与刷新效果相同, 取决于服务器处理.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用缓存数据的情况: 请求头中无 &lt;code class=&quot;language-text&quot;&gt;Cache-Control&lt;/code&gt; 属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前进/后退 按钮&lt;/li&gt;
&lt;li&gt;重定向跳转&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;条件请求&lt;/h3&gt;
&lt;p&gt;先验证缓存是否有效, 若无效再请求新数据 需要两次请求, 成本过高. 所以 HTTP 定义了一系列 &lt;code class=&quot;language-text&quot;&gt;If&lt;/code&gt; 开头的条件请求字段来合并数据验证和请求.&lt;/p&gt;
&lt;p&gt;在首次请求中, 服务器在响应头中添加 &lt;code class=&quot;language-text&quot;&gt;Last-Modified&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;ETag&lt;/code&gt; 属性&lt;/p&gt;
&lt;p&gt;通过缓存的更新时间:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器在请求头添加 &lt;code class=&quot;language-text&quot;&gt;If-Modified-Since&lt;/code&gt; 属性&lt;/li&gt;
&lt;li&gt;若缓存无更新, 服务器在响应头添加 &lt;code class=&quot;language-text&quot;&gt;Last-Modified&lt;/code&gt; 属性并返回”304 Not Modified”, 浏览器更新缓存有效期&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 ETag(资源标识):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器在请求头添加 &lt;code class=&quot;language-text&quot;&gt;If-None-Match: &amp;quot;xxxx&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;若本资源无更新则返回”304 Not Modified”并更新有效期&lt;/li&gt;
&lt;li&gt;ETag 有”强” “弱”之分, 以 “W/”开头的为弱 ETag, 只要求资源在语义上无变化, 但内部可能发生变化; 强 ETag 要求资源在字节级别完全相符.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Proxy&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Via&lt;/code&gt; 在请求和响应头可以出现, 没经过一个代理就追加一个代理主机名/域名, 如 &lt;code class=&quot;language-text&quot;&gt;Via: proxy1, proxy2&lt;/code&gt; .&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有的响应报文会使用 &lt;code class=&quot;language-text&quot;&gt;X-Via&lt;/code&gt; , 与 &lt;code class=&quot;language-text&quot;&gt;Via&lt;/code&gt; 含义相同&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两个常用的事实上的标准(非 HTTP 标准):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;X-Forwarded-For&lt;/code&gt; 与 &lt;code class=&quot;language-text&quot;&gt;Via&lt;/code&gt; 类似, 但追加的是请求方的 IP 地址.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;X-Forwarded-Host&lt;/code&gt; 记录主机名&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;X-Forwarded-Proto&lt;/code&gt; 记录协议名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;X-Real-IP&lt;/code&gt; 记录客户端 IP 地址, 无中间代理信息.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;抓包含代理的通信过程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;客户端与代理的 80 端口通过三次握手建立 TCP 连接;&lt;/li&gt;
&lt;li&gt;客户端向代理发送 HTTP 请求, 代理接收并返回 ACK 确认;&lt;/li&gt;
&lt;li&gt;代理与源服务器通过三次握手建立 TCP 连接;&lt;/li&gt;
&lt;li&gt;代理向源服务器发送 HTTP 请求, 源服务器接收并返回 ACK 确认;&lt;/li&gt;
&lt;li&gt;源服务器向代理发送 HTTP 响应, 代理接收并返回 ACK 确认;&lt;/li&gt;
&lt;li&gt;代理与源服务器通过四次挥手断开 TCP 连接;&lt;/li&gt;
&lt;li&gt;代理将响应数据发给客户端, 客户端接收并返回 ACK 确认.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;代理协议&lt;/h3&gt;
&lt;p&gt;由于 &lt;code class=&quot;language-text&quot;&gt;X-Forwarded-For&lt;/code&gt; 要解析和修改 HTTP Headers, 会影响性能, 在加密通信中甚至无法实现, 所以出现了一个事实标准 &lt;strong&gt;代理协议/The PROXY protocol&lt;/strong&gt; .&lt;/p&gt;
&lt;p&gt;代理协议有 v1 和 v2 两个版本:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;v1: 明文, 在 HTTP 报文前增加一行 ASCII 码文本:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token constant&quot;&gt;PROXY&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;TCP4&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1.1&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;.1&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2.2&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;.2&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;.2&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;55555&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;80&lt;/span&gt;\r\n
&lt;span class=&quot;token constant&quot;&gt;GET&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;HTTP&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1.1&lt;/span&gt;\r\n
&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;必须 &lt;code class=&quot;language-text&quot;&gt;PROXY&lt;/code&gt; 开头, 放在 HTTP 报文首行之前&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;TCP4&lt;/code&gt; 表示客户端的 IP 地址类型&lt;/li&gt;
&lt;li&gt;之后是请求方地址, 应答方地址, 请求方端口, 应答方端口号&lt;/li&gt;
&lt;li&gt;最后与 HTTP 报文一样以回车换行结束&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;v2: 非明文二进制格式, 相对复杂可自行查阅.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Cache Proxy&lt;/h2&gt;
&lt;p&gt;处于客户端和源服务器之间, 作为数据的中转站.&lt;/p&gt;
&lt;p&gt;面向源服务器时是客户端, 面相客户端时是服务器.&lt;/p&gt;
&lt;h3&gt;服务端的缓存控制&lt;/h3&gt;
&lt;p&gt;在&lt;code class=&quot;language-text&quot;&gt;Cache-Control&lt;/code&gt; 响应头中可以对客户端和代理的缓存策略进行配置.&lt;/p&gt;
&lt;p&gt;首先是四个基本属性 &lt;code class=&quot;language-text&quot;&gt;max-age&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;no_store&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;no_cache&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;must-revalidate&lt;/code&gt; 可以通过添加 &lt;code class=&quot;language-text&quot;&gt;private&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;public&lt;/code&gt; 约束客户端和代理的缓存策略:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;private&lt;/code&gt; 表示客户端私有缓存, 如用户信息 Cookie.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;public&lt;/code&gt; 表示客户端与代理都可以进行缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其次, &lt;code class=&quot;language-text&quot;&gt;Cache-Control&lt;/code&gt; 还可以添加 &lt;code class=&quot;language-text&quot;&gt;must-revalidate&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;proxy-revalidate&lt;/code&gt; 属性, 用于说明在缓存失效时必须回源服务器验证还是只验证代理即可.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;s-maxage&lt;/code&gt; 用于单独标识代理端的缓存生效时间, 与客户端的 &lt;code class=&quot;language-text&quot;&gt;max-age&lt;/code&gt; 类似.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;no-transform&lt;/code&gt; 代理专用属性, 表示禁止对数据进行优化处理(一些代理可能会对某些数据进行一些优化处理).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 服务器设置完 &lt;code class=&quot;language-text&quot;&gt;Cache-Control&lt;/code&gt; 后要添加 &lt;code class=&quot;language-text&quot;&gt;Last-modified&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;Etag&lt;/code&gt; 响应头才能使用条件请求.&lt;/p&gt;
&lt;h3&gt;客户端的缓存控制&lt;/h3&gt;
&lt;p&gt;在 &lt;strong&gt;Cache-Control&lt;/strong&gt; 部分讲述的的浏览器缓存控制对代理同样有效, 即通过 &lt;code class=&quot;language-text&quot;&gt;max-age&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;no_store&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;no_cache&lt;/code&gt; 属性作用于源服务器和代理来进行缓存控制.&lt;/p&gt;
&lt;p&gt;还有两个属性用于声明客户端对缓存有效期的偏移量限定:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;max-stale&lt;/code&gt; 可接受缓存过期 x 秒&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;min-fresh&lt;/code&gt; 缓存必须在当前以及 x 秒后未过期&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;only-if-cached&lt;/code&gt; 属性表示客户端只接受代理缓存的数据, 如果代理没有缓存或缓存过期, 就返回 504.&lt;/p&gt;
&lt;h3&gt;缓存数据匹配&lt;/h3&gt;
&lt;p&gt;在 &lt;strong&gt;i18n&lt;/strong&gt; 部分提到过 &lt;code class=&quot;language-text&quot;&gt;Vary&lt;/code&gt; 字段, 表示服务器在内容协商时参考的请求头字段, 可以作为报文的一个版本标记. 如: &lt;code class=&quot;language-text&quot;&gt;Vary: Accept-Encoding,User-Agent,Accept&lt;/code&gt; , 缓存代理会存储这些版本. 当再次收到相同请求时, 代理读取缓存的 &lt;code class=&quot;language-text&quot;&gt;Vary&lt;/code&gt; , 匹配时缓存数据.&lt;/p&gt;
&lt;h3&gt;缓存清理&lt;/h3&gt;
&lt;p&gt;常用的做法是使用自定义请求方发 &lt;code class=&quot;language-text&quot;&gt;PURGE&lt;/code&gt; 来告诉代理服务器删除本 URI 对应的缓存数据.&lt;/p&gt;
&lt;p&gt;需要进行缓存清理的场景: 缓存数据过期; 源服务器存在新数据; 一些无用或有害数据.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[NPM/Yarn包管理策略与最佳实践]]></title><description><![CDATA[NPM NPM 安装机制 执行  : 读取 npm 配置文件  配置文件优先级: 项目级 > 用户级 > 全局 > npm…]]></description><link>https://hrayd.github.io/npm/</link><guid isPermaLink="false">https://hrayd.github.io/npm/</guid><pubDate>Sun, 25 Jul 2021 22:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;NPM&lt;/h2&gt;
&lt;h3&gt;NPM 安装机制&lt;/h3&gt;
&lt;p&gt;执行 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;读取 npm 配置文件 &lt;code class=&quot;language-text&quot;&gt;.npmrc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;配置文件优先级: 项目级 &gt; 用户级 &gt; 全局 &gt; npm 内置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查是否存在 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 文件:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若不存在, 则根据 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 递归构建依赖树并从缓存或远程仓库下载相关资源, 并生成 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 文件;&lt;/li&gt;
&lt;li&gt;若存在, 则对比 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 文件中声明的依赖规范是否一致:&lt;/li&gt;
&lt;li&gt;若一致, 直接使用 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 中的信息从缓存或远程仓库加载依赖文件;&lt;/li&gt;
&lt;li&gt;若不一致, NPM v5.4.2+ 会按照 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 文件安装依赖并更新 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 文件(NPM 旧版本的处理方式有所不同, 详见下文).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构建扁平化依赖树: 无论是直接依赖还是嵌套依赖, 都优先将依赖包放在 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 根目录.&lt;/p&gt;
&lt;p&gt;当遇到相同模块且版本冲突时, 将后者放在当前模块的 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 目录下.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;NPM 不同版本对于 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 文件处理方式的不同, 可能导致安装的依赖包版本不一致, 所以团队内应保持 NPM 版本一致.&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;NPM 缓存机制&lt;/h3&gt;
&lt;p&gt;获取 NPM 本地缓存路径: &lt;code class=&quot;language-text&quot;&gt;npm config get cache&lt;/code&gt; , 默认为 &lt;code class=&quot;language-text&quot;&gt;~/.npm&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;缓存路径下的 &lt;code class=&quot;language-text&quot;&gt;_cacache&lt;/code&gt; 目录下有三个子目录:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;content-v2&lt;/code&gt; 二进制文件, 将此目录扩展名改为 &lt;code class=&quot;language-text&quot;&gt;.tgz&lt;/code&gt; 并解压则可以得到依赖包资源&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;index-v5&lt;/code&gt; 同样可通过修改扩展名解压, 是 &lt;code class=&quot;language-text&quot;&gt;content-v2&lt;/code&gt; 资源的索引文件&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;tmp&lt;/code&gt; 临时文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NPM 缓存策略: 执行 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 时, 若缓存中存在依赖包, 则通过 &lt;code class=&quot;language-text&quot;&gt;pacote&lt;/code&gt; 将依赖包解压到对应的 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 目录下; 若缓存中不存在, 则先从远程仓库下载依赖包到缓存中, 再从缓存解压到项目 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 中.&lt;/p&gt;
&lt;p&gt;在安装资源时, 根据 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 中依赖包的 &lt;code class=&quot;language-text&quot;&gt;integrity&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;version&lt;/code&gt; 信息生成一个唯一的 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt;, 根据这个 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt; 从 &lt;code class=&quot;language-text&quot;&gt;index-v5&lt;/code&gt; 目录中寻找缓存资源的 &lt;code class=&quot;language-text&quot;&gt;hash&lt;/code&gt; , 如果找到了就可以从 &lt;code class=&quot;language-text&quot;&gt;content-v2&lt;/code&gt; 中找到对应的 tar 包, 通过 &lt;code class=&quot;language-text&quot;&gt;pacote&lt;/code&gt; 将二进制文件解压到项目的 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 中.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NPM v5 之前的缓存文件是以 &lt;code class=&quot;language-text&quot;&gt;{cache}/{name}/{version}&lt;/code&gt; 的形式直接存储在 &lt;code class=&quot;language-text&quot;&gt;.npm&lt;/code&gt; 目录下.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;npm link&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;npx&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;npm link&lt;/code&gt; 为目标模块创建软连接, 将其链接到全局安装路径中, 可用于在模块发布之前在本地调试和使用.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;npx&lt;/code&gt; 的两个作用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可直接执行 &lt;code class=&quot;language-text&quot;&gt;node_modules/.bin&lt;/code&gt; 和 环境变量 &lt;code class=&quot;language-text&quot;&gt;PATH&lt;/code&gt; 中的命令, 在之前只能通过在 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 中定义 &lt;code class=&quot;language-text&quot;&gt;script&lt;/code&gt; 或手动定位到命令所在目录来执行;&lt;/li&gt;
&lt;li&gt;执行一个需要安装依赖的命令, 在临时目录中安装依赖, 并在执行完成后删除相关依赖, 避免在全局安装模块. 可用于使用脚手架生成项目: &lt;code class=&quot;language-text&quot;&gt;npx create-react-app my-app&lt;/code&gt; .&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 中的依赖&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 文件中的 &lt;code class=&quot;language-text&quot;&gt;dependency&lt;/code&gt; 主要有以下属性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Version：版本号&lt;/li&gt;
&lt;li&gt;Resolved：安装源（下载地址）&lt;/li&gt;
&lt;li&gt;Integrity：表明包完整性的 Hash 值&lt;/li&gt;
&lt;li&gt;Dev：该依赖是否为顶级模块的开发依赖或者是传递依赖&lt;/li&gt;
&lt;li&gt;requires：需要的所有依赖项, 对应该依赖包 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 中 &lt;code class=&quot;language-text&quot;&gt;dependencies&lt;/code&gt; 中的依赖项&lt;/li&gt;
&lt;li&gt;dependencies：依赖包 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 中依赖的包, 当子依赖的依赖与当前根目录中的依赖冲突后才有此属性&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;lockfiles&lt;/code&gt; 与 NPM 版本问题总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;早期 NPM 使用 &lt;code class=&quot;language-text&quot;&gt;npm-shrinkwrap.json&lt;/code&gt; 锁定版本, 与 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 不同点在于：NPM 包发布时默认将 &lt;code class=&quot;language-text&quot;&gt;npm-shrinkwrap.json&lt;/code&gt; 同时发布;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 是 NPM v5.x 版本新增特性, 而 v5.6 以上才逐步稳定, 在 5.0 - 5.6 之间对 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 的处理逻辑进行过几次更新:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 v5.0.x 中, &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 时根据 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 文件下载, 不考虑 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 内容;&lt;/li&gt;
&lt;li&gt;v5.1.0 - v5.4.2, &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 会无视 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 文件而下载最新的依赖包并更新 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; ;&lt;/li&gt;
&lt;li&gt;v5.4.2 后：&lt;/li&gt;
&lt;li&gt;如果项目只有 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 文件, &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 后会根据它生成一个 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 文件;&lt;/li&gt;
&lt;li&gt;如果存在 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 文件，同时 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 的 &lt;code class=&quot;language-text&quot;&gt;semver-range&lt;/code&gt; 版本 和 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 中版本兼容, &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 会根据 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 下载;&lt;/li&gt;
&lt;li&gt;如果存在 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 且 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 的 &lt;code class=&quot;language-text&quot;&gt;semver-range&lt;/code&gt; 版本和 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 中版本不兼容, &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 时 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 将会更新到兼容 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 的版本;&lt;/li&gt;
&lt;li&gt;如果 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;npm-shrinkwrap.json&lt;/code&gt; 都存在于项目根目录, &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 将会被忽略.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;xxxDependencies&lt;/code&gt; 声明总结&lt;/h3&gt;
&lt;p&gt;NPM 中共有 5 中依赖声明:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;dependencies&lt;/code&gt; 项目依赖, NPM 包被下载时, 它的项目依赖会被一起下载.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;devDependencies&lt;/code&gt; 开发依赖, 只在开发阶段或开发环境用到的依赖. 在实际业务中只是一个规范, 依赖是否被打包完全取决于项目中是否引入了该模块, 开发依赖在 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 时也会被下载.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;peerDependencies&lt;/code&gt; 同版本依赖, 一般用于在基于某个框架或核心库做扩展库或中间件时, 来声明宿主环境, 如开发基于 React 的 UI 组件库时就可以声明 &lt;code class=&quot;language-text&quot;&gt;&amp;quot;peerDependencies&amp;quot;: { &amp;quot;react&amp;quot;: &amp;quot;^17.0.0&amp;quot; }&lt;/code&gt; .&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;bundledDependencies&lt;/code&gt; 捆绑依赖, 在 &lt;code class=&quot;language-text&quot;&gt;npm pack&lt;/code&gt; 时会在压缩包中包含捆绑依赖中声明的安装包; 业务方使用 &lt;code class=&quot;language-text&quot;&gt;npm install xx&lt;/code&gt; 安装压缩包时也会安装捆绑依赖中声明的包. 需要注意的是, 此包必须在 &lt;code class=&quot;language-text&quot;&gt;dependencies&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;devDependencies&lt;/code&gt; 中声明过.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;optionalDependencies&lt;/code&gt; 可选依赖, 表示安装失败也不影响整个过程, 一般不建议使用.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;CI 环境中的 NPM 优化&lt;/h2&gt;
&lt;h3&gt;使用 &lt;code class=&quot;language-text&quot;&gt;npm ci&lt;/code&gt; 代替 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;npm ci&lt;/code&gt; 是专用于 CI 环境的安装命令, 它与 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 的主要不同有:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目中必须存在 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;npm-shrinkwrap.json&lt;/code&gt; ;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;npm ci&lt;/code&gt; 完全根据 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 安装依赖, 保证整个团队的依赖包完全一致, 同时安装过程也更迅速;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;npm ci&lt;/code&gt; 执行安装时会删除现有的 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 并重新安装;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;npm ci&lt;/code&gt; 只能一次安装整个依赖包, 无法单独安装;&lt;/li&gt;
&lt;li&gt;若 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 冲突会直接报错;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;npm ci&lt;/code&gt; 不会修改 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; .&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于 &lt;code class=&quot;language-text&quot;&gt;npm ci&lt;/code&gt; 命令的特性, 可得出以下 CI 环境中的 NPM 优化方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提交 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 到仓库;&lt;/li&gt;
&lt;li&gt;缓存 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 文件;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;适用于团队的 NPM 最佳实践&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用 NPM v5.4.2 以上的版本, 最好统一 Node.js 版本.&lt;/li&gt;
&lt;li&gt;项目初次搭建时使用 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 安装依赖, 并提交 package.json、package-lock.json, 不提交 node_modules 目录.&lt;/li&gt;
&lt;li&gt;其他成员首次 clone/checkout 项目后, 执行 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 安装依赖包.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;升级依赖包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code class=&quot;language-text&quot;&gt;npm update&lt;/code&gt; 升级到新的小版本;&lt;/li&gt;
&lt;li&gt;使用 &lt;code class=&quot;language-text&quot;&gt;npm install @&lt;/code&gt; 升级大版本;&lt;/li&gt;
&lt;li&gt;也可以手动修改 package.json 中的版本号并执行 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 升级版本;&lt;/li&gt;
&lt;li&gt;本地验证升级后无问题再提交新的 package.json、package-lock.json 文件.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;降级依赖包：执行 &lt;code class=&quot;language-text&quot;&gt;npm install @&lt;/code&gt; 命令，验证没问题后提交新的 package.json、package-lock.json 文件.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除依赖包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行 &lt;code class=&quot;language-text&quot;&gt;npm uninstall xx&lt;/code&gt; 命令, 验证没问题后提交新的 package.json、package-lock.json 文件;&lt;/li&gt;
&lt;li&gt;或手动更改 package.json 删除依赖并执行 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 命令, 验证没问题后提交新的 package.json、package-lock.json 文件.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;任何成员更新 package.json、package-lock.json 后, 其他成员在拉取代码后执行 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 更新依赖.&lt;/li&gt;
&lt;li&gt;禁止修改 package-lock.json.&lt;/li&gt;
&lt;li&gt;若 package-lock.json 出现冲突或问题，建议删除本地 package-lock.json 文件, 引入远程的 package-lock.json 和 package.json 文件, 再执行 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; .&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Yarn&lt;/h2&gt;
&lt;p&gt;Yarn 是在 NPM 处于 v3 时为了解决 NPM 在依赖包的版本确定性(无 lock 文件)、扁平化安装、网络性能、缓存机制等方面的问题而出现的包管理器.&lt;/p&gt;
&lt;p&gt;目前 NPM 也吸收了 Yarn 的很多优势特点, 改进了本身存在的诸多问题, 所以二者目前并没有明显的优劣之分.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;yarn.lock&lt;/code&gt; 与 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 相比, 除了文件格式不同, 另一个显著区别是其中的 &lt;strong&gt;子依赖&lt;/strong&gt; 的版本号不是固定版本, 而是类似于 &lt;code class=&quot;language-text&quot;&gt;^4.0.1&lt;/code&gt; 这样的版本规则, 这意味着 &lt;code class=&quot;language-text&quot;&gt;yarn.lock&lt;/code&gt; 必须和 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 文件相配合才能确定 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 目录结构.&lt;/p&gt;
&lt;p&gt;Yarn 和 NPM 的另一个显著区别是: Yarn 默认使用 &lt;code class=&quot;language-text&quot;&gt;prefer-online&lt;/code&gt; 模式, 即优先使用网络资源, 请求失败后才去读取缓存资源.&lt;/p&gt;
&lt;h3&gt;Yarn 安装机制&lt;/h3&gt;
&lt;p&gt;Yarn 的安装过程可分为 5 个步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Checking&lt;/p&gt;
&lt;p&gt;检查项目中是否存在 npm 相关文件如 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 等, 若有会提示用户可能导致冲突; 也会检查当前环境的操作系统、CPU 等信息.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Resolving&lt;/p&gt;
&lt;p&gt;解析依赖树:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取首层依赖, 即 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 中的 &lt;code class=&quot;language-text&quot;&gt;dependencies&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;devDependencies&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;optionalDependencies&lt;/code&gt; 内容&lt;/li&gt;
&lt;li&gt;遍历首层依赖, 逐个递归查找嵌套依赖: 对于每个包, 尝试从 &lt;code class=&quot;language-text&quot;&gt;yarn.lock&lt;/code&gt; 中获取版本信息, 若获取不到, 则从远程仓库获取满足版本规则的最高版本的版本信息.&lt;/li&gt;
&lt;li&gt;通过步骤 b 最终得到所有依赖的具体版本信息和下载地址.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fetching&lt;/p&gt;
&lt;p&gt;检查缓存中是否存在当前依赖包, 对于不存在的包会维护一个 fetch 队列, 将依赖包下载到缓存目录.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linking&lt;/p&gt;
&lt;p&gt;将依赖包从缓存目录 &lt;strong&gt;扁平化&lt;/strong&gt; 复制到项目 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 下.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Building&lt;/p&gt;
&lt;p&gt;对存在二进制包的依赖包进行编译.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;依赖嵌套问题&lt;/h2&gt;
&lt;h3&gt;早期 NPM 的树形依赖&lt;/h3&gt;
&lt;p&gt;早期 NPM 的依赖包采用自然的树形依赖: 将项目的直接依赖放到项目 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 根目录, 若直接依赖 A 还依赖模块 B, 则将模块 B 放在模块 A 的 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 下. 在稍复杂的项目中形成“嵌套地狱”:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;依赖树层级过深, 一方面难以调试, 另一方面可能出现文件路径过长导致的一些问题;&lt;/li&gt;
&lt;li&gt;依赖树的不同分支可能存在重复的依赖包, 导致安装过慢、浪费空间.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;扁平化依赖&lt;/h3&gt;
&lt;p&gt;对于没有版本冲突的依赖包, 扁平化地将依赖包放在 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 根目录.&lt;/p&gt;
&lt;p&gt;存在版本冲突时则嵌套安装, 如 模块 A 依赖 模块 B-v1.0 , 模块 C 依赖 模块 B-v2.0 , 则将 模块 B-v2.0 安装在 模块 C 的 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 中.&lt;/p&gt;
&lt;p&gt;冲突模块 B 不同版本的安装路径取决于模块 A 和 C 的安装顺序, 先安装的版本放在根目录.&lt;/p&gt;
&lt;p&gt;此时, 依赖包的安装顺序对依赖树影响很大: 若 模块 A 依赖 模块 B-v1.0 , 而 模块 C、D、E 都依赖 模块 B-2.0 , 则会导致 C、D、E 模块下都存在重复性的 模块 B-v2.0 .&lt;/p&gt;
&lt;p&gt;执行 &lt;code class=&quot;language-text&quot;&gt;npm dedupe&lt;/code&gt; 会尝试通过将依赖关系向上移动来尽可能删除重复依赖.&lt;/p&gt;
&lt;p&gt;Yarn 则会在安装依赖时自动执行 &lt;code class=&quot;language-text&quot;&gt;dedupe&lt;/code&gt; 命令.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[HTTP之一：通识]]></title><description><![CDATA[HTTP Hyper Text Transfer Protocol - 超文本传输协议 应用层协议, 构建在 TCP/IP 协议之上. 请求方: User Agent, 如浏览器、爬虫等 应答方: 服务器, 如 Apache、Nginx 等 CDN Content…]]></description><link>https://hrayd.github.io/http-1/</link><guid isPermaLink="false">https://hrayd.github.io/http-1/</guid><pubDate>Thu, 22 Jul 2021 22:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;HTTP&lt;/h2&gt;
&lt;p&gt;Hyper Text Transfer Protocol - 超文本传输协议&lt;/p&gt;
&lt;p&gt;应用层协议, 构建在 TCP/IP 协议之上.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求方: User Agent, 如浏览器、爬虫等&lt;/li&gt;
&lt;li&gt;应答方: 服务器, 如 Apache、Nginx 等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;CDN&lt;/h2&gt;
&lt;p&gt;Content Delivery Network - 内容分发网络&lt;/p&gt;
&lt;p&gt;应用了 HTTP 协议中的缓存和代理技术, 通过缓存快速响应客户端的请求.&lt;/p&gt;
&lt;p&gt;处于请求方(浏览器)和应答方(服务器)之间.&lt;/p&gt;
&lt;h2&gt;TCP/IP&lt;/h2&gt;
&lt;h3&gt;IP&lt;/h3&gt;
&lt;p&gt;Internate Protocol, 网络层, 主要目的是解决寻址和路由问题.&lt;/p&gt;
&lt;p&gt;通过 IP 地址定位网络节点.&lt;/p&gt;
&lt;p&gt;IP 协议:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;v4: 4 组 8 位地址, 总共 &lt;code class=&quot;language-text&quot;&gt;2**32(约42亿)&lt;/code&gt; 个可分配地址&lt;/li&gt;
&lt;li&gt;v6: 8 组 16 位地址, 共 &lt;code class=&quot;language-text&quot;&gt;2**128&lt;/code&gt; 个可分配地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;TCP&lt;/h3&gt;
&lt;p&gt;Transmission Control Protocol, 传输控制协议, 传输层.&lt;/p&gt;
&lt;p&gt;位于 IP 协议之上, 基于 IP 协议提供可靠的、字节流形式的通信.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;传统的互联网: HTTP over TCP/IP&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;DNS&lt;/h2&gt;
&lt;p&gt;Domain Name System, 域名系统, 将域名转换成真实 IP.&lt;/p&gt;
&lt;p&gt;在 DNS 中, Domain Name/域名 = Host/主机名&lt;/p&gt;
&lt;p&gt;核心 DNS, 三层的树状分布式服务:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;根域名服务器(Root DNS Server), 管理顶级域名服务器, 返回 &lt;code class=&quot;language-text&quot;&gt;com&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;net&lt;/code&gt; 等顶级域名服务器的 IP 地址;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全世界共 13 组, 它必须是众所周知的.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;顶级域名服务器(Top-level DNS Server), 管理各自顶级域名下的权威域名服务器, 如 &lt;code class=&quot;language-text&quot;&gt;com&lt;/code&gt; 顶级域名服务器可以返回 &lt;code class=&quot;language-text&quot;&gt;[xx.com](http://xx.com)&lt;/code&gt; 域名服务器的 IP 地址;&lt;/li&gt;
&lt;li&gt;权威域名服务器(Authoritative DNS Server), 管理自己域名下主机的 IP 地址, 如权威域名服务器 &lt;code class=&quot;language-text&quot;&gt;[xxx.com](http://xxx.com)&lt;/code&gt; 可以返回 &lt;code class=&quot;language-text&quot;&gt;[www.xxx.com](http://www.xxx.com)&lt;/code&gt; 的 IP 地址.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;核心 DNS 系统之外的两个缓存系统:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非权威域名服务器: 大公司、网络运营商的 DNS 服务器, 代理用户访问核心 DNS 并缓存, 如 Google 的“8.8.8.8”&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作系统缓存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DNS 缓存&lt;/li&gt;
&lt;li&gt;hosts 文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;URI/URL&lt;/h2&gt;
&lt;p&gt;IP 地址可以定位到主机, URI/URL 定位主机里的特定资源.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;URI: Uniform Resource Identifier, 统一资源标识符&lt;/li&gt;
&lt;li&gt;URL: Uniform Resource Locator, 统一资源定位符, 俗称的网址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;URL 是 URI 的子集, 但二者差异不大, 不用严格区分.&lt;/p&gt;
&lt;p&gt;一般的 URI 构成: &lt;code class=&quot;language-text&quot;&gt;{协议名}://{主机名}{路径}&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;HTTPS&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;HTTP over SSL/TLS&lt;/strong&gt; , 即运行在 SSL/TLS 之上的 HTTP.&lt;/p&gt;
&lt;p&gt;SSL/TLS 是负责加密通信的安全协议, 处于 TCP/IP 之上、HTTP 之下, 也是可靠的传输协议.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTPS = HTTP + SSL/TLS + TCP/IP&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;SSL&lt;/h3&gt;
&lt;p&gt;Secure Socket Layer, SSL3.0 时改名为 TLS 即 Transport Layer Security, 历史原因习惯称为 SSL/TLS 或 SSL.&lt;/p&gt;
&lt;p&gt;SSL 使用了许多密码学成果, 综合了对称加密、非对称加密、摘要研发、数字签名、数字证书等技术, 在不安全的环境中为通信双方创建出一个秘密、安全的传输通道.&lt;/p&gt;
&lt;h2&gt;Proxy&lt;/h2&gt;
&lt;p&gt;即代理, 处于 HTTP 的请求方和应答方之间, 可以转发客户端的请求, 也可以转发服务器的应答.&lt;/p&gt;
&lt;p&gt;分类:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;匿名代理: 完全隐匿被代理的及其&lt;/li&gt;
&lt;li&gt;透明代理: 透明开放&lt;/li&gt;
&lt;li&gt;正向代理: 靠近客户端, 代表客户端向服务器发送请求&lt;/li&gt;
&lt;li&gt;反向代理: 靠近服务端, 代表服务器响应客户端&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CDN 就是一种代理, 属于透明代理和反向代理.&lt;/p&gt;
&lt;p&gt;代理处于中间层的可以做什么?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负载均衡(集群化)&lt;/li&gt;
&lt;li&gt;健康检查(心跳监控服务器)&lt;/li&gt;
&lt;li&gt;内容缓存&lt;/li&gt;
&lt;li&gt;安全防护(隐匿 IP、限制 IP 或流量)&lt;/li&gt;
&lt;li&gt;加密卸载(对外网使用 SSL/TLS 加密, 内网消除加密)&lt;/li&gt;
&lt;li&gt;数据过滤(修改请求或响应)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;网络分层模型&lt;/h2&gt;
&lt;h3&gt;TCP/IP 四层模型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;应用层: HTTP&lt;/li&gt;
&lt;li&gt;传输层: TCP/UDP&lt;/li&gt;
&lt;li&gt;网络层: IP&lt;/li&gt;
&lt;li&gt;链路层: MAC&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;OSI 七层模型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;L7: 应用层&lt;/li&gt;
&lt;li&gt;L6: 表示层&lt;/li&gt;
&lt;li&gt;L5: 会话层&lt;/li&gt;
&lt;li&gt;L4: 传输层&lt;/li&gt;
&lt;li&gt;L3: 网络层&lt;/li&gt;
&lt;li&gt;L2: 数据链路层&lt;/li&gt;
&lt;li&gt;L1: 物理层&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;两种分层模型对比&lt;/h3&gt;
&lt;p&gt;TCP/IP 是纯软件的栈, 没有最根基的电缆、网卡等物理设备; OSI 在理论层面上描述网络更加详细、完整.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.notion.so/03d6d4410c924823b2100cf4c8fd3fdd&quot;&gt;TCP/IP 与 OSI 网络分层模型映射关系&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;输入网址、按下回车&lt;/h2&gt;
&lt;p&gt;通过 Wireshark 抓包可验证, 当输入 &lt;code class=&quot;language-text&quot;&gt;[localhost](http://localhost)&lt;/code&gt; 后:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;浏览器从地址栏(或 DNS 多级缓存)取得服务器的 IP 地址和端口号&lt;/li&gt;
&lt;li&gt;浏览器用 TCP 的三次握手与服务器建立连接&lt;/li&gt;
&lt;li&gt;浏览器向服务器发送 HTTP 请求报文&lt;/li&gt;
&lt;li&gt;服务器向浏览器发送确认(ACK); 处理完后向浏览器返回 HTTP 响应报文&lt;/li&gt;
&lt;li&gt;浏览器接收到之后向服务器发送确认(ACK), 并根据 HTTP 响应渲染页面&lt;/li&gt;
&lt;li&gt;浏览器通过 TCP 四次挥手与服务器断开连接&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;真实的更复杂的网络:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据上网方式或网络配置的不同, IP 可能是动态或静态的&lt;/li&gt;
&lt;li&gt;DNS 除了层层解析给出服务器 IP 之外, 对于静态资源还可能直接给出 CDN 服务器的 IP&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目标网站的服务器为了扛住高并发, 内部也极其复杂, 如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入口是负载均衡设备, 如四层 LVS、七层 Nginx&lt;/li&gt;
&lt;li&gt;之后是服务器集群: Memory 级缓存(Redis) → Disk 级缓存(Varnish) → 应用服务器(Tomcat、Nodejs、Django) → 数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[React核心原理浅析]]></title><description><![CDATA[1. JSX 与虚拟 DOM 我们从 React 官方文档开头最基本的一段 Hello World 代码入手: 很明显, 这段代码的意思是通过  方法将  包裹的 JSX 元素渲染到 id 为“root”的 HTML 元素上. 除了在 JS…]]></description><link>https://hrayd.github.io/react/</link><guid isPermaLink="false">https://hrayd.github.io/react/</guid><pubDate>Sun, 18 Jul 2021 22:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;1. JSX 与虚拟 DOM&lt;/h1&gt;
&lt;p&gt;我们从 React 官方文档开头最基本的一段 Hello World 代码入手:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;ReactDOM&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;Hello, world!&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;h1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;root&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很明显, 这段代码的意思是通过 &lt;code class=&quot;language-text&quot;&gt;ReactDOM.render()&lt;/code&gt; 方法将 &lt;code class=&quot;language-text&quot;&gt;h1&lt;/code&gt; 包裹的 JSX 元素渲染到 id 为“root”的 HTML 元素上. 除了在 JS 中早已熟知的 &lt;code class=&quot;language-text&quot;&gt;document.getElementById()&lt;/code&gt; 方法外, 这段代码中还包含两个知识点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以 &lt;code class=&quot;language-text&quot;&gt;h1&lt;/code&gt; 标签包裹的 JSX 元素&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;ReactDOM.render()&lt;/code&gt; 方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而这两个知识点则对应着 React 中要解决的核心问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为何以及如何使用(JSX 表示的)虚拟 DOM?&lt;/li&gt;
&lt;li&gt;如何对虚拟 DOM 进行处理, 使其高效地渲染出来?&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1.1 虚拟 DOM 是什么? 为何要使用虚拟 DOM?&lt;/h3&gt;
&lt;p&gt;虚拟 DOM 其实就是用 JavaScript 对象表示的一个 DOM 节点, 内部包含了节点的 &lt;code class=&quot;language-text&quot;&gt;tag&lt;/code&gt; , &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;children&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;为何使用虚拟 DOM? 因为直接操作真实 DOM 繁琐且低效, 通过虚拟 DOM, 将一部分昂贵的浏览器重绘工作转移到相对廉价的存储和计算资源上.&lt;/p&gt;
&lt;h3&gt;1.2 如何将 JSX 转换成虚拟 DOM?&lt;/h3&gt;
&lt;p&gt;通过 babel 可以将 JSX 编译为特定的 JavaScript 对象, 示例代码如下:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// JSX&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; e &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;root&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;className&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;title&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;Title&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;h1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// babel编译结果(React17之前), 注意子元素的嵌套结构&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; e &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; React&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token string&quot;&gt;&quot;div&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; id&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;root&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  React&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;h1&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; className&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;title&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Title&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// React17之后编译结果有所区别, 创建节点的方法由react导出, 但基本原理大同小异&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.3 如何将虚拟 DOM 渲染出来?&lt;/h3&gt;
&lt;p&gt;很明显, 虚拟 DOM 中包含了创建 DOM 所需的各种信息, 对于首次渲染, 直接依照这些信息创建 DOM 节点即可.&lt;/p&gt;
&lt;p&gt;但虚拟 DOM 的真正价值在于“更新”: 当一个 list 中的某些项发生了变化, 或删除或增加了若干项, 如何通过对比前后的虚拟 DOM 树, 最小化地更新真实 DOM? 这就是 React 的核心目标.&lt;/p&gt;
&lt;h1&gt;2. React Diffing&lt;/h1&gt;
&lt;p&gt;“Diffing”即“找不同”, 就是解决上文引出的 React 的核心目标——如何通过对比新旧虚拟 DOM 树, 以在最小的操作次数下将旧 DOM 树转换为新 DOM 树.&lt;/p&gt;
&lt;p&gt;在算法领域中, 两棵树的转换目前最优的算法复杂度为 &lt;code class=&quot;language-text&quot;&gt;O(n**3)&lt;/code&gt; , n 为节点个数. 这意味着当树上有 1000 个元素时, 需要 10 亿次比较, 显然远远不够高效.&lt;/p&gt;
&lt;p&gt;React 在基于以下两个假设的基础上, 提出了一套复杂度为 &lt;code class=&quot;language-text&quot;&gt;O(n)&lt;/code&gt; 的启发式算法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不同类型(即标签名、组件名)的元素会产生不同的树;&lt;/li&gt;
&lt;li&gt;通过设置 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt; 属性来标识一组同级子元素在渲染前后是否保持不变.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在实践中, 以上两个假设在绝大多数场景下都成立.&lt;/p&gt;
&lt;h2&gt;2.1 Diffling 算法描述&lt;/h2&gt;
&lt;h3&gt;不同类型的元素/组件&lt;/h3&gt;
&lt;p&gt;当元素的标签或组件名发生变化, 直接卸载并替换以此元素作为根节点的整个子树.&lt;/p&gt;
&lt;h3&gt;同一类型的元素&lt;/h3&gt;
&lt;p&gt;当元素的标签相同时, React 保留此 DOM 节点, 仅对比和更新有改变的属性, 如 className、title 等, 然后递归对比其子节点.&lt;/p&gt;
&lt;p&gt;对于 &lt;code class=&quot;language-text&quot;&gt;style&lt;/code&gt; 属性, React 会继续深入对比, 仅更新有改变的属性, 如 color、fontSize 等.&lt;/p&gt;
&lt;h3&gt;同一类型的组件&lt;/h3&gt;
&lt;p&gt;当组件的 props 更新时, 组件实例保持不变, React 调用组件的 &lt;code class=&quot;language-text&quot;&gt;componentWillReceiveProps()&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;componentWillUpdate()&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;componentDidUpdate()&lt;/code&gt; 生命周期方法, 并执行 &lt;code class=&quot;language-text&quot;&gt;render()&lt;/code&gt; 方法.&lt;/p&gt;
&lt;p&gt;Diffing 算法会递归比对新旧 &lt;code class=&quot;language-text&quot;&gt;render()&lt;/code&gt; 执行的结果.&lt;/p&gt;
&lt;h3&gt;对子节点的递归&lt;/h3&gt;
&lt;p&gt;当一组同级子节点(列表)的末尾添加了新的子节点时, 上述 Diffing 算法的开销较小; 但当新元素被插入到列表开头时, Diffing 算法只能按顺序依次比对并重建从新元素开始的后续所有子节点, 造成极大的开销浪费.&lt;/p&gt;
&lt;p&gt;解决方案是为一组列表项添加 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt; 属性, 这样 React 就可以方便地比对出插入或删除项了.&lt;/p&gt;
&lt;p&gt;关于 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt; 属性, 应稳定、可预测且在列表内唯一(无需全局唯一), 如果数据有 ID 的话直接使用此 ID 作为 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt;, 或者利用数据中的一部分字段哈希出一个 key 值.&lt;/p&gt;
&lt;p&gt;避免使用数组索引值作为 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt;, 因为当插入或删除元素后, 之后的元素和索引值的对应关系都会发生错乱, 导致错误的比对结果.&lt;/p&gt;
&lt;p&gt;避免使用不稳定的 key(如随机数), 因为每次渲染都会发生改变, 从而导致列表项被不必要地重建.&lt;/p&gt;
&lt;h2&gt;2.2 递归的 Diffing&lt;/h2&gt;
&lt;p&gt;在 1.2 节中的虚拟 DOM 对象中可以得知: 虚拟 DOM 树的每个节点通过 &lt;code class=&quot;language-text&quot;&gt;children&lt;/code&gt; 属性构成了一个嵌套的树结构, 这意味着要以递归的形式遍历和比较新旧虚拟 DOM 树.&lt;/p&gt;
&lt;p&gt;2.1 节的策略解决了 Diffing 算法的时间复杂度的问题, 但我们还面临着另外一个重大的性能问题——浏览器的渲染线程和 JS 的执行线程是互斥的, 这意味着 DOM 节点过多时, 虚拟 DOM 树的构建和处理会长时间占用主线程, 使得一些需要高优先级处理的操作如用户输入、平滑动画等被阻塞, 严重影响使用体验.&lt;/p&gt;
&lt;h3&gt;时间切片(Time Slice)&lt;/h3&gt;
&lt;p&gt;为了解决浏览器主线程的阻塞问题, 引出 &lt;strong&gt;时间切片&lt;/strong&gt; 的策略——将整个工作流程分解成小的工作单元, 并在浏览器空闲时交由浏览器执行这些工作单元, 每个执行单元执行完毕后, 浏览器都可以选择中断渲染并处理其他需要更高优先级处理的工作.&lt;/p&gt;
&lt;p&gt;浏览器中提供了 &lt;code class=&quot;language-text&quot;&gt;requestIdleCallback&lt;/code&gt; 方法实现此功能, 将待调用的函数加入执行队列, 浏览器将在不影响关键事件处理的情况下逐个调用.&lt;/p&gt;
&lt;p&gt;考虑到浏览器的兼容性以及 &lt;code class=&quot;language-text&quot;&gt;requestIdleCallback&lt;/code&gt; 方法的不稳定性, React 自己实现了专用于 React 的类似 &lt;code class=&quot;language-text&quot;&gt;requestIdleCallback&lt;/code&gt; 且功能更完备的 &lt;code class=&quot;language-text&quot;&gt;Scheduler&lt;/code&gt; 来实现空闲时触发回调, 并提供了多种优先级供任务设置.&lt;/p&gt;
&lt;h3&gt;递归与时间切片&lt;/h3&gt;
&lt;p&gt;时间切片策略要求我们将虚拟 DOM 的更新操作分解为小的工作单元, 同时具备以下特性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可暂停、可恢复的更新;&lt;/li&gt;
&lt;li&gt;可跳过的重复性、覆盖性更新;&lt;/li&gt;
&lt;li&gt;具备优先级的更新.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于递归形式的程序来说, 这些是难以实现的. 于是就需要一个处于递归形式的虚拟 DOM 树上层的数据结构, 来辅助完成这些特性.&lt;/p&gt;
&lt;p&gt;这就是 React16 引入的重构后的算法核心——Fiber.&lt;/p&gt;
&lt;h1&gt;3. Fiber&lt;/h1&gt;
&lt;p&gt;从概念上来说, Fiber 就是重构后的虚拟 DOM 节点, 一个 Fiber 就是一个 JS 对象.&lt;/p&gt;
&lt;p&gt;Fiber 节点之间构成 &lt;strong&gt;单向链表&lt;/strong&gt; 结构, 以实现前文提到的几个特性: 更新可暂停/恢复、可跳过、可设优先级.&lt;/p&gt;
&lt;h2&gt;3.1 Fiber 节点&lt;/h2&gt;
&lt;p&gt;一个 Fiber 节点就是一个 JS 对象, 其中的关键属性可分类列举如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结构信息(构成链表的指针属性)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;return: 父节点&lt;/li&gt;
&lt;li&gt;child: 第一个子节点&lt;/li&gt;
&lt;li&gt;sibling: 右侧第一个兄弟节点&lt;/li&gt;
&lt;li&gt;alternate: 本节点在相邻更新时的状态, 用于比较节点前后的变化, 3.3 节详述&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组件信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tag: 组件创建类型, 如 FunctionComponent、ClassComponent、HostComponent 等&lt;/li&gt;
&lt;li&gt;key: 即 key 属性&lt;/li&gt;
&lt;li&gt;type: 组件类型, Function/Class 组件的 type 就是对应的 Function/Class 本身, Host 组件的 type 就是对应元素的 TagName&lt;/li&gt;
&lt;li&gt;stateNode: 对应的真实 DOM 节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本次更新的 props 和 state 相关信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pendingProps、memoizedProps&lt;/li&gt;
&lt;li&gt;memoizedState&lt;/li&gt;
&lt;li&gt;dependencies&lt;/li&gt;
&lt;li&gt;updateQueue&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新标记&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;effectTag: 节点更新类型, 如替换、更新、删除等&lt;/li&gt;
&lt;li&gt;nextEffect、firstEffect、lastEffect&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优先级相关: lanes、childrenLanes&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.2 Fiber 树&lt;/h2&gt;
&lt;p&gt;前文说到, Fiber 节点通过 &lt;code class=&quot;language-text&quot;&gt;return&lt;/code&gt; , &lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;slibling&lt;/code&gt; 属性构成了单向链表结构, 为了与 DOM 树对应, 习惯上仍称其为“树”.&lt;/p&gt;
&lt;p&gt;如一棵 DOM 树:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;html&quot;&gt;&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;Title&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;h1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;section&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;h2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;Section&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;h2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;p&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;Content&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;p&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;section&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;footer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;Footer&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;footer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其 &lt;code class=&quot;language-text&quot;&gt;section&lt;/code&gt; 节点的 Fiber 可表示为:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; sectionFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  key&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;SECTION_KEY&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  child&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; h2Fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  sibling&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; footerFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; divFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  alternate&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; oldSectionFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;otherFiberProps&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整体的 Fiber 结构:&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 351px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/b3457a432995dc057094ab9e3bb38373/7c2a6/DOM.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 79.74683544303798%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAABwklEQVQ4y5WU12oDUQxE9/9/y2D8YGxccO+9994mHAWZzWYdiECsb5E0M9J1MBgMhLdaLS0WC81mMz0eD2Gv10v/teB0Omk4HKpUKtnG4XDQ7Xb7mJA93/ffYQ9Go5FWq5V2u52KxaL2+33sxTiPRdjv95XNZo1uKpXS5XL5ge6vYO7CkC8OmKDT6Qi/Xq+aTqdar9dG+fl8mruxdzweLRCNz+ezMZvP5+r1eppMJmq32wo2m43wSqVigclkUrlczpJ3u11lMhnl83lbFwoFIRE6w4g9ktVqNWtqtVr9TujVQMAaFNAECcFU986HDYrENhoNi6WIacgG0BOJhB1EOxztfFTX5XL5XgdAhgqJoO1NCdt2u9X9fv84e+HJMIQMM5Q5ADaI6B5UOUO38Xhs80rTKO4yMWro5+gDDukwARgJaEI6nbbLJCmXy4aexDSARADhHmuPtYQkYKhxqvN1AyX6eFebzaY1jUDO0B0pkORN2bvpHhWdoQcNCEEc9yQp8n4pcSJ7QjoLXZCgL5TD44OO7MPC2QR/vVNoQol/I28WmjJmFEICCqAhxev1+m+E4TeMNuEBJjko6D6vCOSuNUaxL8UZzYzW8I5pAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;./DOM.png&quot;
        title=&quot;./DOM.png&quot;
        src=&quot;/static/b3457a432995dc057094ab9e3bb38373/7c2a6/DOM.png&quot;
        srcset=&quot;/static/b3457a432995dc057094ab9e3bb38373/c26ae/DOM.png 158w,
/static/b3457a432995dc057094ab9e3bb38373/6bdcf/DOM.png 315w,
/static/b3457a432995dc057094ab9e3bb38373/7c2a6/DOM.png 351w&quot;
        sizes=&quot;(max-width: 351px) 100vw, 351px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3.3 Fiber 架构&lt;/h2&gt;
&lt;p&gt;基于 Fiber 构成的虚拟 DOM 树就是 Fiber 架构.&lt;/p&gt;
&lt;p&gt;在 3.1 节中我们介绍过, 在 Fiber 节点中有一个重要属性 &lt;code class=&quot;language-text&quot;&gt;alternate&lt;/code&gt; , 单词意为“备用”.&lt;/p&gt;
&lt;p&gt;实际上, 在 React 中最多会同时存在两棵 Fiber 树:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前显示在屏幕上、已经构建完成的 Fiber 树称为“Current Fiber Tree”, 我们将其中的 Fiber 节点简写为 &lt;code class=&quot;language-text&quot;&gt;currFiber&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;当前正在构建的 Fiber 树称为“WorkInProgress Fiber Tree”, 我们将其 Fiber 节点节点简写为 &lt;code class=&quot;language-text&quot;&gt;wipFiber&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而这两棵树中节点的 &lt;code class=&quot;language-text&quot;&gt;alternate&lt;/code&gt; 属性互相指向对方树中的对应节点, 即: &lt;code class=&quot;language-text&quot;&gt;currFiber.alternate === wipFiber; wipFiber.alternate === currFber;&lt;/code&gt; 他们用于对比更新前后的节点以决定如何更新此节点.&lt;/p&gt;
&lt;p&gt;在 React 中, 整个应用的根节点为 &lt;code class=&quot;language-text&quot;&gt;fiberRoot&lt;/code&gt; , 当 wipFiber 树构建完成后, &lt;code class=&quot;language-text&quot;&gt;fiberRoot.current&lt;/code&gt; 将从 currFiber 树的根节点切换为 wipFiber 的根节点, 以完成更新操作.&lt;/p&gt;
&lt;h3&gt;3.1 基于 Fiber 的调度——时间切片&lt;/h3&gt;
&lt;p&gt;在 2.2 节我们讨论了采用拆分工作单元并以时间切片的方式执行, 以避免阻塞主线程. 在 Fiber 架构下, 每个 Fiber 节点就是一个工作单元.&lt;/p&gt;
&lt;p&gt;在以下示例代码中, 我们使用浏览器提供的 &lt;code class=&quot;language-text&quot;&gt;requestIdleCallback&lt;/code&gt; 方法演示这个过程, 它会在浏览器空闲时执行一个 workLoop、处理一个 Fiber 节点, 然后可以根据实际情况继续执行或暂停等待执行下一个 workLoop.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;workLoop&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;deadline&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; shouldYield &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;nextUnitOfWork &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;shouldYield&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 处理一个Fiber节点, 返回下一个Fiber节点, 详见3.3节&lt;/span&gt;
    nextUnitOfWork &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;performUnitOfWork&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;nextUnitOfWork&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 暂停处理的演示: 当时间不足时取消循环处理过程&lt;/span&gt;
    shouldYield &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; deadline&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;timeRemaining&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 当执行完毕(不存在下一个执行单元), 提交整个DOM树&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;nextUnitOfWork &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; wipRoot&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;commitRoot&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;requestIdleCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;workLoop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;requestIdleCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;workLoop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.2 对 Fiber 节点的处理顺序——DFS&lt;/h3&gt;
&lt;p&gt;由前文我们可知, Fiber 节点通过 &lt;code class=&quot;language-text&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;sibling&lt;/code&gt; 三个属性相互连接, 整体构成一个单向链表结构,其调度方式就是 深度优先遍历 :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以 wipFiber 树的 Root 节点作为第一个执行单元;&lt;/li&gt;
&lt;li&gt;若当前执行单元存在 child 节点, 则将 child 节点作为下一个执行单元;&lt;/li&gt;
&lt;li&gt;重复 2, 直至当前执行单元无 child;&lt;/li&gt;
&lt;li&gt;若当前执行单元存在 sibling 节点, 则将 sibling 节点作为下一个执行单元, 并回到 2;&lt;/li&gt;
&lt;li&gt;若当前执行单元无 child 且无 sibling, 返回到父节点, 并回到 4;&lt;/li&gt;
&lt;li&gt;重复 5; 直至回到 Root 节点, 执行完毕, 将 &lt;code class=&quot;language-text&quot;&gt;fiberRoot.current&lt;/code&gt; 只为 wipFiber 树的根节点.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上步骤说明, Fiber 节点通过 &lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt; → &lt;code class=&quot;language-text&quot;&gt;sibling&lt;/code&gt; → &lt;code class=&quot;language-text&quot;&gt;return&lt;/code&gt; 的顺序进行深度优先遍历“处理”, 而后更新 Fiber 树. 那么如何“处理”Fiber 节点呢?&lt;/p&gt;
&lt;h3&gt;3.3 对 Fiber 节点的处理过程&lt;/h3&gt;
&lt;p&gt;对 Fiber 节点的处理就是执行一个 &lt;code class=&quot;language-text&quot;&gt;performUnitOfWork&lt;/code&gt; 方法, 它接收一个将要处理的 Fiber 节点, 然后完成以下工作:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;完善构建 Fiber 节点: 创建 DOM 并获取 &lt;code class=&quot;language-text&quot;&gt;children&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于 HostComponent 和 ClassComponent, 根据 Fiber 中的相关属性, 创建 DOM 节点并赋给 &lt;code class=&quot;language-text&quot;&gt;Fiber.stateNode&lt;/code&gt; 属性;&lt;/li&gt;
&lt;li&gt;对于 FunctionComponent, 直接通过函数调用获取其 children: &lt;code class=&quot;language-text&quot;&gt;Fiber.type(Fiber.props)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 执行工作单元,并返回下一个工作单元&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;performUnitOfWork&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;fiber&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;token comment&quot;&gt;// 构建当前节点的fiber&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; isFunctionComponent &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;type &lt;span class=&quot;token keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Function&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;isFunctionComponent&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;token function&quot;&gt;updateFunctionComponent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;token function&quot;&gt;updateHostComponent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

 &lt;span class=&quot;token comment&quot;&gt;// 处理子节点, 构建Fiber树&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; elements &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;children
 &lt;span class=&quot;token function&quot;&gt;reconcileChildren&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; elements&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

 &lt;span class=&quot;token comment&quot;&gt;// TODO: 返回下一个执行单元&lt;/span&gt;
 &lt;span class=&quot;token comment&quot;&gt;// fiber.child || fiber.sibling || fiber.return&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// Class/Host组件: 创建DOM&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateHostComponent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;fiber&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dom&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
   fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dom &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createDom&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;token function&quot;&gt;reconcileChildren&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;children&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 更新Function组件, Function组件需要从返回值获取子组件&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 注意: Function组件无DOM&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateFunctionComponent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;fiber&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;token comment&quot;&gt;// 初始化hooks&lt;/span&gt;
 wipFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fiber
 hookIndex &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
 fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;hooks &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; children &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Function组件返回children&lt;/span&gt;
 &lt;span class=&quot;token function&quot;&gt;reconcileChildren&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; children&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// TODO: reconcileChildren处理子节点,见第3步&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 &lt;code class=&quot;language-text&quot;&gt;Fiber.alternate&lt;/code&gt; 获取 &lt;code class=&quot;language-text&quot;&gt;oldFiber&lt;/code&gt; , 即上一次更新后的 Fiber 值, 然后在下一步中构建和 Diff 当前 Fiber 的 &lt;code class=&quot;language-text&quot;&gt;children&lt;/code&gt; .&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;reconcileChildren&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;wipFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; elements&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; oldFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;child
 &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构建 &lt;code class=&quot;language-text&quot;&gt;children&lt;/code&gt; Fibers, 对于每个子 Fiber, 同步地完成以下工作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建 Fiber 链表: 为每个子元素创建 Fiber, 并将父 Fiber 的 &lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt; 属性指向第一个子 Fiber, 然后按顺序将子 Fiber 的 &lt;code class=&quot;language-text&quot;&gt;sibling&lt;/code&gt; 属性指向下一个子 Fiber;&lt;/li&gt;
&lt;li&gt;对比(Diffing)新旧 Fiber 节点的 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt; 等属性, 确定节点是可以直接复用、替换、更新还是删除, 需要更新的 Fiber 节点在其 &lt;code class=&quot;language-text&quot;&gt;effectTag&lt;/code&gt; 属性中打上 &lt;code class=&quot;language-text&quot;&gt;Update&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;Placement&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;PlacementAndUpdate&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;Deletion&lt;/code&gt; 等标记, 以在提交更新阶段进行处理.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;reconcileChildren&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;wipFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; elements&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; oldFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;child&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; index &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; prevSibling &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

 &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;index &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; elements&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; oldFiber &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; element &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; elements&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;index&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; newFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

   &lt;span class=&quot;token comment&quot;&gt;// Compare oldFiber to element&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; sameType &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; oldFiber &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; element &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; element&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;type &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; oldFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;type&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

   &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sameType&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;token comment&quot;&gt;// update the node&lt;/span&gt;
     newFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
       type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; oldFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;type&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; element&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       dom&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; oldFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dom&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       parent&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; wipFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       alternate&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; oldFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       effectTag&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;UPDATE&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
     &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;element &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;sameType&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;token comment&quot;&gt;// add this node&lt;/span&gt;
     newFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
       type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; element&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;type&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; element&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       dom&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       parent&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; wipFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       alternate&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       effectTag&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;PLACEMENT&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
     &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;oldFiber &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;sameType&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;token comment&quot;&gt;// delete the oldFiber&apos;s node&lt;/span&gt;
     oldFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;effectTag &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;DELETION&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
     deletions&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;oldFiber&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;oldFiber&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
     oldFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; oldFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sibling&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;index &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
     wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;child &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newFiber&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
     prevSibling &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newFiber&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

   prevSibling &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newFiber&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   index&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按 DFS 顺序返回下一个工作单元, 示例代码如下:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;child&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;child
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; nextFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fiber
&lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;nextFiber&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;nextFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sibling&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; nextFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sibling
 &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
 nextFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; nextFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;parent
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当 DFS 过程回到根节点时, 表明本次更新的 wipFiber 树 构建完成, 进入下一步的提交更新阶段.&lt;/p&gt;
&lt;h3&gt;3.4 提交更新阶段&lt;/h3&gt;
&lt;p&gt;在进入本阶段时, 新的 Fiber 树已构建完成, 需要进行替换、更新或删除的 Fiber 节点也在其 &lt;code class=&quot;language-text&quot;&gt;effectTag&lt;/code&gt; 中进行了标记, 所以本阶段第一个工作就是根据 &lt;code class=&quot;language-text&quot;&gt;effectTag&lt;/code&gt; 操作真实 DOM.&lt;/p&gt;
&lt;p&gt;为了避免从头再遍历 Fiber 树寻找具有 &lt;code class=&quot;language-text&quot;&gt;effectTag&lt;/code&gt; 属性的 Fiber, 在上一步 Fiber 树的构建过程中保存了一条需要更新的 Fiber 节点的单向链表 &lt;code class=&quot;language-text&quot;&gt;effectList&lt;/code&gt; , 并将此链表的头节点存储在 Fiber 树根节点的 &lt;code class=&quot;language-text&quot;&gt;firstEffect&lt;/code&gt; 属性中, 同时这些 Fiber 节点的 &lt;code class=&quot;language-text&quot;&gt;updateQueue&lt;/code&gt; 属性中也保存了需要更新的 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;除了更新真实 DOM 外, 在提交更新阶段还需要在特定阶段调用和处理生命周期方法、执行 Hooks 操作, 本文不再详述.&lt;/p&gt;
&lt;p&gt;在此参考了 &lt;a href=&quot;https://pomb.us/build-your-own-react/&quot;&gt;https://pomb.us/build-your-own-react/&lt;/a&gt; 中提供的 &lt;code class=&quot;language-text&quot;&gt;useState&lt;/code&gt; Hook 的实现代码, 有助于理解在执行 &lt;code class=&quot;language-text&quot;&gt;setState&lt;/code&gt; 方法后都发生了什么:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;initial&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 判断上一次渲染是否存在此Hook,如果存在就使用上一个state,否则创建新的hook并更新索引&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; oldHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;
    wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
    wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;hooks &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
    wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;hooks&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;hookIndex&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; hook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    state&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; oldHook &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; oldHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; initial&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    queue&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 每次执行setState时,将action加入此队列,并在下一次渲染时执行&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// 下一次渲染时, 获取执行队列并逐步执行, 使得state保持最新&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; actions &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; oldHook &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; oldHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;queue &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
  actions&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;action&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// setState方法: 将action添加到执行队列并触发渲染, 在下一次渲染时执行此action&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;setState&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;action&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;action&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 执行setState后应重新触发渲染&lt;/span&gt;
    wipRoot &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      dom&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; currentRoot&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dom&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; currentRoot&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      alternate&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; currentRoot&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    nextUnitOfWork &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; wipRoot
    deletions &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;hooks&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;hook&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  hookIndex&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; setState&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;参考文献&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;React 官方文档与相关源码&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pomb.us/build-your-own-react/&quot;&gt;https://pomb.us/build-your-own-react/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://react.iamkasong.com/renderer/beforeMutation.html#commitbeforemutationeffects&quot;&gt;https://react.iamkasong.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[在线编辑器实现浅析]]></title><description><![CDATA[在线编辑器根据其侧重点和实现方式的不同, 可大致分为富文本编辑器和代码编辑器两类, 本文对这两类编辑器的实现方式进行最基本的解读和分析. 富文本编辑器 基本实现原理 富文本编辑器的实现原理很简单, 其编辑区域一般使用一个  的  元素来实现. 当 HTML…]]></description><link>https://hrayd.github.io/online-editor/</link><guid isPermaLink="false">https://hrayd.github.io/online-editor/</guid><pubDate>Sat, 10 Jul 2021 22:00:00 GMT</pubDate><content:encoded>&lt;p&gt;在线编辑器根据其侧重点和实现方式的不同, 可大致分为富文本编辑器和代码编辑器两类, 本文对这两类编辑器的实现方式进行最基本的解读和分析.&lt;/p&gt;
&lt;h1&gt;富文本编辑器&lt;/h1&gt;
&lt;h2&gt;基本实现原理&lt;/h2&gt;
&lt;p&gt;富文本编辑器的实现原理很简单, 其编辑区域一般使用一个 &lt;code class=&quot;language-text&quot;&gt;contentedtable=&amp;quot;true&amp;quot;&lt;/code&gt; 的 &lt;code class=&quot;language-text&quot;&gt;div&lt;/code&gt; 元素来实现. 当 HTML 元素的 &lt;code class=&quot;language-text&quot;&gt;contenteditable&lt;/code&gt; 属性设为 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt; 后, 该元素的内容变为可编辑状态:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;html&quot;&gt;&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;contenteditable&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;true&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;这是一个可编辑元素&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时即可修改元素的内容, 当点击回车键后, 会自动生成一个 &lt;code class=&quot;language-text&quot;&gt;p&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;div&lt;/code&gt; 元素.
可设置 &lt;code class=&quot;language-text&quot;&gt;outline: none&lt;/code&gt; 以去掉默认的聚焦态边框.&lt;/p&gt;
&lt;h2&gt;修改样式与内容&lt;/h2&gt;
&lt;p&gt;此时即可修改元素的内容, 当点击回车键后, 会自动生成一个 &lt;code class=&quot;language-text&quot;&gt;p&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;div&lt;/code&gt; 元素.&lt;/p&gt;
&lt;p&gt;可设置 &lt;code class=&quot;language-text&quot;&gt;outline: none&lt;/code&gt; 以去掉默认的聚焦态边框.文本样式的修改主要通过调用 &lt;code class=&quot;language-text&quot;&gt;document.execCommand()&lt;/code&gt; 方法来实现, 此方法会影响当前处于活动状态的可编辑元素. 此方法接收三个输入参数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令名称[string], 如 fontsize、backcolor、undo 等, 详见 MDN 相关参考.&lt;/li&gt;
&lt;li&gt;是否展开用户界面[boolean], 一般传入 false 即可.&lt;/li&gt;
&lt;li&gt;命令参数[可选], 如 fontSize 传入字体尺寸、backColor 传入 color 类型的 string 等, 默认为 null.&lt;/li&gt;
&lt;li&gt;返回值: boolean, 返回 false 表示命令不被支持或未启用.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 将当前行设为“Heading2”, 添加“h2”标签&lt;/span&gt;
document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;execCommand&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;formatblock&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;h2&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 在插入点或选中文字部分修改字体、字号&lt;/span&gt;
document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;execCommand&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;fontname&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Times New Roman&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;execCommand&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;fontsize&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;3&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 撤销上一次修改&lt;/span&gt;
document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;execCommand&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;undo&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; 是否展开用户界面&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;boolean&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 一般传入&lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;即可&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;浏览器实现差异&lt;/h2&gt;
&lt;p&gt;可编辑元素在不同浏览器及其版本之间可能存在一些差异, 如按下回车键后, IE/Opera 会添加一个 &lt;code class=&quot;language-text&quot;&gt;p&lt;/code&gt; 标签元素, 旧版本的 Firefox 会添加 &lt;code class=&quot;language-text&quot;&gt;br&lt;/code&gt; 元素, 而 Chrome/Safari 会添加 &lt;code class=&quot;language-text&quot;&gt;div&lt;/code&gt; 元素. 通过调用 &lt;code class=&quot;language-text&quot;&gt;document.execCommand(&amp;quot;defaultParagraphSeparator&amp;quot;, false, &amp;quot;div&amp;quot;)&lt;/code&gt; 可显式指定创建新段落的方式, 此方法也支持使用自定义标签, 如语雀的编辑器就使用了以 &lt;code class=&quot;language-text&quot;&gt;ne&lt;/code&gt; 开头的一系列自定义标签.&lt;/p&gt;
&lt;p&gt;文末提供了 MDN 中展示的一个最基本的原生富文本编辑器 Demo.&lt;/p&gt;
&lt;hr&gt;
&lt;h1&gt;代码编辑器&lt;/h1&gt;
&lt;p&gt;富文本编辑器受到原生 HTML 和 DOM 技术的友好支持, 其编辑区生成的就是一组的 HTML 元素, 通过自定义标签、添加自定义样式表等方式来定制主题样式即可.&lt;/p&gt;
&lt;p&gt;相较于富文本编辑器, 代码编辑器则要复杂得多. 代码编辑器的核心是通过对代码文本的词法、语法和语义分析, 将内容划分为关键字、变量名、字面量、函数体等元素, 并为每类元素添加不同的 CSS class, 同时插入一些带边框的空格元素来实现代码的缩进和格式化等.&lt;/p&gt;
&lt;h2&gt;monaco-editor&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;monaco-editor&lt;/code&gt; 是 VSCode 中分离出的编辑器模块, 也是目前最典型、应用最为广泛的前端代码编辑器之一, 本文以 &lt;code class=&quot;language-text&quot;&gt;monaco-editor&lt;/code&gt; 为例分析代码编辑器的实现方式.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;monaco-editor&lt;/code&gt; 的编辑器区域使用了绝对定位、完全重叠的两层 &lt;code class=&quot;language-text&quot;&gt;div&lt;/code&gt; 区域与一个 1px 宽度的 &lt;code class=&quot;language-text&quot;&gt;textarea&lt;/code&gt; 元素构成:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一层 div 主要负责背景样式的渲染, 其内部由绝对定位、固定高度的 div 代码行构成, 每个代码行内包含若干个绝对定位的 div 块, 用于展示缩进线、当前聚焦行边框、文字选中态高亮、警告和错误信息的下划波浪线等样式信息. 这一层的所有 div 都没有文本元素.&lt;/li&gt;
&lt;li&gt;第二层 div 用于渲染代码文本, 内部的 div 代码行与第一层完全重叠, 每个代码行内由若干 span 标签包裹的文本元素(一个单词、一个标点符号、一段连续空格等)构成. 对代码进行语义分析后为每个 span 元素赋予不同的 class , 从而实现代码高亮.&lt;/li&gt;
&lt;li&gt;输入光标为一个绝对定位、宽度为 1px、内容为空的 textarea , 当使用鼠标或触控板单击编辑器区域、或使用方向键和其他快捷键改变输入光标位置后, 需要计算出正确的文本编辑位置并更新 textarea 元素的位置.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1&gt;结语&lt;/h1&gt;
&lt;p&gt;本文对富文本编辑器和代码编辑器的实现方式进行了最基本最浅显的分析, 相较于代码编辑器而言, 富文本编辑器应用更广、更贴近前端.&lt;/p&gt;
&lt;p&gt;作为学习者, 可以扒一扒市面上比较有名的在线富文本编辑器(如语雀、幕布、Notion、EverNote 等), 发挥自己的创意, 做一个自己心目中更易用、更美观、更极客的富文本编辑器吧!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;附:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Editable_content/Rich-Text_Editing_in_Mozilla#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E4%BD%86%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8&quot;&gt;MDN - 一个简易但完整的富文本编辑器实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Microsoft/monaco-editor&quot;&gt;Monaco Editor - Github Pages&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://prosemirror.net/&quot;&gt;ProseMirror - 一个开源的支持 Markdown、WYSIWYG 的富文本编辑器 Toolkit&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Clean Architecture]]></title><description><![CDATA[第一部分 概述 第…]]></description><link>https://hrayd.github.io/clean-architecture/</link><guid isPermaLink="false">https://hrayd.github.io/clean-architecture/</guid><pubDate>Fri, 18 Jun 2021 22:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;第一部分 概述&lt;/h2&gt;
&lt;h3&gt;第 1 章 设计与架构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;随着软件版本的更迭: 需要的工程师人数越来越多、人均生产效率显著降低(以同期代码行数作为统计)、每行代码的变更成本显著增高.&lt;/li&gt;
&lt;li&gt;对于重构的过于乐观: 为了快速上线而容忍混乱的代码, 忽略软件架构, 而寄希望于未来的重构工作. 事实上, 新功能源源不断, 混乱的架构又会导致新功能的开发成本急速上升, 生产效率持续下降, 陷入恶性循环, 导致重构的成本越来越大, 重构的时机几乎不会存在.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 2 章 两个价值维度&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;两个价值纬度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;系统行为, 即软件功能是否满足需求&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;系统架构, 即软件是否足够灵活&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;何者更重要?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是系统正常工作更重要, 还是系统易于修改更重要?&lt;/li&gt;
&lt;li&gt;对于业务部门来说, 答案一般是前者, 而一旦开发人员也选择了前者, 紧接着就会面临源源不断的新增需求和需求变更, 导致生产效率直线下降.&lt;/li&gt;
&lt;li&gt;所以对于开发人员来说, 系统架构大于系统行为: 只要保持系统的灵活性, 系统行为总会以平和的方式得到满足.&lt;/li&gt;
&lt;li&gt;开发团队同市场、销售、运营团队一样需要“长期抗争”, 保护系统的灵活性/可维护性, 是开发团队的职责.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第二部分 编程范式&lt;/h2&gt;
&lt;h3&gt;第 3 章 编程范式总览&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;三大编程范式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构化编程&lt;/li&gt;
&lt;li&gt;对程序控制权的直接转移进行了限制和规范&lt;/li&gt;
&lt;li&gt;限制了 goto: 使用 if、for、while 等流程控制&lt;/li&gt;
&lt;li&gt;面向对象编程&lt;/li&gt;
&lt;li&gt;对程序控制权的间接转移进行了限制和规范&lt;/li&gt;
&lt;li&gt;限制了函数指针&lt;/li&gt;
&lt;li&gt;函数式编程&lt;/li&gt;
&lt;li&gt;对程序中的赋值进行了限制和规范&lt;/li&gt;
&lt;li&gt;限制了赋值语句&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编程范式与架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;架构的三大关注点&lt;/li&gt;
&lt;li&gt;功能性&lt;/li&gt;
&lt;li&gt;组件独立性&lt;/li&gt;
&lt;li&gt;数据管理&lt;/li&gt;
&lt;li&gt;编程范式的作用&lt;/li&gt;
&lt;li&gt;结构化编程: 实现逻辑功能&lt;/li&gt;
&lt;li&gt;面向对象: 封装与多态&lt;/li&gt;
&lt;li&gt;函数式: 规范数据存放与访问权限&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 4 章 结构化编程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可推导性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三种基本结构&lt;/li&gt;
&lt;li&gt;顺序结构&lt;/li&gt;
&lt;li&gt;分支结构&lt;/li&gt;
&lt;li&gt;循环结构&lt;/li&gt;
&lt;li&gt;可以用三种基本结构构造出任何程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不受限制的直接控制转移语句——goto 是有害的, 可被三种基本结构替代&lt;/li&gt;
&lt;li&gt;结构化编程范式使得可以将大型系统设计拆分为模块和组件, 然后可递归拆分为更小的、可证明的函数&lt;/li&gt;
&lt;li&gt;结构化编程范式促使将一段程序递归降解为一系列小单元, 程序的测试过程即证伪过程.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 5 章 面向对象编程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;面向对象编程语言&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;封装性: 较 C 而言实际上减弱了封装性&lt;/li&gt;
&lt;li&gt;继承性: 提供了一定便利,但没有开创出新&lt;/li&gt;
&lt;li&gt;多态: C 本来就有,只是提供了安全性和便利&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面向对象的多态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插件式架构&lt;/li&gt;
&lt;li&gt;程序应与设备无关&lt;/li&gt;
&lt;li&gt;依赖反转&lt;/li&gt;
&lt;li&gt;原本: 层层依赖-上层组件依赖下层组件&lt;/li&gt;
&lt;li&gt;多态: 上层组件提供需求接口, 底层组件实现接口&lt;/li&gt;
&lt;li&gt;例子&lt;/li&gt;
&lt;li&gt;原本: 业务逻辑引入(依赖)用户界面和数据库&lt;/li&gt;
&lt;li&gt;应用多态: 用户界面和数据库作为业务逻辑的插件,从而可以各自独立部属&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;架构师眼中的面向对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以多态为手段来对源代码中的依赖关系进行控制, 构建出某种插件式架构, 让高层策略性组件和底层实现性组件相分离, 底层组件可以作为插件, 独立于高层组件进行开发和部属&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 6 章 函数式编程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;变量不可变&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不可变性与软件架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果变量不可变, 一切并发问题都会不复存在: 竞争、死锁、并发更新等.&lt;/li&gt;
&lt;li&gt;不可变性是否可行? 如果能忽略存储器和处理器的速度限制,则可行; 否则只有一定情况下可行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可变形隔离&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个架构设计良好的应用程序应该将状态修改的部分和不需要修改状态的部分隔离成单独的组件，然后用合适的机制来保护可变量&lt;/li&gt;
&lt;li&gt;软件架构师应该着力于将大部分处理逻辑都归于不可变组件中，可变状态组件的逻辑应该越少越好&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件溯源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果有足够大的存储量和处理能力，应用程序就可以用完全不可变的、纯函数式的方式来编程&lt;/li&gt;
&lt;li&gt;只存储事务记录, 不存储具体状态, 通过计算所有事务来获取当前状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第三部分 设计原则&lt;/h2&gt;
&lt;h3&gt;综述&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;构建中层结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使软件可容忍被改动&lt;/li&gt;
&lt;li&gt;使软件更容易被理解&lt;/li&gt;
&lt;li&gt;构建可复用的组件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SOLID 原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SRP: 单一职责原则——每个模块有且只有一个被改变的理由&lt;/li&gt;
&lt;li&gt;OCP: 开闭原则——允许通过新增代码来扩展功能,尽量减少代码修改&lt;/li&gt;
&lt;li&gt;LSP: 李氏替换原则——遵守同一约定的组件可相互替换&lt;/li&gt;
&lt;li&gt;ISP: 接口隔离原则——在设计中避免不必要的依赖&lt;/li&gt;
&lt;li&gt;DIP: 依赖反转原则——实现底层细节的代码应依赖高层策略性代码,而非反向依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 7 章 SRP: 单一职责原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;不仅仅是“每个模块只做一件事”&lt;/li&gt;
&lt;li&gt;任何一个软件模块都应该只对某一类行为者负责&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 8 章 OCP: 开闭原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;易于扩展(新增代码),抗拒修改&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;将需求分组,即 SRP&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;调整分组之间的依赖,即 DIP&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果 A(Father)组件不想被 B(Child)组件发生的修改所影响,那么就让 B 依赖于 A.&lt;/li&gt;
&lt;li&gt;分层设计: 高层组件更核心、更封闭, 低层依赖于高层.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 9 章 LSP: 李氏替换原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;子类型可以替代父类型被调用/使用, 即继承关系&lt;/li&gt;
&lt;li&gt;LSP 演变为更广泛的、指导接口与实现方式的设计原则&lt;/li&gt;
&lt;li&gt;反例: 当核心业务逻辑出现无法避免的例外情况时,避免在核心组件中进行特殊情况判断,而应该使用一个额外的调度组件来处理特殊情况&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 10 章 ISP: 接口隔离原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;尽量避免多个行为依赖并操作同一个接口: 在中间再做一层封装进行隔离.&lt;/li&gt;
&lt;li&gt;尽量减少不必要的依赖, 第 13 章再继续探讨更多细节&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 11 章 DIP: 依赖反转原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在源代码层次上只引用包含接口、抽象类或其他抽象类型声明的源文件, 而不引用任何具体实现.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编码守则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多使用抽象接口,避免使用多变的具体实现类&lt;/li&gt;
&lt;li&gt;不要在具体实现类上创建衍生类&lt;/li&gt;
&lt;li&gt;不要覆盖(override)包含具体实现的函数&lt;/li&gt;
&lt;li&gt;避免在代码中写入任何具体实现相关或其他容易变动的事务的名字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用抽象工厂模式创建对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第四部分 组件构建原则&lt;/h2&gt;
&lt;h3&gt;第 12 章 组件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;组件是软件在部属过程中的最小单元&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在编译运行语言中是一组二进制文件;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在解释运行语言中是一组源代码文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;设计良好的组件: 独立部署、单独开发&lt;/li&gt;
&lt;li&gt;组件概念的历史: 动态链接文件&lt;/li&gt;
&lt;li&gt;现状: 组件化的插件式架构&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 13 章 组件聚合&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;问题: 哪些类应该被合成一个组件?&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;REP: 复用/发布等同原则&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- 软件复用的最小粒度应等同于其发布的最小粒度
- 被复用的组件应有明确的发布版本号、适当的通知和发布文档
- 组件中包含的类与模块也应该可以同时发布,共享相同的版本号和版本跟踪,被包含在发布文档中.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CCP: 共同闭包原则&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- 将会同时修改、并且为相同目的而修改的类放入同一组件; 反之放入不同组件.
- SRP原则在组件层面的阐述
- 一个组件应该只有一个变更原因;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一次变更最好都体现在一个组件中 - 一般来说, 可维护性比可复用性重要得多&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CRP: 共同复用原则&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- 将经常共同复用的类和模块放入同一个组件
- 不是紧密相连的类不应被放入同一组件
- 是ISP原则的普适版&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;组件聚合原则张力图&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;REP 和 CCP 使组件更大, CRP 使组件更小, 架构师的任务就是在三原则中进行取舍, 并且是随着项目状态逐步调整&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目早期一般偏向右侧, 主要牺牲复用性&lt;/li&gt;
&lt;li&gt;随着项目逐渐成熟,其他项目对其产生依赖,会逐渐向左侧滑动&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 14 章 组件耦合&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无依赖环原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决方案&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;将项目划分为可独立发布的组件&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;组件独立发布,打版本号并通知其他成员&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;其他开发者基于组件公开发布的版本进行开发,并可以选择是否采用新版本&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;组件依赖图: 有向无环图(DAG)&lt;/li&gt;
&lt;li&gt;可以直观地判断出某个组件变更的影响范围&lt;/li&gt;
&lt;li&gt;无环: 从任意节点开始沿依赖线都回不到起始点&lt;/li&gt;
&lt;li&gt;发布过程从下至上进行编译、测试、发布&lt;/li&gt;
&lt;li&gt;循环依赖: 组件依赖图存在环, 组件的独立维护工作以及单元测试、发布流程都将十分困难&lt;/li&gt;
&lt;li&gt;消除循环依赖&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;应用依赖反转原则(DIP), 将环形依赖反转&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;创建新的上层组件, 将相互依赖的类进行抽象提取&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;当循环依赖出现时,必须立刻进行消除,调整组件结构&lt;/li&gt;
&lt;li&gt;组件结构图的构建&lt;/li&gt;
&lt;li&gt;不可能在系统构建之初就被完美设计, 因为它不是描述软件功能的,而是软件构建性和维护性的地图&lt;/li&gt;
&lt;li&gt;隔离频繁的变更: 将稳定的高价值组件与常变的组件进行隔离&lt;/li&gt;
&lt;li&gt;随着项目的逻辑设计一起扩张和演进&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;稳定依赖原则(SDP)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;稳定性&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直观上&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果组件不依赖其他组件, 或被多个其他组件依赖, 则是稳定的组件.&lt;/li&gt;
&lt;li&gt;如果组件依赖多个组件, 则是不稳定的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I(不稳定性) = FanOut / (FanIn + FanOut)&lt;/li&gt;
&lt;li&gt;FanIn: 入向依赖,组件内部类被外部类依赖的数量&lt;/li&gt;
&lt;li&gt;FanOut: 出向依赖, 组件内部类依赖外部类的数量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;要求: 每个组件的 I 指标都大于其所依赖组件的 I 指标. 即: 越高层的组件越稳定.&lt;/li&gt;
&lt;li&gt;高阶组件 &gt;&gt; I=0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;稳定抽象原则(SAP)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组件的抽象化程度应与其稳定性保持一致,&lt;/li&gt;
&lt;li&gt;如何使一个趋于无限稳定(I=0)的组件接收变更?&lt;/li&gt;
&lt;li&gt;抽象类(与接口)&lt;/li&gt;
&lt;li&gt;指标&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A(抽象化程度) = Na / Nc&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Na: 组件中类的数量&lt;/li&gt;
&lt;li&gt;Nc: 组件中抽象类和接口的数量&lt;/li&gt;
&lt;li&gt;0 表示没有抽象类; 1 表示只有抽象类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SDP 与 SAP&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I/A 图&lt;/li&gt;
&lt;li&gt;最稳定、包含无限抽象类的组件位于左上角(0,1)&lt;/li&gt;
&lt;li&gt;最不稳定、最具体的组件位于右下角(1,0)&lt;/li&gt;
&lt;li&gt;主序列、痛苦区与无用区&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;痛苦区: 稳定且具体, 涉及很多具体业务但又难以修改&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;典型: 数据库的表结构、工具型类库&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;无用区: 无限抽象、但没有被其他组件依赖, 多为无用代码&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主序列线: 合适的位置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽量让组件贴近主序列线&lt;/li&gt;
&lt;li&gt;最优位置是线的两端&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;D 指标 = |A + I - 1|&lt;/li&gt;
&lt;li&gt;组件与主序列线的距离: 0 表示在主序列上; 1 表示最远位置&lt;/li&gt;
&lt;li&gt;可用“D 指标小于 xx”来指导组件的重构&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用途&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重点分析 D 指标处于平均值的标准差之外的组件: 要么过于抽象但依赖不足, 要么过于具体而被依赖太多&lt;/li&gt;
&lt;li&gt;按时间跟踪每个组件的 D 指标, 及时发现组件架构隐患&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第五部分 软件架构&lt;/h2&gt;
&lt;h3&gt;第 15 章 什么是软件架构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;软件架构师: 坚持一线程序员、更多的编程任务&lt;/li&gt;
&lt;li&gt;实质: 如何将系统切分成组件, 并安排好组件之间的排列关系及互相通信的方式.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目的: 更好地对组件进行研发、部属、运行及维护&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发: 当开发人员组成复杂、系统体量较大时, 清晰的组件和稳定的接口是开发顺利的必要条件&lt;/li&gt;
&lt;li&gt;部属: 一键式的轻松部属应该是设计软件架构的目标.&lt;/li&gt;
&lt;li&gt;微服务架构虽然有利于开发, 但要考虑其部属和通信带来的隐患&lt;/li&gt;
&lt;li&gt;运行: 软件架构对运行的影响较小, 但架构应该将系统中的用例、功能和核心行为设为开发者可见的一级实体, 简化理解&lt;/li&gt;
&lt;li&gt;维护: 成本最高的部分&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主要成本&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;探秘: 对现系统的挖掘, 确定新增功能或被修复问题的最佳位置和方式&lt;/li&gt;
&lt;li&gt;风险: 进行修改时, 对可能衍生出新问题的风险成本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过架构设计(切分、隔离组件)降低以上成本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;策略: 保持可选项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件系统的主要元素&lt;/li&gt;
&lt;li&gt;策略: 业务规则与操作过程, 是系统的价值所在&lt;/li&gt;
&lt;li&gt;细节: 用户、程序员或第三方与策略进行交互的行为, 包括 I/O 设备、数据库、Web 系统、服务器、框架、交互协议等&lt;/li&gt;
&lt;li&gt;架构: 以策略为基本元素, 让细节与策略脱离关系, 并允许在具体决策过程中推迟或延迟与细节相关的内容&lt;/li&gt;
&lt;li&gt;方法: 做高层的策略决策时,尽可能摆脱并推迟对细节的决策(如数据库、框架和设备的选型等)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;好处&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对策略的信息越多, 对细节的决策越合理&lt;/li&gt;
&lt;li&gt;保持可选项, 可尝试不同的细节决策&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;示范: 设备无关性的应用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 16 章 独立性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;架构的支持目标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用例: 架构的首要目标是为所有系统用例提供支持&lt;/li&gt;
&lt;li&gt;运行: 架构需要支持系统的运行条件&lt;/li&gt;
&lt;li&gt;如为了支持系统的吞吐量和响应时间要求, 使用微服务或多进程、多线程架构&lt;/li&gt;
&lt;li&gt;开发: 将系统切分为隔离良好、可独立开发的组件&lt;/li&gt;
&lt;li&gt;部属: 设计目标是“一键部属”, 减少部属脚本与配置文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;挑战: 无法预知所有用例、运行条件、开发团队结构和部属需求; 并且这些需求会发生变化&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;策略: 保留可选项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用例: 解耦模式&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;水平分层解耦&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UI 界面&lt;/li&gt;
&lt;li&gt;应用独有的业务逻辑&lt;/li&gt;
&lt;li&gt;领域通用的业务逻辑&lt;/li&gt;
&lt;li&gt;数据库&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;垂直解耦: 按用例(如新增、删除)对系统进行垂直切分, 每个用例都可能涉及 UI 界面、业务逻辑和数据库&lt;/li&gt;
&lt;li&gt;运行: 按用例解耦后, 可以将高吞吐量和低吞吐量的组件、UI 和数据库等按需分开部属在不同的环境中&lt;/li&gt;
&lt;li&gt;开发: 解耦后可按水平分层或用例分别独立开发&lt;/li&gt;
&lt;li&gt;部属: 解耦后可独立部署、热更新等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重复的代码不一定是坏事&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用例之间的重复代码: 可能之后的变更速率和变更缘由会完全不同, 必须加倍小心地避免在用例之间复用代码&lt;/li&gt;
&lt;li&gt;水平分层的重复代码: 当数据库结构与 UI 界面的数据接口非常相似时(几乎一定是表面性的重复),也不要省略中间的视图模型,要保持水平分层之间的隔离&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解耦&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模式&lt;/li&gt;
&lt;li&gt;水平分层&lt;/li&gt;
&lt;li&gt;用例解耦&lt;/li&gt;
&lt;li&gt;解耦层次&lt;/li&gt;
&lt;li&gt;源码层次: 源代码模块之间通过函数调用来交互&lt;/li&gt;
&lt;li&gt;部属层次: 部属单元(jar 包、DLL、共享库)之间通过函数调用、跨进程通信、socket 或共享内存通信&lt;/li&gt;
&lt;li&gt;服务层次: 组件之间仅通过网络数据包通信&lt;/li&gt;
&lt;li&gt;解决方案&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单一层次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源码层次: 适合系统只运行在一台服务器上(单体结构), 但之后可能需要进行部属层次和服务层次的解耦&lt;/li&gt;
&lt;li&gt;服务层次: 资源成本、研发成本、人力成本高昂&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态层次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源码层次 -&gt; 部属层次 -&gt; 服务层次&lt;/li&gt;
&lt;li&gt;根据系统开发和部属需要进行变更&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;良好的架构&lt;/li&gt;
&lt;li&gt;允许从单体结构向可部属单元、独立的服务或微服务进行转变&lt;/li&gt;
&lt;li&gt;允许从部属和服务层次回退到单体结构&lt;/li&gt;
&lt;li&gt;在层次转变过程中保持系统的大部分源码不受影响&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 17 章 划分边界&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;划分边界的目的: 尽量将一些决策延后, 并确保这些决策不对核心业务逻辑产生干扰&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统最消耗人力资源的问题: 耦合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尤其是与系统业务需求无关的决策造成的耦合, 如过早决策系统框架、数据库、服务器等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;范例分析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;过早地做出决策去适应一个并不存在的大型服务器集群环境,导致开发成本急剧上升.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;过早地采用一整套域对象服务体系,需要将一整套服务全部运行起来才能进行开发,导致开发效率急剧下降&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;成功案例: 延后数据库相关决策,采用一种与数据库无关的设计,并预留空的数据访问方法,使得开发过程中不需要面对表结构问题、查询问题、数据库服务器问题、密码问题、链接时间等一系列数据库带来的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在何处划分?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GUI 与业务逻辑之间&lt;/li&gt;
&lt;li&gt;数据库与 GUI 之间&lt;/li&gt;
&lt;li&gt;数据库与业务逻辑之间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插件式架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心业务逻辑与其他组件隔离&lt;/li&gt;
&lt;li&gt;其他组件要么是可去掉的, 要么是有多种实现的&lt;/li&gt;
&lt;li&gt;GUI 与数据库都应可作为插件进行替换&lt;/li&gt;
&lt;li&gt;是单一职责原则(SRP)的具体实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 18 章 边界剖析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;跨边界调用: 边界一侧的函数调用另一侧的函数,并同时传递数据&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单体结构/源码层次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单体结构: 各组件合并产生一个单独的可执行文件&lt;/li&gt;
&lt;li&gt;一般利用某种动态形式的多态来管理内部依赖关系&lt;/li&gt;
&lt;li&gt;最简单的调用形式: 低层客户端调用高层服务函数&lt;/li&gt;
&lt;li&gt;当高层组件需要调用低层组件中的服务时,可以运行动态形式的多态来反转依赖关系&lt;/li&gt;
&lt;li&gt;高层组件提供接口&lt;/li&gt;
&lt;li&gt;低层组件实现接口并被高层组件调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;部属层次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跨边界调用方式与单体结构类似, 只是普通的函数调用.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程模型: 单体结构和按部属层次划分的组件都可以采用线程模型&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本地进程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不同进程拥有不同的地址空间, 无法共享内存&lt;/li&gt;
&lt;li&gt;进程间通信&lt;/li&gt;
&lt;li&gt;用某种独立的内存区域实现共享&lt;/li&gt;
&lt;li&gt;socket(最常见)&lt;/li&gt;
&lt;li&gt;一些操作系统提供的方式,如共享邮件、消息队列&lt;/li&gt;
&lt;li&gt;进程间的隔离策略与单体结构类似, 依赖关系始终指向更高层次组件&lt;/li&gt;
&lt;li&gt;高层进程源码中不应包含低层进程的名称、物理地址或注册表键名.&lt;/li&gt;
&lt;li&gt;设计目标: 低层进程作为高层进程的插件&lt;/li&gt;
&lt;li&gt;进程间通信成本相对较高,需要谨慎控制通信次数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统架构中最强的边界形式&lt;/li&gt;
&lt;li&gt;不依赖于具体的运行位置,始终假设服务之间的通信全部通过网络进行&lt;/li&gt;
&lt;li&gt;跨边界通信速度缓慢,尽可能控制通信次数并适应高延时情况&lt;/li&gt;
&lt;li&gt;目标: 低层服务成为高层服务的插件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 19 章 策略与层次&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;策略&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序 = 策略语句的集合&lt;/li&gt;
&lt;li&gt;策略语句&lt;/li&gt;
&lt;li&gt;描述计算部分的业务逻辑&lt;/li&gt;
&lt;li&gt;描述计算报告的格式&lt;/li&gt;
&lt;li&gt;描述输入数据的校验策略&lt;/li&gt;
&lt;li&gt;架构设计&lt;/li&gt;
&lt;li&gt;将策略语句彼此分离, 按变更方式(原因、时间、层次)重新分组(组件)&lt;/li&gt;
&lt;li&gt;将组件重新组合为一个有向无环图, 低层依赖于高层&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;层次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按输入与输出之间的距离来分层, 距离越远层次越高&lt;/li&gt;
&lt;li&gt;高层提供接口, 低层实现接口并依赖高层&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;涉及原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单一职责原则（SRP）、开闭原则（OCP）、共同闭包原则（CCP）、依赖反转原则（DIP）、稳定依赖原则（SDP）以及稳定抽象原则（SAP）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 20 章 业务逻辑&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;应用程序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;业务逻辑&lt;/li&gt;
&lt;li&gt;插件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;业务实体(Entity)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构成&lt;/li&gt;
&lt;li&gt;关键业务逻辑&lt;/li&gt;
&lt;li&gt;关键业务数据: 包含或容易访问&lt;/li&gt;
&lt;li&gt;接口&lt;/li&gt;
&lt;li&gt;实现关键业务逻辑的函数&lt;/li&gt;
&lt;li&gt;操作关键业务数据的属性或函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用例(Usecase)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义输入、输出及产生输出的过程&lt;/li&gt;
&lt;li&gt;描述某种特定应用场景下的业务逻辑&lt;/li&gt;
&lt;li&gt;用例属于低层概念, 依赖于业务实体&lt;/li&gt;
&lt;li&gt;只描述业务逻辑, 不描述交互方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求/响应模型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入输出都是简单的数据结构&lt;/li&gt;
&lt;li&gt;不派生任何 HTTP 接口和用户界面细节&lt;/li&gt;
&lt;li&gt;避免引用业务实体, 即使二者有很多相同的数据&lt;/li&gt;
&lt;li&gt;因为两个对象会以不同原因和速率发生变更&lt;/li&gt;
&lt;li&gt;会违反共同闭包原则(CCP)和单一职责原则(SRP)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 21 章 尖叫的软件架构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;架构设计的主题应该是业务, 而非架构/框架本身&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;推荐阅读《Object Oriented Software Engineering: A Use Case Driven Approach》&lt;/li&gt;
&lt;li&gt;系统的架构图基于用例, 而不是框架&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;良好的架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;围绕用例, 可以在脱离框架、工具和使用环境的情况下完整地描述用例.&lt;/li&gt;
&lt;li&gt;尽可能允许推迟和延后决定细节: 框架、数据库、Web 服务等. 并且容易改变&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Web 只是一种交付手段, 而非架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统应尽量保持它与交付方式之间的无关性&lt;/li&gt;
&lt;li&gt;应该可以将应用程序交付成命令行程序、Web 程序、富客户端程序、Web 服务程序等任何一种形式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;框架是工具而非信条&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;待着怀疑的态度审视每一个框架&lt;/li&gt;
&lt;li&gt;权衡使用框架、保护系统&lt;/li&gt;
&lt;li&gt;保持对系统用例的关注,避免让框架主导架构设计&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可测试的架构设计&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;架构设计应围绕用例展开, 应该可以在不依赖框架、Web 服务、数据库的情况下对用例进行单元测试&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 22 章 整洁架构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;几种架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;六边形架构/端口与适配器架构&lt;/li&gt;
&lt;li&gt;《Growing Object Oriented Software with Tests》&lt;/li&gt;
&lt;li&gt;DCI 架构&lt;/li&gt;
&lt;li&gt;BEC 架构&lt;/li&gt;
&lt;li&gt;《Object Oriented Software Engineering: A Use Case Driven Approach》&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;设计目标: 按照不同的关注点对软件进行切割&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;独立于框架: 框架作为工具而非依赖&lt;/li&gt;
&lt;li&gt;可被测试: 脱离框架、数据库、Web 服务测试&lt;/li&gt;
&lt;li&gt;独立于 UI: UI 变更很容易&lt;/li&gt;
&lt;li&gt;独立于数据库: 轻易替换数据库&lt;/li&gt;
&lt;li&gt;独立于外部机构: 不依赖任何外部接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;整洁架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分层: 中心为高层&lt;/li&gt;
&lt;li&gt;内层: 策略&lt;/li&gt;
&lt;li&gt;外层: 机制&lt;/li&gt;
&lt;li&gt;依赖关系: 由外指向内&lt;/li&gt;
&lt;li&gt;业务实体: 封装关键业务逻辑, 可以是带有方法的对象或一组数据结构和函数的集合&lt;/li&gt;
&lt;li&gt;用例: 特定应用场景下的业务逻辑, 封装了系统的所有用例, 引导业务实体的数据流&lt;/li&gt;
&lt;li&gt;接口适配器: 一组数据转换器, 负责在内部(用例和业务实体)和外部(数据库、Web)之间进行数据转换, 本层内部的同心圆不依赖任何数据库&lt;/li&gt;
&lt;li&gt;框架与驱动程序: 包含所有实现细节(Web 和数据库等), 实现不影响内层, 只有一些与内层沟通的黏合性代码&lt;/li&gt;
&lt;li&gt;跨越边界: 如图像右下角, 控制流从控制器开始, 穿过用例, 最后执行展示器代码&lt;/li&gt;
&lt;li&gt;当用例代码需要调用展示器时, 不能违反依赖关系直接调用, 可以使用依赖反转原则(DIP)来解决.&lt;/li&gt;
&lt;li&gt;跨越边界的数据: 数据结构应独立、简单, 避免直接传递业务实体或数据库记录对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 23 章 展示器和谦卑对象&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;谦卑对象模式: 按照是否难以测试将行为拆分成两组模块, 其中包含系统中所有难以测试的行为的一组模块称为谦卑(Humble)组.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;谦卑对象模式应用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;展示器与视图&lt;/li&gt;
&lt;li&gt;GUI 难以进行单元测试, 但可以利用谦卑对象模式将 GUI 拆分成展示器与视图两部分&lt;/li&gt;
&lt;li&gt;视图: 难以测试的谦卑对象, 代码越简单越好, 只负责将数据填充到 GUI 而不做任何处理&lt;/li&gt;
&lt;li&gt;展示器: 可测试的对象, 负责接收和处理数据, 以便视图将其呈现在屏幕上&lt;/li&gt;
&lt;li&gt;数据库网关&lt;/li&gt;
&lt;li&gt;用例交互器与数据库中间的组件, 是一个多态接口, 包含了应用程序在数据库上要执行的所有操作&lt;/li&gt;
&lt;li&gt;SQL 不应出现在用例层代码中, 需要由数据库网关接口提供, 其实现由数据库层来负责, 这些实现(SQL 或其他数据库提供的接口)属于谦卑对象&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据映射器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ORM(对象关系映射器)只是将数据从关系数据库加载到了对应的数据结构中, 属于数据库层, 是在数据库和数据库网关接口之间构建了一种谦卑对象的边界&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务监听器: 从服务接口中接收并处理数据, 使得数据可以跨服务边界传输. 也属于谦卑对象模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;谦卑对象模式将最难以测试的跨边界的数据交互行为分割出来, 可以大幅提高整个系统的可测试性.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 24 章 不完全边界&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;架构边界的挑战——
引入不完全边界的原因&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建完整的架构边界成本极高: 设计双向多态边界接口、输入输出数据结构、依赖关系管理、分割组件等&lt;/li&gt;
&lt;li&gt;为了应对将来可能的需要, 希望预留边界&lt;/li&gt;
&lt;li&gt;违背YAGNI原则(You aren’t going to need it, 不要预测未来的需要)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构建不完全边界&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;省掉最后一步: 将系统分割为可独立编译、部属的组件之后, 再将其合并起来构建成一个组件&lt;/li&gt;
&lt;li&gt;设计工作量和代码量与构建完整边界相同&lt;/li&gt;
&lt;li&gt;省去了多组件发布管理的工作&lt;/li&gt;
&lt;li&gt;危险性: 组件之间的独立性逐渐降低、隔离弱化&lt;/li&gt;
&lt;li&gt;单向边界: 在设计时就进行必要的依赖反转, 使得跨边界调用保持单向&lt;/li&gt;
&lt;li&gt;危险性: 只能依赖于开发者和架构师的自律性来保证组件的持久隔离&lt;/li&gt;
&lt;li&gt;门户模式: 边界由一个统一的类来定义, 这个类中包含了所有的服务函数列表, 负责将外层的调用传递给外层不可见的服务函数&lt;/li&gt;
&lt;li&gt;危险性: 外层组件传递性地依赖于所有服务函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 25 章 层次与边界&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;本章示例: 将一个简单的小程序逐步扩展为具有系统架构边界的复杂程序&lt;/li&gt;
&lt;li&gt;架构边界可以存在于任何地方, 需要小心审视何时需要设计架构边界&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;困难之处&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完全实现边界需要很高的成本, 且违反 YAGNI 原则, 容易过度设计&lt;/li&gt;
&lt;li&gt;如果事先忽略了某些边界, 后续再添加可能极为困难&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;架构师&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;权衡哪里需要设计架构边界&lt;/li&gt;
&lt;li&gt;权衡需要完整边界 or 不完整的边界&lt;/li&gt;
&lt;li&gt;持续观察系统演进、权衡架构边界成本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 26 章 Main 组件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;负责创建、协调、监督其他组件运转&lt;/li&gt;
&lt;li&gt;最底层、最细节的策略, 没有其他组件依赖于它&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置起始状态、配置信息、加载外部资源, 并将系统控制权交给最高抽象层的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可以以插件形式为系统设计多个 Main 组件对应于不同的配置&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 27 章 服务: 宏观与微观&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;面向服务的架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务只是一种跨进程/平台边界的函数调用, 不一定蕴含架构的意义&lt;/li&gt;
&lt;li&gt;架构是由跨越架构边界的关键函数调用来定义的, 并且必须遵守依赖关系规则&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务的好处谬论&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解耦合&lt;/li&gt;
&lt;li&gt;任何形式的共享数据行为都会导致强耦合&lt;/li&gt;
&lt;li&gt;服务的接口与函数接口类似, 并没有更好&lt;/li&gt;
&lt;li&gt;独立开发部属&lt;/li&gt;
&lt;li&gt;并非服务仅有的特性, 采用单体或组件模式同样可以独立开发和部属&lt;/li&gt;
&lt;li&gt;强耦合的服务并不能真正做到独立开发部属维护&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务与架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统的架构边界在服务内部的组件而不在服务上&lt;/li&gt;
&lt;li&gt;在服务内部应采用遵守依赖关系原则的组件设计方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 28 章 测试边界&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;测试也是一种系统组件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遵守依赖关系原则: 处于最外层, 向内依赖&lt;/li&gt;
&lt;li&gt;测试组件可以独立部署(测试环境)&lt;/li&gt;
&lt;li&gt;支持开发过程, 而非运行过程(往往不会部属到生产环境)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可测试性设计&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脆弱的测试问题&lt;/li&gt;
&lt;li&gt;测试代码与系统强耦合, 系统组件的小变化都需要测试组件做出相应变更&lt;/li&gt;
&lt;li&gt;GUI 是多变的, 通过 GUI 来验证系统的测试一定是脆弱的, 应该让业务逻辑不通过 GUI 也能被测试&lt;/li&gt;
&lt;li&gt;测试专用 API&lt;/li&gt;
&lt;li&gt;拥有超级用户权限, 允许测试代码忽视安全限制、绕过成本高昂的资源(数据库), 强制将系统设置到可测试状态中&lt;/li&gt;
&lt;li&gt;将测试代码从应用程序中分离&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免结构性耦合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果每个产品函数都有一个对应的测试函数, 那么测试套件与应用程序在结构上是紧耦合的, 导致脆弱的测试问题. 测试专用 API 使测试代码与应用程序解耦.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安全性: 具有超级权限的测试专用 API 应该放置在单独的、可独立部属的组件中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 29 章 整洁的嵌入式结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;软件与固件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件本身不会随时间而磨损, 周期很长&lt;/li&gt;
&lt;li&gt;但硬件和固件会随着硬件演进而过时, 进而可能导致软件无法使用.&lt;/li&gt;
&lt;li&gt;固件代码&lt;/li&gt;
&lt;li&gt;对特定硬件平台 API 依赖的代码都属于固件代码, 如未分离业务与系统 API 调用的 Android 开发&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分离固件代码: 延长软件代码的生命周期&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;”程序适用测试“&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果代码只有在特定硬件平台上才能被测试, 那么即使通过了“适用性测试”, 仍不能说其拥有整洁的嵌入式架构. 除非这个产品永远不需要迁移到其他硬件平台&lt;/li&gt;
&lt;li&gt;目标硬件瓶颈: 嵌入式开发面临的特有的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;整洁的嵌入式架构就是可测试的嵌入式架构&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目标硬件瓶颈解决方案&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分层&lt;/li&gt;
&lt;li&gt;硬件、固件、[操作系统]、软件&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;边界&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码与硬件: 边界比较清晰&lt;/li&gt;
&lt;li&gt;软件(操作系统)与固件&lt;/li&gt;
&lt;li&gt;硬件抽象层(HAL): 为软件提供服务, 隐藏硬件实现细节&lt;/li&gt;
&lt;li&gt;软件与操作系统&lt;/li&gt;
&lt;li&gt;操作系统抽象层(OSAL): 隐藏操作系统实现细节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;面向接口编程与可替代性&lt;/li&gt;
&lt;li&gt;模块之间定义接口进行通信&lt;/li&gt;
&lt;li&gt;每一个借口都为平台之外的测试提供替换点&lt;/li&gt;
&lt;li&gt;DRY 条件性编译命令&lt;/li&gt;
&lt;li&gt;问题: 如果程序中多次使用了重复的条件性编译命令来为不同平台启用/禁用一段代码&lt;/li&gt;
&lt;li&gt;方案: 使用硬件抽象层(HAL)隐藏硬件类型, 然后使用链接器或某种运行时加载器进行软硬件组合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第六部分 实现细节&lt;/h2&gt;
&lt;h3&gt;第 30 章 数据库只是实现细节&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据库不是数据模型, 而只是存储数据的工具&lt;/li&gt;
&lt;li&gt;依赖数据库表结构的代码应该被局限在系统架构的最外层的工具函数中&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库溯源: 优化磁盘存储&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件系统: 便于存储和检索文档, 但对文档内容难以关注&lt;/li&gt;
&lt;li&gt;数据库系统: 关注文档/记录的内容/属性&lt;/li&gt;
&lt;li&gt;存储的未来&lt;/li&gt;
&lt;li&gt;基于 RAM, 将数据组织成最合适的数据结构&lt;/li&gt;
&lt;li&gt;基于文件和表格(数据库)的形式被逐渐取代&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统架构不应关心数据在磁盘上如何存储这种实现细节&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;性能考量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能是系统架构的一个考量标准&lt;/li&gt;
&lt;li&gt;数据存储方面的性能是底层问题, 不需要与系统架构相关联&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 31 章 Web 是实现细节&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Web 的振荡式发展&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;将计算资源集中在服务器集群中, 浏览器保持简单&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Web2.0 用 Ajax 和 JavaScript 将很多计算挪到浏览器中执行&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;用 Nodejs 技术将 JavaScript 代码挪回到服务器中执行&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GUI 只是实现细节, 而 Web 是 GUI 中的一种&lt;/li&gt;
&lt;li&gt;作为软件架构师, 需要将其与核心业务逻辑进行隔离&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将 Web 应用抽象为设备无关架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;业务逻辑 -&gt; 一组用例&lt;/li&gt;
&lt;li&gt;用例 -&gt; 输入、处理、输出数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 32 章 应用程序框架是实现细节&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;框架的目的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决框架作者所侧重的一些问题, 而不是解决你的问题——只是这些问题有较大的重合性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单向约定&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发者需要遵守框架的一系列约定&lt;/li&gt;
&lt;li&gt;框架作者不需要遵守什么约定&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;风险&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;框架自身的架构设计可能不正确&lt;/li&gt;
&lt;li&gt;产品的演进可能超出框架提供的能力范围&lt;/li&gt;
&lt;li&gt;框架本身可能朝着我们不需要的方向演进, 被迫进行不必要的升级或悄悄改变了行为&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决方案&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将框架作为实现细节, 不要将其引入内圈&lt;/li&gt;
&lt;li&gt;不要基于框架的基类创建派生类, 可以创造一些代理类作为业务逻辑的插件&lt;/li&gt;
&lt;li&gt;根据依赖关系原则, 将框架作为核心代码的插件&lt;/li&gt;
&lt;li&gt;可以在最外层的 Main 组件中引入、依赖框架&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于不得不接受的框架依赖, 需要慎重决定&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 33 章 案例分析: 视频销售网站&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;识别系统中的各种角色和用例&lt;/li&gt;
&lt;li&gt;角色: 单一职责原则(SRP)&lt;/li&gt;
&lt;li&gt;角色作为系统变更的主要驱动力, 一个角色的变更需求不影响其他角色&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;构造组件架构图&lt;/li&gt;
&lt;li&gt;构建系统架构边界&lt;/li&gt;
&lt;li&gt;分割组件&lt;/li&gt;
&lt;li&gt;每个组件对应一个潜在的独立部署文件, 包含视图、展示器、交互器、控制器文件&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;独立部属&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个组件独立交付部属是否过于繁琐?&lt;/li&gt;
&lt;li&gt;将组件组合为多个交付单元来部属, 如交付为视图、展示器、交互器、控制器和工具类 5 个.jar 文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;依赖关系管理&lt;/li&gt;
&lt;li&gt;控制流: 从控制器输入数据, 经由交互器处理, 再由展示器格式化出结果, 最后由视图展示结果&lt;/li&gt;
&lt;li&gt;依赖关系: 与控制流方向相反, 由低层指向高层&lt;/li&gt;
&lt;li&gt;使用关系: 与控制流一致&lt;/li&gt;
&lt;li&gt;“继承”关系: 与控制流相反&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总结: 架构实现了两个维度上的隔离&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据单一职责原则隔离各个角色&lt;/li&gt;
&lt;li&gt;应用依赖关系原则&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 34 章 拾遗&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;代码结构设计&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;水平分层&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;层次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web 代码&lt;/li&gt;
&lt;li&gt;业务逻辑&lt;/li&gt;
&lt;li&gt;持久化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在项目初期合适, 不会过于复杂; 一旦软件规模扩展, 就需要进一步进行模块化&lt;/li&gt;
&lt;li&gt;问题: 无法展现具体的业务领域信息&lt;/li&gt;
&lt;li&gt;垂直切分&lt;/li&gt;
&lt;li&gt;按功能、业务概念或聚合根(DDD 术语)切分, 每一类放在一个包中, 以业务概念命名&lt;/li&gt;
&lt;li&gt;水平分层与垂直切分都很不好&lt;/li&gt;
&lt;li&gt;隔离业务领域与实现细节(数据库、框架等)&lt;/li&gt;
&lt;li&gt;端口和适配器模式&lt;/li&gt;
&lt;li&gt;六边形架构&lt;/li&gt;
&lt;li&gt;边界、控制器、实体&lt;/li&gt;
&lt;li&gt;按组件封装&lt;/li&gt;
&lt;li&gt;将一个粗粒度组件相关的所有类放入一个包, 类似于微服务架构, 将 UI 与粗粒度组件分离&lt;/li&gt;
&lt;li&gt;新的组件定义: 在一个执行环境（应用程序）中的、一个干净、良好的接口背后的一系列相关功能的集合&lt;/li&gt;
&lt;li&gt;优点: 一类业务的变更只需要修改一个粗粒度组件&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C4 软件架构模型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统由一个或多个容器组成(Web 应用、移动 App、数据库、独立应用、文件系统等)&lt;/li&gt;
&lt;li&gt;容器包含一个或多个组件&lt;/li&gt;
&lt;li&gt;组件包含一个或多个类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将代码分散到不同的代码树&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如端口与适配器架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例 1&lt;/li&gt;
&lt;li&gt;业务代码树: 所有技术和框架无关的代码&lt;/li&gt;
&lt;li&gt;Web 源代码树&lt;/li&gt;
&lt;li&gt;持久化源代码树&lt;/li&gt;
&lt;li&gt;例 2&lt;/li&gt;
&lt;li&gt;业务(Domain)代码(内部)&lt;/li&gt;
&lt;li&gt;基础设施(Infrastructure)代码(外部)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;中心思想: 要将架构设计映射到具体的代码结构上&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;思维导图&lt;/h2&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/3457995e0cfaad5f5403c78a3c1797c5/044d8/CleanArchitecture.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 877.2151898734178%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAACvCAYAAAD9hP67AAAACXBIWXMAABYlAAAWJQFJUiTwAAAL7ElEQVRo3p2byW9jWRXG8w/yHyDECtESEmpALVoNEmoJFggQYtMNGxatlrolFmzYsCmpKKqTqlSqkso820lsJ07iOGNVbOeg30194fj63jfE0tPz+L0zfGe45z5PmXvc3d09PL+5ubGjoyN7/vy5PXnyxJaWlh6+oyP1mIrBbm9v7fj4OJwHg4HNzc3Z/Py8ra2t2bt37yYunAT0V0Syq6urcFxcXIT3m81mkHB3d9dGo5HFvymU8P379+E8HA4D6OXlpS0sLNjLly/t9evXY1JmAf2H/EBS6AKrq6u2vr5um5ubpWpP+Q8BSv0AKbvdru3v71ur1QqS50ALATmw4+npqR0cHATHYM/r6+v6gHi51+s9eLvT6QQJ9d3aKgPEa9Q7Pz8PkuJlr25tCXnNAZXgZqPRsHa7XShlFhA15XXAdnZ2JhxWC5AzakIVSL21tTXmjFo25MyPUXVjY8MWFxcDYErCGHgq/kK/37fDw8Nw5oFD8O7y8nIgdxEHk4AAyCkKvbOzM9vb2wvSQh8+qyQhqgLIa9TjOaDXNzfBw2/fvg325AKVAPGsl5D3sSWgawtv7MWzp7Y8N2vX5/3HAfIgyfbPzqzTbln74MBOjrtmd6NqtPGAqIxj8DRx/PTpU/tuejo8L8rcWUBFCPaC1NiPoygxFALqPQDIMnAR2nCRyrHsAWVHUhdJAROQxX0JqCUhmRoQeEeUYE/Pv9IilXIK6sI/SgAxXcS/SrThNRlaYadwfJSEGB8JiWuqHsBlDkkCIoUyNXFMGUBtYlk5srKEeJHIIKHiXexIpkFC1MZBtSQEEDDvFC4Aod+8eRO8neqDsoDqa7wNkerFixc2Ozsb6klZwzQVtyEeEClPTk5CpJC2sGUtYntAnlNTcBLdwsrKSuCi93QtQG8GAMkySIvnK2ebGBDqAEQsA4aD4GURfbKASl/YDcqoOMW0qSwhgKirPpEIApxCFbcklQF5zSEK4RiaTryec04hINLde/o8SAh1VlZWC5vOQkBAhoNbs7uh9Xpntr6+asvLi2OOqyzhcDiy66tLa+4f29pWx96/u7T5xS3b3Dl8HG0Gw2Eol9uNI5ue24SRtrDStNXNzgcN0v3NBCB8+//iB1uNwvGfmXW7vb2x3EIpmxxIAKQugCEw+bDdbtnzl+t22uvZ+Xk/2NaTOyshgOQ/0QTHYAK4d3jYCrFMKeCieL8UEDoQt3pPVY5Ht3scihXgMQezgHxRgHBQgEiDpMo6hCIxXSphChCpSQq0I1qnkHEwR4o6WUCFHsCAUpOxn3rE1JqP81TcxyjNCxBvcsaz9DcAppa6Ok8AqrJ5CcVRdbG5Gj0hISlJxhagUhcqK8nCTZ6TfGXTJCAf8AMBUk/UZ6tQAaBSgPSYxBeuCUCWsV4V3gMYqaAOJtne3n6QKg7DMUDxTe8pJ95TiP5wEGyHhFwkps2EhAAqOQgQLl5fX9loROa+ZwFSxhImAbEXiWEMcDCwy4sL6/VO7fLqItjMr1R5jQZJlQHEVjGVyDBH/a71L/vWbDRtt7H70NVqLZ0ElPHj1VUfwONuoBTqojbtncidVRnAVNuLlGe9s1A+kYzwjPNhUkLAfNvrvYedkAw+Qps422QB43UKTiKxEnZ87h1R6mV+oEys9+Edh1IZ4CRaLiCnaAWblNDHJZJoDoYdcRgJljQGINLzfS5YCkhi0GupyHtIxXtabog+WS+rCVLQK/CRgs8pYnibJAKwilnWhlptqvPiNUCEJNwjHzJPpFiRSOIWeQwQG8WDIGUhqAL/dAFqTDytm5AQI2t+KAnVTaAmEpJUkcwnh2yRQkIBqpYAhnR4FvthO6SK2+Ksl1WL+YGWFeRIeRzpUoOgbHLwgH58iu0ARsp4bpNVGcbry77QQyVUxbMQ2mekwv6QsBMgQPwQMJGYuhxno0JARYUiBTA+A/jVq1fBMbmephTQdwwAshqF1IAWzbInCr0AUV02xBF4G3VrjVnwpPIcYFIbQIo8EkLsXOdVCqiRAaCEHaBk7CI7ToX0Hq44CchnSIkNSVN4OZ59ZfcC7h+DJCDSQRsSQlwiJiTsHF3Zf2da9t1sx+bmW2OAPCchkFUAo0gplrMqr2/17Ot/rNq3/9ywf/17wwaDcQmRiORA6qeW4OnS9XJKZeih1oStD3Z+SKylMweWWIMhqZ7QG48UVOOMM9T564K1I0U2hDYkV+/dyoA+23hAwo3pUm5uUyl9CZCEiqcBxcMKvdwCMpu+FClECcTG0+RDUhlSY9tSCQH02UaLR5IqjgEQMJWEFH0mnKK07wu7MrWSa2WVtUMh2mhcxYXUganU5ga8E2s93zlokKFRFapiS8DxeKnKHhApBKj1nXKh73kKVY4BeR+qMPyRDT1AqZcBiwE5QxVUlcPiKKlsQ79RiJQQXJWwUuh5wND5n50FABxA+kLSoiJfakN1rPCQXIiEtXYeU15GIp+ta6WvlA0htVapGpo/ClCbM1rNw0PUTk2UsgufmDbaXm+126Emtz7kw1QsJwHVunEGTJFysL9nSwvz1u20x5ZqpbGM3QAiqWrFHt67OLfBZd+ueyfW3Nm2xaWlQPTU/GtCQl0VW2nDkCXt5taWNZp71mg0g7cxjSd4FlC04DkHXsbD62trtry0FOjjy0BhcvCA8rI8jRlIW5A73rSuJKFqiwZBFCkOTU0qTTg9oCIFSSnwdF+EoPamKk3aYwl5jnTaBUJtldpcwZ8Y6sbtnEamHGGuHcVyIbFVi/0WEslBy7K70V29SNGQR14OlOl2A/+2dratc9h5qHpcyBM7uw3nOwceX3/zjX38y1/YJ7/5zH77+9/ZF19+EeoLCRdHxcu0iV0z1Q2d//K3v9pPvv89++lHP7Cff/qp/flPfwzl4NmzZ+Hs91kK73MQ4N+/+sp+9OMf2s8++dh+9evP7A+ffx5imX4RKVFbmQmBCgFHd6MQFUura7a2sWE7O9vWbrXs+OQkvI/X6R3ZpqN2E1WlEvK62WhY60PnoO1NfU8zxqSX45tPfBcGhagtbBiSvZWIK98r4m+G0qYh5J6ZmQmlIF5aJL2cAsTomhFCF27bmp6ertYs5VTmYDVKF0bjicq5nbNCp2iYRtdF0w6QRqqVQi8lIVSQZICidtGGYaENteDWIhy7oTpScqTuKihUWRFAHiRuVQIUJfEQvVRlzRCRDO8CCIhm2UhZWWVlb8jMAMOnfs24U01nqQ0BQTJIjR0VkinHVFIZUqd2bCuVgFhlDuzFOhknxLvftWOZcMOr2kuBMn7EUlpGU8TWBpdmX2VtcRZQo1E5BrpgSxyUmsZXIraGkjgG3iEhqhPbuXtvKqlM54AdOfwGTi1A3xJr1EL4xY6pzEONWUQfSE1i5eB5bRsqG0MdraY0rtKuRS0J/WBc42dyIcUdkkOf2qEnKQDEhiRYPKzdidLlbSqW1bSTbTQVye1+V6YNeU/jKoBT6+bS5KCBrqodHMQhmm7mJiOFd+pq51F21O2/mm/7SVSphL7vRsqLsPvYC3kRtXEO0tYC9Kpo3xQ70t9wruVl34Rqs1pnSI50qbVzKSBpjBhGVZziB261vayl2f2G63mQDC76DevKkaKVFD/EszgB+mhHPGfr0kjhPeii+4n9hK723c7qHFBXs2xAczu3lQo90qEqQCJ00ei50IZQRmQmdQFK4/6oqudvjdG9sCQIPP1oCXkOsCoeIVd2p+nE7dO+FdFOLWqzsKGli++STObD1GTEq0w+1ECt8k3yHlC00QoJQG2D4ByRvpDYfv6FWiKwkgP0wdsceDq3BTKVWh5oeKHRlWZiAAOopim78El1o7qNXzUYtfU/FdT2+wJJwNjQurruPyQ5aOfROyyrcuqvOVq6AqgtdSTTKiubsYsApT5gqO3Xxo8C5DV2pP2gc0Dl0n8u5ADlcTmETK12ruKu2SSgJAQU6SB30Z82soB+O5h4xsP6v1Rqw3+sSOUA/YYr0YPaiufcPDsLqCm7tjoAJ/w0vtcdLsmBZC5a5GkiRrfJoD7JlrLg+ZgFjNXW30k4lHRJDiJ4JRt6Y2sh7sMtFa4C/B8OhyBNRMOINgAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Clean Architecture 思维导图&quot;
        title=&quot;Clean Architecture 思维导图&quot;
        src=&quot;/static/3457995e0cfaad5f5403c78a3c1797c5/f058b/CleanArchitecture.png&quot;
        srcset=&quot;/static/3457995e0cfaad5f5403c78a3c1797c5/c26ae/CleanArchitecture.png 158w,
/static/3457995e0cfaad5f5403c78a3c1797c5/6bdcf/CleanArchitecture.png 315w,
/static/3457995e0cfaad5f5403c78a3c1797c5/f058b/CleanArchitecture.png 630w,
/static/3457995e0cfaad5f5403c78a3c1797c5/40601/CleanArchitecture.png 945w,
/static/3457995e0cfaad5f5403c78a3c1797c5/78612/CleanArchitecture.png 1260w,
/static/3457995e0cfaad5f5403c78a3c1797c5/044d8/CleanArchitecture.png 3366w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[GTD之二：实践要点]]></title><description><![CDATA[经过两个月的 GTD 实践，发现 GTD 其实并不是想象中那么高深和繁琐，只要能做到两个关键点，就可以使整个流程顺利执行下来。 关键点一：收集一切 GTD 的核心目的是解放大脑、提升效率，一旦决定使用 GTD…]]></description><link>https://hrayd.github.io/gtd-2/</link><guid isPermaLink="false">https://hrayd.github.io/gtd-2/</guid><pubDate>Thu, 20 May 2021 22:00:00 GMT</pubDate><content:encoded>&lt;p&gt;经过两个月的 GTD 实践，发现 GTD 其实并不是想象中那么高深和繁琐，只要能做到两个关键点，就可以使整个流程顺利执行下来。&lt;/p&gt;
&lt;h2&gt;关键点一：收集一切&lt;/h2&gt;
&lt;p&gt;GTD 的核心目的是解放大脑、提升效率，一旦决定使用 GTD 系统，就应该完全信赖它，将自己的一切想法第一时间纳入系统：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个新的工作任务&lt;/li&gt;
&lt;li&gt;一个新的学习计划&lt;/li&gt;
&lt;li&gt;一个待办事项&lt;/li&gt;
&lt;li&gt;一篇待阅读文章&lt;/li&gt;
&lt;li&gt;一个刚刚看到的待深入了解的新词汇&lt;/li&gt;
&lt;li&gt;一个学习或生活小窍门&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;就是两个字：一切。将一切想法和事务先放入收集篮并释放大脑，集中精力于当前事务。&lt;/p&gt;
&lt;h2&gt;关键点二：每周回顾&lt;/h2&gt;
&lt;p&gt;这是整个 GTD 系统中唯一需要花费一整段时间的步骤，需要做的有三点（详情参照《GTD 之一：GTD 的理论笔记》）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;清空 &lt;strong&gt;收集篮&lt;/strong&gt;：将收集篮中的事务逐个理清，纳入系统；&lt;/li&gt;
&lt;li&gt;回顾未完成的 &lt;strong&gt;日程表&lt;/strong&gt; 和 &lt;strong&gt;下一步行动清单&lt;/strong&gt;，重新纳入系统；&lt;/li&gt;
&lt;li&gt;回顾 &lt;strong&gt;将来/也许清单&lt;/strong&gt;，决定是否将其纳入系统并开始执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于我个人来说，每周的收集篮大约新增 10 条左右，逐条进行分解和规划，一般在一个小时左右处理完毕，处理完毕后基本上也就将下周任务规划好了。&lt;/p&gt;
&lt;h2&gt;关于工具&lt;/h2&gt;
&lt;p&gt;我个人认为选择工具（此处特指 APP）有以下要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;覆盖个人的全平台；&lt;/li&gt;
&lt;li&gt;APP 数量尽可能少，尽可能集中在三个 APP 以内：如一个清单类、一个导图类、一个笔记类；&lt;/li&gt;
&lt;li&gt;支持标签系统，根据所处场景可以快速找到当前可执行任务&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;标签系统示例&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;地点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;办公室&lt;/li&gt;
&lt;li&gt;家中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时长：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;10 分钟&lt;/li&gt;
&lt;li&gt;30 分钟&lt;/li&gt;
&lt;li&gt;1 小时&lt;/li&gt;
&lt;li&gt;3 小时&lt;/li&gt;
&lt;li&gt;1 天&lt;/li&gt;
&lt;li&gt;3 天&lt;/li&gt;
&lt;li&gt;1 周&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动作类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阅读&lt;/li&gt;
&lt;li&gt;代码&lt;/li&gt;
&lt;li&gt;思考&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[GTD之一：GTD的理论笔记]]></title><description><![CDATA[引言 网络上关于 GTD 系统的文章琳琅满目，但大多都经过了作者的主观简化或加工，本人在最初学习 GTD 时参考了大量的知乎问答和博客专栏，但总是不得要领，没多久 GTD 就变成了单纯的 Todo…]]></description><link>https://hrayd.github.io/gtd-1/</link><guid isPermaLink="false">https://hrayd.github.io/gtd-1/</guid><pubDate>Tue, 09 Mar 2021 22:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;引言&lt;/h2&gt;
&lt;p&gt;网络上关于 GTD 系统的文章琳琅满目，但大多都经过了作者的主观简化或加工，本人在最初学习 GTD 时参考了大量的知乎问答和博客专栏，但总是不得要领，没多久 GTD 就变成了单纯的 Todo 清单，接着就是未完成事项越攒越多，被催促的焦虑感越来越强，最终系统“爆炸”、崩溃。&lt;/p&gt;
&lt;p&gt;在若干次失败之后，决定从头开始把 GTD 作为一门科学的方法论认真学习一遍。“GTD”系统源于一本书籍——《Getting Things Done》，中文书名《搞定》，本文系本书的读书笔记。&lt;/p&gt;
&lt;h2&gt;读书笔记&lt;/h2&gt;
&lt;p&gt;阅读本书用时约 6 小时，本书分为三个部分，Part1 部分的前三章为全书理论核心，基本囊括了 GTD 系统的所有知识；Part2 部分从第 4 章至第 10 章，是将 GTD 每个阶段的具体做法详细讲述了一遍；Part3 部分对 GTD 进行了总结和评价。&lt;/p&gt;
&lt;h3&gt;8 个容器&lt;/h3&gt;
&lt;p&gt;所谓容器，就是事务清单，可以是记录在随身笔记本上的纸质清单，可以是简单便携的手机备忘录，也可以是专业的 GTD 软件产品。&lt;/p&gt;
&lt;p&gt;GTD 系统总的来说是一套周期性流水线式的事务管理方法论，其中涉及 8 个清单，一般的专业 GTD 工具也就是能将以下容器有机结合起来的软件，个人推荐新手使用纸质清单+手机日历的方式来熟悉和执行 GTD。&lt;/p&gt;
&lt;p&gt;8 个容器列举如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;收集篮：未经处理过的原始“材料”，定期清空&lt;/li&gt;
&lt;li&gt;项目清单：决定执行、且需要多步执行的事务清单&lt;/li&gt;
&lt;li&gt;项目计划本：对项目清单中每个项目的行动方案规划&lt;/li&gt;
&lt;li&gt;也许/将来清单：以后可能执行的事务清单&lt;/li&gt;
&lt;li&gt;日程表：记录指定日期或时间需要执行或提醒执行的事务&lt;/li&gt;
&lt;li&gt;下一步行动清单：可执行的待办事项清单&lt;/li&gt;
&lt;li&gt;等待清单：需要等待他人完成才能继续执行的待办事项清单&lt;/li&gt;
&lt;li&gt;参考资料库：个人资料库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在实际的执行中，这 8 个清单也可以进行简化处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;收集篮需要随身携带随手记录，可以用随身小本或手机备忘录作为载体；&lt;/li&gt;
&lt;li&gt;项目清单、项目计划本、也许/将来清单、等待清单都是在每周回顾中对事务进行分析和规划，可以使用一个笔记本或电子版的思维导图或树状清单来实现；&lt;/li&gt;
&lt;li&gt;日程表可以直接使用手机自带日历或全平台的日历 APP(如 outlook)；&lt;/li&gt;
&lt;li&gt;下一步行动清单即传统的待办事项，任何一个有提醒功能的待办事项 APP 都可以；&lt;/li&gt;
&lt;li&gt;参考资料库其实是 GTD 系统之外的个人知识库，可以使用任何带标签和搜索功能的笔记 APP 来实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;事务的横向管理&lt;/h3&gt;
&lt;p&gt;事务的横向管理即对多个事务的并行管理，是 GTD 系统的核心。其流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;收集：收集一切未竟之事加入【收集篮】，清空大脑&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;理清：抽出两个小时以上的时间块，对【收集篮】的事务挨个执行以下述流程进行清空：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;想清楚事情具体是什么，一个目标？一项工作？一次活动？一些资料？&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;事情需要采取行动吗？是转 3，否转 9；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;需要多步行动才能完成吗？若是，加入【项目清单】转 4，否转 5；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;将事务划分为有序或无序的多步行动计划，加入【项目计划本】，转 5；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;明确下一步行动，写入【下一步行动清单】，转 6；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;下一步行动是否可以在两分钟内完成？若是，立即执行，然后继续下一步行动，若否转 7；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;下一步行动是否需要等待他人完成？若是，加入【等待列表】，并在【日程表】中设定下一次跟进时间，若否转 8；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;下一步行动是否在指定日期或时间完成？若是，加入【日程表】；若否，加入【也许/将来清单】；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;是否希望在将来采取行动？若是，加入【也许/将来清单】，若否转 10；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;是否是有意义的参考资料？若是，加入【参考资料库】；若否，扔进垃圾箱。&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每周回顾：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;执行整个理清流程，清空收集篮，更新各清单容器&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;回顾未完成的【日程表】和【下一步行动清单】，重新纳入系统&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;回顾【也许/将来清单】，决定是否开始执行&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;依据场景（办公室、家中）、时间约束、个人状态、重要性等来选择执行&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;可以通过事先给项目、行动打标签的形式来筛选&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;优先执行当日【日程表】、【下一步行动清单】与其他突发紧急事件&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;事务的纵向管理&lt;/h3&gt;
&lt;p&gt;所谓纵向管理，即对单个事务流程的管理，由于每个人的事务所处的领域、规模、专业程度等因素天差地别，很难总结出一套通用的方法，而 GTD 对于事务纵向管理的描述我个人认为过于泛泛而谈，意义有限。但还是将书中内容记录如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务纵向管理的目标：将事务纳入 GTD 系统，清空大脑。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;哪些事务需要计划？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;80%简单的事务：直接列出行动清单，概括预期结果与各阶段行动步骤；&lt;/li&gt;
&lt;li&gt;15%复杂的事务：运用参考资料或辅助工具规划事务；&lt;/li&gt;
&lt;li&gt;5%需要认真权衡的事务：实施如下 &lt;strong&gt;自然计划法&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;自然计划法&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;定义目标与限定条件&lt;/li&gt;
&lt;li&gt;展望成功场景或结果&lt;/li&gt;
&lt;li&gt;头脑风暴/集思广益&lt;/li&gt;
&lt;li&gt;组织整理，将事务划分为有序或无序的若干步骤&lt;/li&gt;
&lt;li&gt;明确 &lt;strong&gt;下一步行动&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;GTD 的执行方案建议&lt;/h2&gt;
&lt;p&gt;首先需要牢记 GTD 的目标：&lt;strong&gt;将一切事务纳入 GTD 系统，清空大脑&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为了达到这一点，一个可随取随用的 &lt;strong&gt;收集篮&lt;/strong&gt; 至关重要，可以选择随身手帐、手机备忘录或其他 APP，我的建议是选择一个全平台的清单应用，当然这个“全平台”是相对个人来说的，我自己日常平台 Mac+iPhone+iPad，收集篮就用 iOS 自带备忘录来做（后来改成了 Things3）。&lt;/p&gt;
&lt;p&gt;另一个重要容器是 &lt;strong&gt;下一步行动清单&lt;/strong&gt; ，理论上任何 Todo 类应用都符合要求，但我建议选择全平台（同收集篮）、支持标签、支持设定开始和截止时间、支持三层以上嵌套的树形清单，如果能支持同步到日历就更好了，可以把 &lt;strong&gt;日程表&lt;/strong&gt; 也合并到一起了。我之前使用 iOS 自带待办事项，但功能上还是过于简陋，就选择了很久以前买的 Things3 来用，一些优秀的待办事项 APP 如 Microsoft ToDo、滴答清单、Any.do、Sorted 等都可以满足要求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;也许/将来清单&lt;/strong&gt;和&lt;strong&gt;等待清单&lt;/strong&gt;也可以合并到待办事项 APP 中，与下一步行动清单的区别是，它们处于等待执行的状态，在每周回顾中进行重新思考，决定执行时再将其转移到项目清单或下一步行动清单中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;项目清单&lt;/strong&gt;、&lt;strong&gt;项目计划本&lt;/strong&gt; 我是使用思维导图来做的，它们的主要任务是在每周回顾中对项目进行规划和分解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料库&lt;/strong&gt; 使用任何笔记类软件都可以，我个人是印象笔记长期用户，也可以选择 OneNote、语雀、Notion 等，我的建议是：至少要支持标签系统、全局搜索和本地数据库。&lt;/p&gt;
&lt;p&gt;当然，在对 GTD 系统熟悉和进阶到一定程度后，也可以选择更为专业的 Omnifocus 神器，我在 Mac 端试用过一段时间，相当满意，但全平台的价格劝退了我。。等以后觉得这套 GTD 系统值得了再做考虑吧。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[HTML5技术扫盲]]></title><description><![CDATA[元素 语义元素 HTML 语义化标签              音视频元素   表单优化：内置数据校验 校验属性： :   : 正则校验   校验效果 通过：CSS 伪类  ，提交数据 不通过：CSS 伪类  ，显示错误信息并阻止提交 iframe…]]></description><link>https://hrayd.github.io/html5/</link><guid isPermaLink="false">https://hrayd.github.io/html5/</guid><pubDate>Mon, 11 May 2020 22:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;元素&lt;/h2&gt;
&lt;h3&gt;语义元素&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HTML 语义化标签&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;article&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;aside&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;details&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;figcaption&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;figure&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;footer&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;header&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;main&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;mark&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;nav&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;section&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;summary&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;time&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;音视频元素&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;表单优化：内置数据校验&lt;/h3&gt;
&lt;p&gt;校验属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt;: &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input type=&amp;quot;email&amp;quot;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;required&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;pattern&lt;/code&gt;: 正则校验&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;min / max&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;minlength / maxlength&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;校验效果&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过：CSS 伪类 &lt;code class=&quot;language-text&quot;&gt;:valid&lt;/code&gt; ，提交数据&lt;/li&gt;
&lt;li&gt;不通过：CSS 伪类 &lt;code class=&quot;language-text&quot;&gt;:invalid&lt;/code&gt; ，显示错误信息并阻止提交&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;iframe 增强安全性和渲染&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;sandbox&lt;/code&gt; 对 frame 中的内容添加额外限制，如 &lt;code class=&quot;language-text&quot;&gt;allow-downloads&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;allow-same-origin&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;allow-scripts&lt;/code&gt; 等&lt;/li&gt;
&lt;li&gt;seamless: 无缝嵌入 iframe&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;srcdoc&lt;/code&gt; 直接嵌入内联 HTML 文本，如:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; iframe &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;iframe&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
iframe&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;srcdoc &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&amp;lt;!DOCTYPE html&gt;&amp;lt;p&gt;Hello World!&amp;lt;/p&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;
document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;body&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;iframe&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;MathML&lt;/h3&gt;
&lt;p&gt;参考 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Authoring&quot;&gt;MDN-MathML&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;支持使用 MathML 书写数学公式：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;html&quot;&gt;&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;math&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;msqrt&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;mn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;2&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;mn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;msqrt&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;math&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;通信&lt;/h2&gt;
&lt;h3&gt;WebSockets&lt;/h3&gt;
&lt;p&gt;客户端和服务器建立持久的 TCP 连接，用得比较多了不再赘述。&lt;/p&gt;
&lt;h3&gt;Server-Sent Events(SSE)&lt;/h3&gt;
&lt;p&gt;允许服务器向客户端推送事件，可用于数据仪表盘、实时股票价格展示等场景。&lt;/p&gt;
&lt;h3&gt;WebRTC&lt;/h3&gt;
&lt;p&gt;浏览器之间建立点对点通信，可用于实时音视频和数据共享等场景。&lt;/p&gt;
&lt;h2&gt;离线与存储&lt;/h2&gt;
&lt;h3&gt;在线/离线事件&lt;/h3&gt;
&lt;p&gt;读取属性值: &lt;code class=&quot;language-text&quot;&gt;navigator.online: boolean&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;ononline&lt;/code&gt; / &lt;code class=&quot;language-text&quot;&gt;onoffline&lt;/code&gt; 事件注册：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件注册：在 window, document 或 document.body 上 &lt;code class=&quot;language-text&quot;&gt;addEventListener(&amp;quot;ononline&amp;quot;, fn);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;事件函数: &lt;code class=&quot;language-text&quot;&gt;document.[body.]ononline = function(){...}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;内联事件: &lt;code class=&quot;language-text&quot;&gt;&amp;lt;body ononline=&amp;quot;fn1()&amp;quot; onoffline=&amp;quot;fn2()&amp;quot;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;DOM Storage&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;LocalStorage：同域跨浏览器窗口和选项卡共享&lt;/li&gt;
&lt;li&gt;SessionStorage：仅本次会话可用&lt;/li&gt;
&lt;li&gt;GlobalStorage(仅 Firefox)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;IndexedDB&lt;/h3&gt;
&lt;p&gt;用于在浏览器端存储大量结构化数据的事务型数据库系统。&lt;/p&gt;
&lt;p&gt;可以和 &lt;strong&gt;Web Workers&lt;/strong&gt; 结合使用以提高性能。&lt;/p&gt;
&lt;p&gt;可用于构建 &lt;strong&gt;PWA&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;File API&lt;/h3&gt;
&lt;p&gt;文件上传：&lt;code class=&quot;language-text&quot;&gt;&amp;lt;input type=&amp;quot;file&amp;quot; multiple onchange=&amp;quot;handleFiles(this.files)&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ObjectURL:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;window.URL.createObjectURL(file)&lt;/code&gt; 创建 ObjectURL 使得文件可以通过 URL 来引用(如 a、img 元素等)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;window.URL.revokeObjectURL(objURL)&lt;/code&gt; ObjectURL 使用完毕后应释放&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;多媒体&lt;/h2&gt;
&lt;p&gt;上文已提到过的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; 与 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;WebRTC&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Camera API&lt;/h3&gt;
&lt;p&gt;调用系统自带相机: &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input type=&amp;quot;file&amp;quot; id=&amp;quot;take-picture&amp;quot; accept=&amp;quot;image/*&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;Track 和 WebVTT&lt;/h3&gt;
&lt;p&gt;用于时序文本或其他基于时间的数据, 如视频字幕等.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;track&amp;gt;&lt;/code&gt;元素作为 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;video&amp;gt;&lt;/code&gt; 元素的子元素,用于指定时序文本字幕.&lt;/p&gt;
&lt;p&gt;WebVTT 表示 Web 视频文本字幕格式(.vtt).&lt;/p&gt;
&lt;h2&gt;图像与效果&lt;/h2&gt;
&lt;h3&gt;Canvas Text API&lt;/h3&gt;
&lt;p&gt;新增 &lt;code class=&quot;language-text&quot;&gt;fillText()&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;strokeText()&lt;/code&gt; 方法&lt;/p&gt;
&lt;h3&gt;WebGL 3D&lt;/h3&gt;
&lt;p&gt;用于特定领域, 这里不做详述.&lt;/p&gt;
&lt;h3&gt;SVG&lt;/h3&gt;
&lt;p&gt;基于 XML 语法的矢量图, 可用于绘制简单的 LOGO 或流程图绘制等场景.&lt;/p&gt;
&lt;h2&gt;性能与集成&lt;/h2&gt;
&lt;h3&gt;Web Workers&lt;/h3&gt;
&lt;p&gt;创建后台线程执行一个 JS 文件, 一般用于执行大量耗时的计算任务.&lt;/p&gt;
&lt;h3&gt;XMLHttpRequest Level 2&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;支持 &lt;code class=&quot;language-text&quot;&gt;timeout&lt;/code&gt; 超时设定&lt;/li&gt;
&lt;li&gt;支持使用 FormData 对象管理表单数据&lt;/li&gt;
&lt;li&gt;支持文件上传&lt;/li&gt;
&lt;li&gt;支持跨域请求&lt;/li&gt;
&lt;li&gt;支持获取二进制数据&lt;/li&gt;
&lt;li&gt;支持数据传输进度信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;History API&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;window.history&lt;/code&gt; 对象提供了一些有用的方法来操作浏览器访问历史:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;history.back()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;history.forward()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;history.go()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ContentEditable&lt;/h3&gt;
&lt;p&gt;可编辑元素, 可用于实现富文本编辑器, 详情查看另一篇文章 &amp;#x3C;在线编辑器实现浅析&gt;.&lt;/p&gt;
&lt;h3&gt;拖拽 API&lt;/h3&gt;
&lt;p&gt;用于实现拖拽元素, 主要包括 &lt;code class=&quot;language-text&quot;&gt;ondrop&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;ondrag&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;ondragstart&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;ondragend&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;ondragenter&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;ondragleave&lt;/code&gt; 等事件及相关属性方法.&lt;/p&gt;
&lt;h3&gt;焦点管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;document.activeElement&lt;/code&gt; 查找当前聚焦的 Element&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;document.hasFocus&lt;/code&gt; 判断当前元素是否是焦点&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;基于 Web 的协议处理程序&lt;/h3&gt;
&lt;p&gt;实现在 Web 中可以使用非 HTTP 协议将网页链接到其他资源, 如发邮件等.&lt;/p&gt;
&lt;p&gt;属于特定领域功能, 用到时再研究.&lt;/p&gt;
&lt;h3&gt;动画渲染控制&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;window.requestAnimationFrame(callback)&lt;/code&gt; 执行动画, 并在下一次浏览器重绘前调用 callback.&lt;/p&gt;
&lt;p&gt;一般 callback 会更新动画, 用于在不同的渲染时机中触发不同的动画.&lt;/p&gt;
&lt;h3&gt;全屏 API&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;element.requestFullscreen()&lt;/code&gt;
&lt;code class=&quot;language-text&quot;&gt;document.exitFullscreen()&lt;/code&gt;
&lt;code class=&quot;language-text&quot;&gt;document.onfullscreenchange&lt;/code&gt;
&lt;code class=&quot;language-text&quot;&gt;document.onfullscreenerror&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;鼠标锁定 API&lt;/h3&gt;
&lt;p&gt;使鼠标指针不离开指定区域, 如游戏场景中, 鼠标指针移到最左侧后, 鼠标不会移出游戏窗口, 而是保持在边缘移动画面.&lt;/p&gt;
&lt;p&gt;兼容性问题: 只有 Chrome 和 Firefox 实现了有限功能.&lt;/p&gt;
&lt;h2&gt;设备访问&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Camera API 见上文&lt;/li&gt;
&lt;li&gt;鼠标锁定 API 见上文&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;触摸事件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;TouchEvent 界面触摸状态发生变化时的事件回调&lt;/li&gt;
&lt;li&gt;Touch 单个触摸对象&lt;/li&gt;
&lt;li&gt;TouchList 一组触摸对象, 如多点触摸时&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;地理位置 API&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;navigator.geolocation&lt;/code&gt; 对象提供了一套地理相关 API:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Geolocation.getCurrentPosition()&lt;/code&gt; 获取设备当前位置&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Geolocation.watchPosition()&lt;/code&gt; 设备位置改变时的触发事件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;设备方向&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;deviceorientation&lt;/code&gt; 设备方向改变时的触发事件&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;devicemotion&lt;/code&gt; 设备移动时的触发事件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;CSS&lt;/h2&gt;
&lt;h3&gt;Background&lt;/h3&gt;
&lt;p&gt;已经用得很普遍了.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;box-shadow&lt;/code&gt; 阴影&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;background&lt;/code&gt; 属性支持多背景&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Border&lt;/h3&gt;
&lt;p&gt;同样早就用过&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;border-image&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;border-radius&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;CSS Animations&lt;/h3&gt;
&lt;p&gt;CSS 动画的灵活性和可玩性都极大, 后面会专门抽时间研究一下.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations&quot;&gt;MDN - CSS Animations&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;排版相关&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;文字溢出处理: &lt;code class=&quot;language-text&quot;&gt;text-overflow&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连字符(长单词)处理: &lt;code class=&quot;language-text&quot;&gt;hyphens&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hyphens 属性值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;hyphens: none; 单词不断行
hyphens: manual; 有连字符时换行
hyphens: auto; 浏览器自动处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;文字阴影: &lt;code class=&quot;language-text&quot;&gt;text-shadow&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;文字装饰(下划线/中划线): &lt;code class=&quot;language-text&quot;&gt;text-decoration&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指定在线字体: &lt;code class=&quot;language-text&quot;&gt;@font-face&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;多列布局&lt;/h3&gt;
&lt;p&gt;参考: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Multiple-column_Layout&quot;&gt;MDN-多列布局&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;column-count: n;&lt;/code&gt; 设置后浏览器自动将当前元素分为 n 列&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;column-width: 200px;&lt;/code&gt; 最小列宽&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;columns: n 200px;&lt;/code&gt; 合并列数与列宽设置&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;column-gap: 20px;&lt;/code&gt; 列间隙, 默认 1em&lt;/p&gt;</content:encoded></item><item><title><![CDATA[TypeScript Type Guards]]></title><description><![CDATA[场景: 当一个变量拥有复合类型, 在某些情况下我们需要对其进行类型断言. 比如: 学生体检时, 除了若干公共体检项目外, 男生还需要检查 A 项目, 女生需要检查 B 项目, 男女生体检结果汇总在一个表中. 在实际操作中, 我们需要根据体检人的 sex(性别)字段来确定展示 A…]]></description><link>https://hrayd.github.io/typescript-type-guards/</link><guid isPermaLink="false">https://hrayd.github.io/typescript-type-guards/</guid><pubDate>Sun, 09 Feb 2020 22:00:00 GMT</pubDate><content:encoded>&lt;p&gt;场景: 当一个变量拥有复合类型, 在某些情况下我们需要对其进行类型断言.&lt;/p&gt;
&lt;p&gt;比如: 学生体检时, 除了若干公共体检项目外, 男生还需要检查 A 项目, 女生需要检查 B 项目, 男女生体检结果汇总在一个表中. 在实际操作中, 我们需要根据体检人的 sex(性别)字段来确定展示 A 项目还是 B 项目的体检结果. 代码如下:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;tsx&quot;&gt;&lt;pre class=&quot;language-tsx&quot;&gt;&lt;code class=&quot;language-tsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Boy&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;
  sex&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; SexEnum
  itemA&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Girl&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;
  sex&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; SexEnum
  itemB&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Boy &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; Girl

&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; s&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Student &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getOne&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sex &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; SexEnum&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Boy&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token builtin&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;itemA&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// error!&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在代码中, 编译器无法确定 &lt;code class=&quot;language-text&quot;&gt;s&lt;/code&gt; 为 &lt;code class=&quot;language-text&quot;&gt;Boy&lt;/code&gt; 类型, 似乎只能通过丑陋的 &lt;code class=&quot;language-text&quot;&gt;as unknow as Boy&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;@ts-ignore&lt;/code&gt; 来绕过错误.&lt;/p&gt;
&lt;h2&gt;Build-in Type Guards&lt;/h2&gt;
&lt;p&gt;JS 中内置的 Type Guards 有 &lt;code class=&quot;language-text&quot;&gt;typeof&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;instanceof&lt;/code&gt; , 但都无法解决问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;typeof&lt;/code&gt; 只能判断基本类型&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;instanceof&lt;/code&gt; 只能应用在 class 中, 函数式编程中极少使用 class, 所以作用有限&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;解决方案: Custom Type Guards&lt;/h2&gt;
&lt;p&gt;示例代码:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;tsx&quot;&gt;&lt;pre class=&quot;language-tsx&quot;&gt;&lt;code class=&quot;language-tsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; isBoy &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;student&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Student&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; student &lt;span class=&quot;token keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;Boy&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; student&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sex &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; SexEnum&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Boy

&lt;span class=&quot;token comment&quot;&gt;// 另一种写法&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; isBoy &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;student&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Student&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; student &lt;span class=&quot;token keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;Boy&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;student &lt;span class=&quot;token keyword&quot;&gt;as&lt;/span&gt; Boy&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;itemA &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; undefine

&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; s&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Student &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getOne&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isBoy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token builtin&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;itemA&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// no error&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关键点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回值应声明为 &lt;code class=&quot;language-text&quot;&gt;variable is Type&lt;/code&gt; 的形式, 如  &lt;code class=&quot;language-text&quot;&gt;student is Boy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;函数体返回一个可以进行类型断言的 bool 值, 如  &lt;code class=&quot;language-text&quot;&gt;student.sex === SexEnum.Boy&lt;/code&gt; .&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;A generic(范型) type guard&lt;/h2&gt;
&lt;p&gt;如果需要编写许多 Type Guards, 使用 custom 的方式将会十分繁复, 不够 DRY.&lt;/p&gt;
&lt;p&gt;Generic Type Guard:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; isOfType &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;(
  varToBeChecked: any,
  propertyToCheckFor: keyof T
): varToBeChecked is T =&gt;
  (varToBeChecked as T)[propertyToCheckFor] !== undefined;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Use case:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;isOfType &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; Car &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;item&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;turnSteeringWheel&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 此处item被成功断言为Car&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Dude, where&apos;s my car?!&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;问题: 只通过一个属性来断言类型, 有时不够安全. 需要根据实际情况进行修改, 如传入属性列表或其他配置项.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[CAGED Guitar System]]></title><description><![CDATA[CAGED 概述 CAGED 代表五种基本和弦手型，即 C-A-G-E-D 和弦. 通过转换把位移调, 任意和弦都可以用这五种手型弹奏. 例: 五种手型弹 C 和弦: 第一把位的 C 手型 五弦三品作为根音的 A 手型 六弦八品作为根音的 G 手型和 E 手型(G 和 E…]]></description><link>https://hrayd.github.io/caged/</link><guid isPermaLink="false">https://hrayd.github.io/caged/</guid><pubDate>Tue, 17 Sep 2019 22:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;CAGED 概述&lt;/h2&gt;
&lt;p&gt;CAGED 代表五种基本和弦手型，即 C-A-G-E-D 和弦.&lt;/p&gt;
&lt;p&gt;通过转换把位移调, 任意和弦都可以用这五种手型弹奏.&lt;/p&gt;
&lt;p&gt;例: 五种手型弹 C 和弦:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一把位的 C 手型&lt;/li&gt;
&lt;li&gt;五弦三品作为根音的 A 手型&lt;/li&gt;
&lt;li&gt;六弦八品作为根音的 G 手型和 E 手型(G 和 E 根音都在六弦)&lt;/li&gt;
&lt;li&gt;四弦十品作为根音的 D 手型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;由根音推和弦&lt;/h2&gt;
&lt;p&gt;由根音可以快速找到一组相同和弦：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C 指型与 A 指型根音相同时为同一和弦&lt;/li&gt;
&lt;li&gt;E 指型与 G 指型根音相同时为同一和弦&lt;/li&gt;
&lt;li&gt;以 E 指型的四弦为根音，可找到 D 指型的同一和弦&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;知识点：十二品为一个八度&lt;/p&gt;
&lt;p&gt;知识点：由调弦方法可推出相邻弦的音高关系，如五弦零品=六弦五品&lt;/p&gt;
&lt;p&gt;应用：由根音快速找到所有的 C 和弦&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;最基本 C 指型，根音为五弦三品&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;根音不动，变为 A 指型&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;五弦零品=六弦五品 =&gt; 五弦三品=六弦八品，以六弦八品为根音的 G 指型与 E 指型&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;十二品为一个八度，以五弦十五品为根音的 C 指型与 A 指型&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同理推出其他大调和弦&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;搞清楚每个基本和弦对应的小调和弦、挂留和弦与七和弦等基本变化, 就可以推出整个指板的所有封闭和弦!&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;由根音推音阶&lt;/h2&gt;
&lt;p&gt;理论都很简单, 但需要集中练习.&lt;/p&gt;
&lt;h3&gt;相对音阶&lt;/h3&gt;
&lt;p&gt;给定一个位置的音, 可以迅速推出周围乃至整个指板的音.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;研究同音/八度位置:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;六弦和四弦, 五弦和三弦差两品&lt;/li&gt;
&lt;li&gt;四弦和二弦, 三弦和一弦差三品&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过八度位置推导并记熟常用的五度和三度位置&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;绝对音阶&lt;/h3&gt;
&lt;p&gt;绝对音阶一般只需要记住特定的几个, 然后与相对音阶位置相结合, 就可以迅速得到指定音阶.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先熟记第一把位的所有音阶, 一般基本和弦练熟了都没问题.&lt;/li&gt;
&lt;li&gt;顺势推出并熟记十二品附近音阶, 与第一把位相同.&lt;/li&gt;
&lt;li&gt;通过八度相对音阶的位置, 就近在第一把位或十二品把位找到对应的同音音阶&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;熟悉之后可以在中间选择一些常用位置进行记忆, 如五品或九品.&lt;/p&gt;
&lt;p&gt;推出音阶之后, 与前一节的 &lt;strong&gt;由根音推和弦&lt;/strong&gt; 相结合, 基本就摸透整个指板了.&lt;/p&gt;
&lt;h2&gt;高把位按弦技巧&lt;/h2&gt;
&lt;p&gt;根音位置不变，这意味着：记住指法与和弦的对应关系，也就记住了指板上对应的根音。&lt;/p&gt;
&lt;p&gt;C 指型在大横按时较为困难，可以只按 2、3、4、5 弦。&lt;/p&gt;
&lt;p&gt;G 指型可以只用小指和食指按 2、3、4、6 弦或 1、2、3、4 弦。&lt;/p&gt;
&lt;p&gt;D 指型一般不用来弹所有和弦，可以只弹 1、2、3 弦的高音，一般为扫弦。&lt;/p&gt;</content:encoded></item></channel></rss>