<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[按太阳穴轮刮眼眶]]></title><description><![CDATA[佚树的个人博客]]></description><link>https://hrayd.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Mon, 23 Aug 2021 01:02:44 GMT</lastBuildDate><item><title><![CDATA[React核心原理浅析]]></title><description><![CDATA[1. JSX 与虚拟 DOM 我们从 React 官方文档开头最基本的一段 Hello World 代码入手: 很明显, 这段代码的意思是通过  方法将  包裹的 JSX 元素渲染到 id 为“root”的 HTML 元素上. 除了在 JS…]]></description><link>https://hrayd.github.io/react/</link><guid isPermaLink="false">https://hrayd.github.io/react/</guid><pubDate>Sun, 18 Jul 2021 22:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;1. JSX 与虚拟 DOM&lt;/h1&gt;
&lt;p&gt;我们从 React 官方文档开头最基本的一段 Hello World 代码入手:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;ReactDOM&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;Hello, world!&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;h1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;root&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很明显, 这段代码的意思是通过 &lt;code class=&quot;language-text&quot;&gt;ReactDOM.render()&lt;/code&gt; 方法将 &lt;code class=&quot;language-text&quot;&gt;h1&lt;/code&gt; 包裹的 JSX 元素渲染到 id 为“root”的 HTML 元素上. 除了在 JS 中早已熟知的 &lt;code class=&quot;language-text&quot;&gt;document.getElementById()&lt;/code&gt; 方法外, 这段代码中还包含两个知识点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以 &lt;code class=&quot;language-text&quot;&gt;h1&lt;/code&gt; 标签包裹的 JSX 元素&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;ReactDOM.render()&lt;/code&gt; 方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而这两个知识点则对应着 React 中要解决的核心问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为何以及如何使用(JSX 表示的)虚拟 DOM?&lt;/li&gt;
&lt;li&gt;如何对虚拟 DOM 进行处理, 使其高效地渲染出来?&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1.1 虚拟 DOM 是什么? 为何要使用虚拟 DOM?&lt;/h3&gt;
&lt;p&gt;虚拟 DOM 其实就是用 JavaScript 对象表示的一个 DOM 节点, 内部包含了节点的 &lt;code class=&quot;language-text&quot;&gt;tag&lt;/code&gt; , &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;children&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;为何使用虚拟 DOM? 因为直接操作真实 DOM 繁琐且低效, 通过虚拟 DOM, 将一部分昂贵的浏览器重绘工作转移到相对廉价的存储和计算资源上.&lt;/p&gt;
&lt;h3&gt;1.2 如何将 JSX 转换成虚拟 DOM?&lt;/h3&gt;
&lt;p&gt;通过 babel 可以将 JSX 编译为特定的 JavaScript 对象, 示例代码如下:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// JSX&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; e &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;root&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;className&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;title&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;Title&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;h1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// babel编译结果(React17之前), 注意子元素的嵌套结构&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; e &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; React&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token string&quot;&gt;&quot;div&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; id&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;root&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  React&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;h1&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; className&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;title&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Title&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// React17之后编译结果有所区别, 创建节点的方法由react导出, 但基本原理大同小异&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.3 如何将虚拟 DOM 渲染出来?&lt;/h3&gt;
&lt;p&gt;很明显, 虚拟 DOM 中包含了创建 DOM 所需的各种信息, 对于首次渲染, 直接依照这些信息创建 DOM 节点即可.&lt;/p&gt;
&lt;p&gt;但虚拟 DOM 的真正价值在于“更新”: 当一个 list 中的某些项发生了变化, 或删除或增加了若干项, 如何通过对比前后的虚拟 DOM 树, 最小化地更新真实 DOM? 这就是 React 的核心目标.&lt;/p&gt;
&lt;h1&gt;2. React Diffing&lt;/h1&gt;
&lt;p&gt;“Diffing”即“找不同”, 就是解决上文引出的 React 的核心目标——如何通过对比新旧虚拟 DOM 树, 以在最小的操作次数下将旧 DOM 树转换为新 DOM 树.&lt;/p&gt;
&lt;p&gt;在算法领域中, 两棵树的转换目前最优的算法复杂度为 &lt;code class=&quot;language-text&quot;&gt;O(n**3)&lt;/code&gt; , n 为节点个数. 这意味着当树上有 1000 个元素时, 需要 10 亿次比较, 显然远远不够高效.&lt;/p&gt;
&lt;p&gt;React 在基于以下两个假设的基础上, 提出了一套复杂度为 &lt;code class=&quot;language-text&quot;&gt;O(n)&lt;/code&gt; 的启发式算法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不同类型(即标签名、组件名)的元素会产生不同的树;&lt;/li&gt;
&lt;li&gt;通过设置 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt; 属性来标识一组同级子元素在渲染前后是否保持不变.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在实践中, 以上两个假设在绝大多数场景下都成立.&lt;/p&gt;
&lt;h2&gt;2.1 Diffling 算法描述&lt;/h2&gt;
&lt;h3&gt;不同类型的元素/组件&lt;/h3&gt;
&lt;p&gt;当元素的标签或组件名发生变化, 直接卸载并替换以此元素作为根节点的整个子树.&lt;/p&gt;
&lt;h3&gt;同一类型的元素&lt;/h3&gt;
&lt;p&gt;当元素的标签相同时, React 保留此 DOM 节点, 仅对比和更新有改变的属性, 如 className、title 等, 然后递归对比其子节点.&lt;/p&gt;
&lt;p&gt;对于 &lt;code class=&quot;language-text&quot;&gt;style&lt;/code&gt; 属性, React 会继续深入对比, 仅更新有改变的属性, 如 color、fontSize 等.&lt;/p&gt;
&lt;h3&gt;同一类型的组件&lt;/h3&gt;
&lt;p&gt;当组件的 props 更新时, 组件实例保持不变, React 调用组件的 &lt;code class=&quot;language-text&quot;&gt;componentWillReceiveProps()&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;componentWillUpdate()&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;componentDidUpdate()&lt;/code&gt; 生命周期方法, 并执行 &lt;code class=&quot;language-text&quot;&gt;render()&lt;/code&gt; 方法.&lt;/p&gt;
&lt;p&gt;Diffing 算法会递归比对新旧 &lt;code class=&quot;language-text&quot;&gt;render()&lt;/code&gt; 执行的结果.&lt;/p&gt;
&lt;h3&gt;对子节点的递归&lt;/h3&gt;
&lt;p&gt;当一组同级子节点(列表)的末尾添加了新的子节点时, 上述 Diffing 算法的开销较小; 但当新元素被插入到列表开头时, Diffing 算法只能按顺序依次比对并重建从新元素开始的后续所有子节点, 造成极大的开销浪费.&lt;/p&gt;
&lt;p&gt;解决方案是为一组列表项添加 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt; 属性, 这样 React 就可以方便地比对出插入或删除项了.&lt;/p&gt;
&lt;p&gt;关于 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt; 属性, 应稳定、可预测且在列表内唯一(无需全局唯一), 如果数据有 ID 的话直接使用此 ID 作为 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt;, 或者利用数据中的一部分字段哈希出一个 key 值.&lt;/p&gt;
&lt;p&gt;避免使用数组索引值作为 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt;, 因为当插入或删除元素后, 之后的元素和索引值的对应关系都会发生错乱, 导致错误的比对结果.&lt;/p&gt;
&lt;p&gt;避免使用不稳定的 key(如随机数), 因为每次渲染都会发生改变, 从而导致列表项被不必要地重建.&lt;/p&gt;
&lt;h2&gt;2.2 递归的 Diffing&lt;/h2&gt;
&lt;p&gt;在 1.2 节中的虚拟 DOM 对象中可以得知: 虚拟 DOM 树的每个节点通过 &lt;code class=&quot;language-text&quot;&gt;children&lt;/code&gt; 属性构成了一个嵌套的树结构, 这意味着要以递归的形式遍历和比较新旧虚拟 DOM 树.&lt;/p&gt;
&lt;p&gt;2.1 节的策略解决了 Diffing 算法的时间复杂度的问题, 但我们还面临着另外一个重大的性能问题——浏览器的渲染线程和 JS 的执行线程是互斥的, 这意味着 DOM 节点过多时, 虚拟 DOM 树的构建和处理会长时间占用主线程, 使得一些需要高优先级处理的操作如用户输入、平滑动画等被阻塞, 严重影响使用体验.&lt;/p&gt;
&lt;h3&gt;时间切片(Time Slice)&lt;/h3&gt;
&lt;p&gt;为了解决浏览器主线程的阻塞问题, 引出 &lt;strong&gt;时间切片&lt;/strong&gt; 的策略——将整个工作流程分解成小的工作单元, 并在浏览器空闲时交由浏览器执行这些工作单元, 每个执行单元执行完毕后, 浏览器都可以选择中断渲染并处理其他需要更高优先级处理的工作.&lt;/p&gt;
&lt;p&gt;浏览器中提供了 &lt;code class=&quot;language-text&quot;&gt;requestIdleCallback&lt;/code&gt; 方法实现此功能, 将待调用的函数加入执行队列, 浏览器将在不影响关键事件处理的情况下逐个调用.&lt;/p&gt;
&lt;p&gt;考虑到浏览器的兼容性以及 &lt;code class=&quot;language-text&quot;&gt;requestIdleCallback&lt;/code&gt; 方法的不稳定性, React 自己实现了专用于 React 的类似 &lt;code class=&quot;language-text&quot;&gt;requestIdleCallback&lt;/code&gt; 且功能更完备的 &lt;code class=&quot;language-text&quot;&gt;Scheduler&lt;/code&gt; 来实现空闲时触发回调, 并提供了多种优先级供任务设置.&lt;/p&gt;
&lt;h3&gt;递归与时间切片&lt;/h3&gt;
&lt;p&gt;时间切片策略要求我们将虚拟 DOM 的更新操作分解为小的工作单元, 同时具备以下特性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可暂停、可恢复的更新;&lt;/li&gt;
&lt;li&gt;可跳过的重复性、覆盖性更新;&lt;/li&gt;
&lt;li&gt;具备优先级的更新.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于递归形式的程序来说, 这些是难以实现的. 于是就需要一个处于递归形式的虚拟 DOM 树上层的数据结构, 来辅助完成这些特性.&lt;/p&gt;
&lt;p&gt;这就是 React16 引入的重构后的算法核心——Fiber.&lt;/p&gt;
&lt;h1&gt;3. Fiber&lt;/h1&gt;
&lt;p&gt;从概念上来说, Fiber 就是重构后的虚拟 DOM 节点, 一个 Fiber 就是一个 JS 对象.&lt;/p&gt;
&lt;p&gt;Fiber 节点之间构成 &lt;strong&gt;单向链表&lt;/strong&gt; 结构, 以实现前文提到的几个特性: 更新可暂停/恢复、可跳过、可设优先级.&lt;/p&gt;
&lt;h2&gt;3.1 Fiber 节点&lt;/h2&gt;
&lt;p&gt;一个 Fiber 节点就是一个 JS 对象, 其中的关键属性可分类列举如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结构信息(构成链表的指针属性)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;return: 父节点&lt;/li&gt;
&lt;li&gt;child: 第一个子节点&lt;/li&gt;
&lt;li&gt;sibling: 右侧第一个兄弟节点&lt;/li&gt;
&lt;li&gt;alternate: 本节点在相邻更新时的状态, 用于比较节点前后的变化, 3.3 节详述&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组件信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tag: 组件创建类型, 如 FunctionComponent、ClassComponent、HostComponent 等&lt;/li&gt;
&lt;li&gt;key: 即 key 属性&lt;/li&gt;
&lt;li&gt;type: 组件类型, Function/Class 组件的 type 就是对应的 Function/Class 本身, Host 组件的 type 就是对应元素的 TagName&lt;/li&gt;
&lt;li&gt;stateNode: 对应的真实 DOM 节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本次更新的 props 和 state 相关信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pendingProps、memoizedProps&lt;/li&gt;
&lt;li&gt;memoizedState&lt;/li&gt;
&lt;li&gt;dependencies&lt;/li&gt;
&lt;li&gt;updateQueue&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新标记&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;effectTag: 节点更新类型, 如替换、更新、删除等&lt;/li&gt;
&lt;li&gt;nextEffect、firstEffect、lastEffect&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优先级相关: lanes、childrenLanes&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.2 Fiber 树&lt;/h2&gt;
&lt;p&gt;前文说到, Fiber 节点通过 &lt;code class=&quot;language-text&quot;&gt;return&lt;/code&gt; , &lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;slibling&lt;/code&gt; 属性构成了单向链表结构, 为了与 DOM 树对应, 习惯上仍称其为“树”.&lt;/p&gt;
&lt;p&gt;如一棵 DOM 树:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;html&quot;&gt;&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;Title&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;h1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;section&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;h2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;Section&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;h2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;p&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;Content&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;p&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;section&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;footer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;Footer&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;footer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其 &lt;code class=&quot;language-text&quot;&gt;section&lt;/code&gt; 节点的 Fiber 可表示为:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; sectionFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  key&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;SECTION_KEY&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  child&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; h2Fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  sibling&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; footerFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; divFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  alternate&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; oldSectionFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;otherFiberProps&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整体的 Fiber 结构:&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 351px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/b3457a432995dc057094ab9e3bb38373/7c2a6/DOM.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 79.74683544303798%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAABwklEQVQ4y5WU12oDUQxE9/9/y2D8YGxccO+9994mHAWZzWYdiECsb5E0M9J1MBgMhLdaLS0WC81mMz0eD2Gv10v/teB0Omk4HKpUKtnG4XDQ7Xb7mJA93/ffYQ9Go5FWq5V2u52KxaL2+33sxTiPRdjv95XNZo1uKpXS5XL5ge6vYO7CkC8OmKDT6Qi/Xq+aTqdar9dG+fl8mruxdzweLRCNz+ezMZvP5+r1eppMJmq32wo2m43wSqVigclkUrlczpJ3u11lMhnl83lbFwoFIRE6w4g9ktVqNWtqtVr9TujVQMAaFNAECcFU986HDYrENhoNi6WIacgG0BOJhB1EOxztfFTX5XL5XgdAhgqJoO1NCdt2u9X9fv84e+HJMIQMM5Q5ADaI6B5UOUO38Xhs80rTKO4yMWro5+gDDukwARgJaEI6nbbLJCmXy4aexDSARADhHmuPtYQkYKhxqvN1AyX6eFebzaY1jUDO0B0pkORN2bvpHhWdoQcNCEEc9yQp8n4pcSJ7QjoLXZCgL5TD44OO7MPC2QR/vVNoQol/I28WmjJmFEICCqAhxev1+m+E4TeMNuEBJjko6D6vCOSuNUaxL8UZzYzW8I5pAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;./DOM.png&quot;
        title=&quot;./DOM.png&quot;
        src=&quot;/static/b3457a432995dc057094ab9e3bb38373/7c2a6/DOM.png&quot;
        srcset=&quot;/static/b3457a432995dc057094ab9e3bb38373/c26ae/DOM.png 158w,
/static/b3457a432995dc057094ab9e3bb38373/6bdcf/DOM.png 315w,
/static/b3457a432995dc057094ab9e3bb38373/7c2a6/DOM.png 351w&quot;
        sizes=&quot;(max-width: 351px) 100vw, 351px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3.3 Fiber 架构&lt;/h2&gt;
&lt;p&gt;基于 Fiber 构成的虚拟 DOM 树就是 Fiber 架构.&lt;/p&gt;
&lt;p&gt;在 3.1 节中我们介绍过, 在 Fiber 节点中有一个重要属性 &lt;code class=&quot;language-text&quot;&gt;alternate&lt;/code&gt; , 单词意为“备用”.&lt;/p&gt;
&lt;p&gt;实际上, 在 React 中最多会同时存在两棵 Fiber 树:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前显示在屏幕上、已经构建完成的 Fiber 树称为“Current Fiber Tree”, 我们将其中的 Fiber 节点简写为 &lt;code class=&quot;language-text&quot;&gt;currFiber&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;当前正在构建的 Fiber 树称为“WorkInProgress Fiber Tree”, 我们将其 Fiber 节点节点简写为 &lt;code class=&quot;language-text&quot;&gt;wipFiber&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而这两棵树中节点的 &lt;code class=&quot;language-text&quot;&gt;alternate&lt;/code&gt; 属性互相指向对方树中的对应节点, 即: &lt;code class=&quot;language-text&quot;&gt;currFiber.alternate === wipFiber; wipFiber.alternate === currFber;&lt;/code&gt; 他们用于对比更新前后的节点以决定如何更新此节点.&lt;/p&gt;
&lt;p&gt;在 React 中, 整个应用的根节点为 &lt;code class=&quot;language-text&quot;&gt;fiberRoot&lt;/code&gt; , 当 wipFiber 树构建完成后, &lt;code class=&quot;language-text&quot;&gt;fiberRoot.current&lt;/code&gt; 将从 currFiber 树的根节点切换为 wipFiber 的根节点, 以完成更新操作.&lt;/p&gt;
&lt;h3&gt;3.1 基于 Fiber 的调度——时间切片&lt;/h3&gt;
&lt;p&gt;在 2.2 节我们讨论了采用拆分工作单元并以时间切片的方式执行, 以避免阻塞主线程. 在 Fiber 架构下, 每个 Fiber 节点就是一个工作单元.&lt;/p&gt;
&lt;p&gt;在以下示例代码中, 我们使用浏览器提供的 &lt;code class=&quot;language-text&quot;&gt;requestIdleCallback&lt;/code&gt; 方法演示这个过程, 它会在浏览器空闲时执行一个 workLoop、处理一个 Fiber 节点, 然后可以根据实际情况继续执行或暂停等待执行下一个 workLoop.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;workLoop&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;deadline&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; shouldYield &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;nextUnitOfWork &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;shouldYield&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 处理一个Fiber节点, 返回下一个Fiber节点, 详见3.3节&lt;/span&gt;
    nextUnitOfWork &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;performUnitOfWork&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;nextUnitOfWork&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 暂停处理的演示: 当时间不足时取消循环处理过程&lt;/span&gt;
    shouldYield &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; deadline&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;timeRemaining&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 当执行完毕(不存在下一个执行单元), 提交整个DOM树&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;nextUnitOfWork &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; wipRoot&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;commitRoot&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;requestIdleCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;workLoop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;requestIdleCallback&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;workLoop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.2 对 Fiber 节点的处理顺序——DFS&lt;/h3&gt;
&lt;p&gt;由前文我们可知, Fiber 节点通过 &lt;code class=&quot;language-text&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;sibling&lt;/code&gt; 三个属性相互连接, 整体构成一个单向链表结构,其调度方式就是 深度优先遍历 :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以 wipFiber 树的 Root 节点作为第一个执行单元;&lt;/li&gt;
&lt;li&gt;若当前执行单元存在 child 节点, 则将 child 节点作为下一个执行单元;&lt;/li&gt;
&lt;li&gt;重复 2, 直至当前执行单元无 child;&lt;/li&gt;
&lt;li&gt;若当前执行单元存在 sibling 节点, 则将 sibling 节点作为下一个执行单元, 并回到 2;&lt;/li&gt;
&lt;li&gt;若当前执行单元无 child 且无 sibling, 返回到父节点, 并回到 4;&lt;/li&gt;
&lt;li&gt;重复 5; 直至回到 Root 节点, 执行完毕, 将 &lt;code class=&quot;language-text&quot;&gt;fiberRoot.current&lt;/code&gt; 只为 wipFiber 树的根节点.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上步骤说明, Fiber 节点通过 &lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt; → &lt;code class=&quot;language-text&quot;&gt;sibling&lt;/code&gt; → &lt;code class=&quot;language-text&quot;&gt;return&lt;/code&gt; 的顺序进行深度优先遍历“处理”, 而后更新 Fiber 树. 那么如何“处理”Fiber 节点呢?&lt;/p&gt;
&lt;h3&gt;3.3 对 Fiber 节点的处理过程&lt;/h3&gt;
&lt;p&gt;对 Fiber 节点的处理就是执行一个 &lt;code class=&quot;language-text&quot;&gt;performUnitOfWork&lt;/code&gt; 方法, 它接收一个将要处理的 Fiber 节点, 然后完成以下工作:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;完善构建 Fiber 节点: 创建 DOM 并获取 &lt;code class=&quot;language-text&quot;&gt;children&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于 HostComponent 和 ClassComponent, 根据 Fiber 中的相关属性, 创建 DOM 节点并赋给 &lt;code class=&quot;language-text&quot;&gt;Fiber.stateNode&lt;/code&gt; 属性;&lt;/li&gt;
&lt;li&gt;对于 FunctionComponent, 直接通过函数调用获取其 children: &lt;code class=&quot;language-text&quot;&gt;Fiber.type(Fiber.props)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 执行工作单元,并返回下一个工作单元&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;performUnitOfWork&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;fiber&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;token comment&quot;&gt;// 构建当前节点的fiber&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; isFunctionComponent &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;type &lt;span class=&quot;token keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Function&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;isFunctionComponent&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;token function&quot;&gt;updateFunctionComponent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;token function&quot;&gt;updateHostComponent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

 &lt;span class=&quot;token comment&quot;&gt;// 处理子节点, 构建Fiber树&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; elements &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;children
 &lt;span class=&quot;token function&quot;&gt;reconcileChildren&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; elements&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

 &lt;span class=&quot;token comment&quot;&gt;// TODO: 返回下一个执行单元&lt;/span&gt;
 &lt;span class=&quot;token comment&quot;&gt;// fiber.child || fiber.sibling || fiber.return&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// Class/Host组件: 创建DOM&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateHostComponent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;fiber&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dom&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
   fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dom &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createDom&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;token function&quot;&gt;reconcileChildren&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;children&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 更新Function组件, Function组件需要从返回值获取子组件&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 注意: Function组件无DOM&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;updateFunctionComponent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;fiber&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;token comment&quot;&gt;// 初始化hooks&lt;/span&gt;
 wipFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fiber
 hookIndex &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
 fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;hooks &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; children &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Function组件返回children&lt;/span&gt;
 &lt;span class=&quot;token function&quot;&gt;reconcileChildren&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; children&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// TODO: reconcileChildren处理子节点,见第3步&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 &lt;code class=&quot;language-text&quot;&gt;Fiber.alternate&lt;/code&gt; 获取 &lt;code class=&quot;language-text&quot;&gt;oldFiber&lt;/code&gt; , 即上一次更新后的 Fiber 值, 然后在下一步中构建和 Diff 当前 Fiber 的 &lt;code class=&quot;language-text&quot;&gt;children&lt;/code&gt; .&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;reconcileChildren&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;wipFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; elements&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; oldFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;child
 &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构建 &lt;code class=&quot;language-text&quot;&gt;children&lt;/code&gt; Fibers, 对于每个子 Fiber, 同步地完成以下工作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建 Fiber 链表: 为每个子元素创建 Fiber, 并将父 Fiber 的 &lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt; 属性指向第一个子 Fiber, 然后按顺序将子 Fiber 的 &lt;code class=&quot;language-text&quot;&gt;sibling&lt;/code&gt; 属性指向下一个子 Fiber;&lt;/li&gt;
&lt;li&gt;对比(Diffing)新旧 Fiber 节点的 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt; 等属性, 确定节点是可以直接复用、替换、更新还是删除, 需要更新的 Fiber 节点在其 &lt;code class=&quot;language-text&quot;&gt;effectTag&lt;/code&gt; 属性中打上 &lt;code class=&quot;language-text&quot;&gt;Update&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;Placement&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;PlacementAndUpdate&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;Deletion&lt;/code&gt; 等标记, 以在提交更新阶段进行处理.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;reconcileChildren&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;wipFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; elements&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; oldFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;child&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; index &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; prevSibling &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

 &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;index &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; elements&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; oldFiber &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; element &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; elements&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;index&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; newFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

   &lt;span class=&quot;token comment&quot;&gt;// Compare oldFiber to element&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; sameType &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; oldFiber &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; element &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; element&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;type &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; oldFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;type&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

   &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;sameType&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;token comment&quot;&gt;// update the node&lt;/span&gt;
     newFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
       type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; oldFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;type&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; element&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       dom&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; oldFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dom&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       parent&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; wipFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       alternate&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; oldFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       effectTag&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;UPDATE&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
     &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;element &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;sameType&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;token comment&quot;&gt;// add this node&lt;/span&gt;
     newFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
       type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; element&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;type&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; element&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       dom&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       parent&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; wipFiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       alternate&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
       effectTag&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;PLACEMENT&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
     &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;oldFiber &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;sameType&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;token comment&quot;&gt;// delete the oldFiber&apos;s node&lt;/span&gt;
     oldFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;effectTag &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;DELETION&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
     deletions&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;oldFiber&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;oldFiber&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
     oldFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; oldFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sibling&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

   &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;index &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
     wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;child &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newFiber&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
     prevSibling &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newFiber&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

   prevSibling &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newFiber&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   index&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按 DFS 顺序返回下一个工作单元, 示例代码如下:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;child&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;child
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; nextFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; fiber
&lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;nextFiber&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;nextFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sibling&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; nextFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sibling
 &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
 nextFiber &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; nextFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;parent
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当 DFS 过程回到根节点时, 表明本次更新的 wipFiber 树 构建完成, 进入下一步的提交更新阶段.&lt;/p&gt;
&lt;h3&gt;3.4 提交更新阶段&lt;/h3&gt;
&lt;p&gt;在进入本阶段时, 新的 Fiber 树已构建完成, 需要进行替换、更新或删除的 Fiber 节点也在其 &lt;code class=&quot;language-text&quot;&gt;effectTag&lt;/code&gt; 中进行了标记, 所以本阶段第一个工作就是根据 &lt;code class=&quot;language-text&quot;&gt;effectTag&lt;/code&gt; 操作真实 DOM.&lt;/p&gt;
&lt;p&gt;为了避免从头再遍历 Fiber 树寻找具有 &lt;code class=&quot;language-text&quot;&gt;effectTag&lt;/code&gt; 属性的 Fiber, 在上一步 Fiber 树的构建过程中保存了一条需要更新的 Fiber 节点的单向链表 &lt;code class=&quot;language-text&quot;&gt;effectList&lt;/code&gt; , 并将此链表的头节点存储在 Fiber 树根节点的 &lt;code class=&quot;language-text&quot;&gt;firstEffect&lt;/code&gt; 属性中, 同时这些 Fiber 节点的 &lt;code class=&quot;language-text&quot;&gt;updateQueue&lt;/code&gt; 属性中也保存了需要更新的 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;除了更新真实 DOM 外, 在提交更新阶段还需要在特定阶段调用和处理生命周期方法、执行 Hooks 操作, 本文不再详述.&lt;/p&gt;
&lt;p&gt;在此参考了 &lt;a href=&quot;https://pomb.us/build-your-own-react/&quot;&gt;https://pomb.us/build-your-own-react/&lt;/a&gt; 中提供的 &lt;code class=&quot;language-text&quot;&gt;useState&lt;/code&gt; Hook 的实现代码, 有助于理解在执行 &lt;code class=&quot;language-text&quot;&gt;setState&lt;/code&gt; 方法后都发生了什么:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;initial&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 判断上一次渲染是否存在此Hook,如果存在就使用上一个state,否则创建新的hook并更新索引&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; oldHook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;
    wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
    wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;hooks &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
    wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;alternate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;hooks&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;hookIndex&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; hook &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    state&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; oldHook &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; oldHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; initial&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    queue&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 每次执行setState时,将action加入此队列,并在下一次渲染时执行&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// 下一次渲染时, 获取执行队列并逐步执行, 使得state保持最新&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; actions &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; oldHook &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; oldHook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;queue &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
  actions&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;action&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// setState方法: 将action添加到执行队列并触发渲染, 在下一次渲染时执行此action&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;setState&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;action&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;action&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 执行setState后应重新触发渲染&lt;/span&gt;
    wipRoot &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      dom&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; currentRoot&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dom&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; currentRoot&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      alternate&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; currentRoot&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    nextUnitOfWork &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; wipRoot
    deletions &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  wipFiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;hooks&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;hook&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  hookIndex&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;hook&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; setState&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;参考文献&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;React 官方文档与相关源码&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pomb.us/build-your-own-react/&quot;&gt;https://pomb.us/build-your-own-react/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://react.iamkasong.com/renderer/beforeMutation.html#commitbeforemutationeffects&quot;&gt;https://react.iamkasong.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[在线编辑器实现浅析]]></title><description><![CDATA[在线编辑器根据其侧重点和实现方式的不同, 可大致分为富文本编辑器和代码编辑器两类, 本文对这两类编辑器的实现方式进行最基本的解读和分析. 富文本编辑器 基本实现原理 富文本编辑器的实现原理很简单, 其编辑区域一般使用一个  的  元素来实现. 当 HTML…]]></description><link>https://hrayd.github.io/online-editor/</link><guid isPermaLink="false">https://hrayd.github.io/online-editor/</guid><pubDate>Sat, 10 Jul 2021 22:00:00 GMT</pubDate><content:encoded>&lt;p&gt;在线编辑器根据其侧重点和实现方式的不同, 可大致分为富文本编辑器和代码编辑器两类, 本文对这两类编辑器的实现方式进行最基本的解读和分析.&lt;/p&gt;
&lt;h1&gt;富文本编辑器&lt;/h1&gt;
&lt;h2&gt;基本实现原理&lt;/h2&gt;
&lt;p&gt;富文本编辑器的实现原理很简单, 其编辑区域一般使用一个 &lt;code class=&quot;language-text&quot;&gt;contentedtable=&amp;quot;true&amp;quot;&lt;/code&gt; 的 &lt;code class=&quot;language-text&quot;&gt;div&lt;/code&gt; 元素来实现. 当 HTML 元素的 &lt;code class=&quot;language-text&quot;&gt;contenteditable&lt;/code&gt; 属性设为 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt; 后, 该元素的内容变为可编辑状态:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;html&quot;&gt;&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;contenteditable&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;true&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;这是一个可编辑元素&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时即可修改元素的内容, 当点击回车键后, 会自动生成一个 &lt;code class=&quot;language-text&quot;&gt;p&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;div&lt;/code&gt; 元素.
可设置 &lt;code class=&quot;language-text&quot;&gt;outline: none&lt;/code&gt; 以去掉默认的聚焦态边框.&lt;/p&gt;
&lt;h2&gt;修改样式与内容&lt;/h2&gt;
&lt;p&gt;此时即可修改元素的内容, 当点击回车键后, 会自动生成一个 &lt;code class=&quot;language-text&quot;&gt;p&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;div&lt;/code&gt; 元素.&lt;/p&gt;
&lt;p&gt;可设置 &lt;code class=&quot;language-text&quot;&gt;outline: none&lt;/code&gt; 以去掉默认的聚焦态边框.文本样式的修改主要通过调用 &lt;code class=&quot;language-text&quot;&gt;document.execCommand()&lt;/code&gt; 方法来实现, 此方法会影响当前处于活动状态的可编辑元素. 此方法接收三个输入参数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令名称[string], 如 fontsize、backcolor、undo 等, 详见 MDN 相关参考.&lt;/li&gt;
&lt;li&gt;是否展开用户界面[boolean], 一般传入 false 即可.&lt;/li&gt;
&lt;li&gt;命令参数[可选], 如 fontSize 传入字体尺寸、backColor 传入 color 类型的 string 等, 默认为 null.&lt;/li&gt;
&lt;li&gt;返回值: boolean, 返回 false 表示命令不被支持或未启用.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 将当前行设为“Heading2”, 添加“h2”标签&lt;/span&gt;
document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;execCommand&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;formatblock&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;h2&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 在插入点或选中文字部分修改字体、字号&lt;/span&gt;
document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;execCommand&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;fontname&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Times New Roman&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;execCommand&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;fontsize&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;3&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 撤销上一次修改&lt;/span&gt;
document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;execCommand&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;undo&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; 是否展开用户界面&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;boolean&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 一般传入&lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;即可&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;浏览器实现差异&lt;/h2&gt;
&lt;p&gt;可编辑元素在不同浏览器及其版本之间可能存在一些差异, 如按下回车键后, IE/Opera 会添加一个 &lt;code class=&quot;language-text&quot;&gt;p&lt;/code&gt; 标签元素, 旧版本的 Firefox 会添加 &lt;code class=&quot;language-text&quot;&gt;br&lt;/code&gt; 元素, 而 Chrome/Safari 会添加 &lt;code class=&quot;language-text&quot;&gt;div&lt;/code&gt; 元素. 通过调用 &lt;code class=&quot;language-text&quot;&gt;document.execCommand(&amp;quot;defaultParagraphSeparator&amp;quot;, false, &amp;quot;div&amp;quot;)&lt;/code&gt; 可显式指定创建新段落的方式, 此方法也支持使用自定义标签, 如语雀的编辑器就使用了以 &lt;code class=&quot;language-text&quot;&gt;ne&lt;/code&gt; 开头的一系列自定义标签.&lt;/p&gt;
&lt;p&gt;文末提供了 MDN 中展示的一个最基本的原生富文本编辑器 Demo.&lt;/p&gt;
&lt;hr&gt;
&lt;h1&gt;代码编辑器&lt;/h1&gt;
&lt;p&gt;富文本编辑器受到原生 HTML 和 DOM 技术的友好支持, 其编辑区生成的就是一组的 HTML 元素, 通过自定义标签、添加自定义样式表等方式来定制主题样式即可.&lt;/p&gt;
&lt;p&gt;相较于富文本编辑器, 代码编辑器则要复杂得多. 代码编辑器的核心是通过对代码文本的词法、语法和语义分析, 将内容划分为关键字、变量名、字面量、函数体等元素, 并为每类元素添加不同的 CSS class, 同时插入一些带边框的空格元素来实现代码的缩进和格式化等.&lt;/p&gt;
&lt;h2&gt;monaco-editor&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;monaco-editor&lt;/code&gt; 是 VSCode 中分离出的编辑器模块, 也是目前最典型、应用最为广泛的前端代码编辑器之一, 本文以 &lt;code class=&quot;language-text&quot;&gt;monaco-editor&lt;/code&gt; 为例分析代码编辑器的实现方式.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;monaco-editor&lt;/code&gt; 的编辑器区域使用了绝对定位、完全重叠的两层 &lt;code class=&quot;language-text&quot;&gt;div&lt;/code&gt; 区域与一个 1px 宽度的 &lt;code class=&quot;language-text&quot;&gt;textarea&lt;/code&gt; 元素构成:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一层 div 主要负责背景样式的渲染, 其内部由绝对定位、固定高度的 div 代码行构成, 每个代码行内包含若干个绝对定位的 div 块, 用于展示缩进线、当前聚焦行边框、文字选中态高亮、警告和错误信息的下划波浪线等样式信息. 这一层的所有 div 都没有文本元素.&lt;/li&gt;
&lt;li&gt;第二层 div 用于渲染代码文本, 内部的 div 代码行与第一层完全重叠, 每个代码行内由若干 span 标签包裹的文本元素(一个单词、一个标点符号、一段连续空格等)构成. 对代码进行语义分析后为每个 span 元素赋予不同的 class , 从而实现代码高亮.&lt;/li&gt;
&lt;li&gt;输入光标为一个绝对定位、宽度为 1px、内容为空的 textarea , 当使用鼠标或触控板单击编辑器区域、或使用方向键和其他快捷键改变输入光标位置后, 需要计算出正确的文本编辑位置并更新 textarea 元素的位置.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1&gt;结语&lt;/h1&gt;
&lt;p&gt;本文对富文本编辑器和代码编辑器的实现方式进行了最基本最浅显的分析, 相较于代码编辑器而言, 富文本编辑器应用更广、更贴近前端.&lt;/p&gt;
&lt;p&gt;作为学习者, 可以扒一扒市面上比较有名的在线富文本编辑器(如语雀、幕布、Notion、EverNote 等), 发挥自己的创意, 做一个自己心目中更易用、更美观、更极客的富文本编辑器吧!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;附:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Editable_content/Rich-Text_Editing_in_Mozilla#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E4%BD%86%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8&quot;&gt;MDN - 一个简易但完整的富文本编辑器实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Microsoft/monaco-editor&quot;&gt;Monaco Editor - Github Pages&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://prosemirror.net/&quot;&gt;ProseMirror - 一个开源的支持 Markdown、WYSIWYG 的富文本编辑器 Toolkit&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[NPM/Yarn包管理策略与最佳实践]]></title><description><![CDATA[NPM NPM 安装机制 执行  : 读取 npm 配置文件  配置文件优先级: 项目级 > 用户级 > 全局 > npm…]]></description><link>https://hrayd.github.io/npm/</link><guid isPermaLink="false">https://hrayd.github.io/npm/</guid><pubDate>Sat, 10 Jul 2021 22:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;NPM&lt;/h2&gt;
&lt;h3&gt;NPM 安装机制&lt;/h3&gt;
&lt;p&gt;执行 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;读取 npm 配置文件 &lt;code class=&quot;language-text&quot;&gt;.npmrc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;配置文件优先级: 项目级 &gt; 用户级 &gt; 全局 &gt; npm 内置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查是否存在 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 文件:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若不存在, 则根据 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 递归构建依赖树并从缓存或远程仓库下载相关资源, 并生成 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 文件;&lt;/li&gt;
&lt;li&gt;若存在, 则对比 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 文件中声明的依赖规范是否一致:&lt;/li&gt;
&lt;li&gt;若一致, 直接使用 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 中的信息从缓存或远程仓库加载依赖文件;&lt;/li&gt;
&lt;li&gt;若不一致, NPM v5.4.2+ 会按照 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 文件安装依赖并更新 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 文件(NPM 旧版本的处理方式有所不同, 详见下文).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构建扁平化依赖树: 无论是直接依赖还是嵌套依赖, 都优先将依赖包放在 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 根目录.&lt;/p&gt;
&lt;p&gt;当遇到相同模块且版本冲突时, 将后者放在当前模块的 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 目录下.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;NPM 不同版本对于 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 文件处理方式的不同, 可能导致安装的依赖包版本不一致, 所以团队内应保持 NPM 版本一致.&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;NPM 缓存机制&lt;/h3&gt;
&lt;p&gt;获取 NPM 本地缓存路径: &lt;code class=&quot;language-text&quot;&gt;npm config get cache&lt;/code&gt; , 默认为 &lt;code class=&quot;language-text&quot;&gt;~/.npm&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;缓存路径下的 &lt;code class=&quot;language-text&quot;&gt;_cacache&lt;/code&gt; 目录下有三个子目录:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;content-v2&lt;/code&gt; 二进制文件, 将此目录扩展名改为 &lt;code class=&quot;language-text&quot;&gt;.tgz&lt;/code&gt; 并解压则可以得到依赖包资源&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;index-v5&lt;/code&gt; 同样可通过修改扩展名解压, 是 &lt;code class=&quot;language-text&quot;&gt;content-v2&lt;/code&gt; 资源的索引文件&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;tmp&lt;/code&gt; 临时文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NPM 缓存策略: 执行 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 时, 若缓存中存在依赖包, 则通过 &lt;code class=&quot;language-text&quot;&gt;pacote&lt;/code&gt; 将依赖包解压到对应的 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 目录下; 若缓存中不存在, 则先从远程仓库下载依赖包到缓存中, 再从缓存解压到项目 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 中.&lt;/p&gt;
&lt;p&gt;在安装资源时, 根据 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 中依赖包的 &lt;code class=&quot;language-text&quot;&gt;integrity&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;version&lt;/code&gt; 信息生成一个唯一的 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt;, 根据这个 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt; 从 &lt;code class=&quot;language-text&quot;&gt;index-v5&lt;/code&gt; 目录中寻找缓存资源的 &lt;code class=&quot;language-text&quot;&gt;hash&lt;/code&gt; , 如果找到了就可以从 &lt;code class=&quot;language-text&quot;&gt;content-v2&lt;/code&gt; 中找到对应的 tar 包, 通过 &lt;code class=&quot;language-text&quot;&gt;pacote&lt;/code&gt; 将二进制文件解压到项目的 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 中.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NPM v5 之前的缓存文件是以 &lt;code class=&quot;language-text&quot;&gt;{cache}/{name}/{version}&lt;/code&gt; 的形式直接存储在 &lt;code class=&quot;language-text&quot;&gt;.npm&lt;/code&gt; 目录下.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;npm link&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;npx&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;npm link&lt;/code&gt; 为目标模块创建软连接, 将其链接到全局安装路径中, 可用于在模块发布之前在本地调试和使用.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;npx&lt;/code&gt; 的两个作用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可直接执行 &lt;code class=&quot;language-text&quot;&gt;node_modules/.bin&lt;/code&gt; 和 环境变量 &lt;code class=&quot;language-text&quot;&gt;PATH&lt;/code&gt; 中的命令, 在之前只能通过在 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 中定义 &lt;code class=&quot;language-text&quot;&gt;script&lt;/code&gt; 或手动定位到命令所在目录来执行;&lt;/li&gt;
&lt;li&gt;执行一个需要安装依赖的命令, 在临时目录中安装依赖, 并在执行完成后删除相关依赖, 避免在全局安装模块. 可用于使用脚手架生成项目: &lt;code class=&quot;language-text&quot;&gt;npx create-react-app my-app&lt;/code&gt; .&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 中的依赖&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 文件中的 &lt;code class=&quot;language-text&quot;&gt;dependency&lt;/code&gt; 主要有以下属性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Version：版本号&lt;/li&gt;
&lt;li&gt;Resolved：安装源（下载地址）&lt;/li&gt;
&lt;li&gt;Integrity：表明包完整性的 Hash 值&lt;/li&gt;
&lt;li&gt;Dev：该依赖是否为顶级模块的开发依赖或者是传递依赖&lt;/li&gt;
&lt;li&gt;requires：需要的所有依赖项, 对应该依赖包 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 中 &lt;code class=&quot;language-text&quot;&gt;dependencies&lt;/code&gt; 中的依赖项&lt;/li&gt;
&lt;li&gt;dependencies：依赖包 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 中依赖的包, 当子依赖的依赖与当前根目录中的依赖冲突后才有此属性&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;lockfiles&lt;/code&gt; 与 NPM 版本问题总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;早期 NPM 使用 &lt;code class=&quot;language-text&quot;&gt;npm-shrinkwrap.json&lt;/code&gt; 锁定版本, 与 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 不同点在于：NPM 包发布时默认将 &lt;code class=&quot;language-text&quot;&gt;npm-shrinkwrap.json&lt;/code&gt; 同时发布;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 是 NPM v5.x 版本新增特性, 而 v5.6 以上才逐步稳定, 在 5.0 - 5.6 之间对 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 的处理逻辑进行过几次更新:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 v5.0.x 中, &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 时根据 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 文件下载, 不考虑 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 内容;&lt;/li&gt;
&lt;li&gt;v5.1.0 - v5.4.2, &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 会无视 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 文件而下载最新的依赖包并更新 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; ;&lt;/li&gt;
&lt;li&gt;v5.4.2 后：&lt;/li&gt;
&lt;li&gt;如果项目只有 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 文件, &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 后会根据它生成一个 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 文件;&lt;/li&gt;
&lt;li&gt;如果存在 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 文件，同时 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 的 &lt;code class=&quot;language-text&quot;&gt;semver-range&lt;/code&gt; 版本 和 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 中版本兼容, &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 会根据 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 下载;&lt;/li&gt;
&lt;li&gt;如果存在 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 且 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 的 &lt;code class=&quot;language-text&quot;&gt;semver-range&lt;/code&gt; 版本和 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 中版本不兼容, &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 时 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 将会更新到兼容 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 的版本;&lt;/li&gt;
&lt;li&gt;如果 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;npm-shrinkwrap.json&lt;/code&gt; 都存在于项目根目录, &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 将会被忽略.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;code class=&quot;language-text&quot;&gt;xxxDependencies&lt;/code&gt; 声明总结&lt;/h3&gt;
&lt;p&gt;NPM 中共有 5 中依赖声明:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;dependencies&lt;/code&gt; 项目依赖, NPM 包被下载时, 它的项目依赖会被一起下载.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;devDependencies&lt;/code&gt; 开发依赖, 只在开发阶段或开发环境用到的依赖. 在实际业务中只是一个规范, 依赖是否被打包完全取决于项目中是否引入了该模块, 开发依赖在 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 时也会被下载.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;peerDependencies&lt;/code&gt; 同版本依赖, 一般用于在基于某个框架或核心库做扩展库或中间件时, 来声明宿主环境, 如开发基于 React 的 UI 组件库时就可以声明 &lt;code class=&quot;language-text&quot;&gt;&amp;quot;peerDependencies&amp;quot;: { &amp;quot;react&amp;quot;: &amp;quot;^17.0.0&amp;quot; }&lt;/code&gt; .&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;bundledDependencies&lt;/code&gt; 捆绑依赖, 在 &lt;code class=&quot;language-text&quot;&gt;npm pack&lt;/code&gt; 时会在压缩包中包含捆绑依赖中声明的安装包; 业务方使用 &lt;code class=&quot;language-text&quot;&gt;npm install xx&lt;/code&gt; 安装压缩包时也会安装捆绑依赖中声明的包. 需要注意的是, 此包必须在 &lt;code class=&quot;language-text&quot;&gt;dependencies&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;devDependencies&lt;/code&gt; 中声明过.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;optionalDependencies&lt;/code&gt; 可选依赖, 表示安装失败也不影响整个过程, 一般不建议使用.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;CI 环境中的 NPM 优化&lt;/h2&gt;
&lt;h3&gt;使用 &lt;code class=&quot;language-text&quot;&gt;npm ci&lt;/code&gt; 代替 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;npm ci&lt;/code&gt; 是专用于 CI 环境的安装命令, 它与 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 的主要不同有:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目中必须存在 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;npm-shrinkwrap.json&lt;/code&gt; ;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;npm ci&lt;/code&gt; 完全根据 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 安装依赖, 保证整个团队的依赖包完全一致, 同时安装过程也更迅速;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;npm ci&lt;/code&gt; 执行安装时会删除现有的 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 并重新安装;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;npm ci&lt;/code&gt; 只能一次安装整个依赖包, 无法单独安装;&lt;/li&gt;
&lt;li&gt;若 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 冲突会直接报错;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;npm ci&lt;/code&gt; 不会修改 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; .&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于 &lt;code class=&quot;language-text&quot;&gt;npm ci&lt;/code&gt; 命令的特性, 可得出以下 CI 环境中的 NPM 优化方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提交 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 到仓库;&lt;/li&gt;
&lt;li&gt;缓存 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 文件;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;适用于团队的 NPM 最佳实践&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用 NPM v5.4.2 以上的版本, 最好统一 Node.js 版本.&lt;/li&gt;
&lt;li&gt;项目初次搭建时使用 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 安装依赖, 并提交 package.json、package-lock.json, 不提交 node_modules 目录.&lt;/li&gt;
&lt;li&gt;其他成员首次 clone/checkout 项目后, 执行 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 安装依赖包.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;升级依赖包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code class=&quot;language-text&quot;&gt;npm update&lt;/code&gt; 升级到新的小版本;&lt;/li&gt;
&lt;li&gt;使用 &lt;code class=&quot;language-text&quot;&gt;npm install @&lt;/code&gt; 升级大版本;&lt;/li&gt;
&lt;li&gt;也可以手动修改 package.json 中的版本号并执行 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 升级版本;&lt;/li&gt;
&lt;li&gt;本地验证升级后无问题再提交新的 package.json、package-lock.json 文件.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;降级依赖包：执行 &lt;code class=&quot;language-text&quot;&gt;npm install @&lt;/code&gt; 命令，验证没问题后提交新的 package.json、package-lock.json 文件.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除依赖包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行 &lt;code class=&quot;language-text&quot;&gt;npm uninstall xx&lt;/code&gt; 命令, 验证没问题后提交新的 package.json、package-lock.json 文件;&lt;/li&gt;
&lt;li&gt;或手动更改 package.json 删除依赖并执行 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 命令, 验证没问题后提交新的 package.json、package-lock.json 文件.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;任何成员更新 package.json、package-lock.json 后, 其他成员在拉取代码后执行 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; 更新依赖.&lt;/li&gt;
&lt;li&gt;禁止修改 package-lock.json.&lt;/li&gt;
&lt;li&gt;若 package-lock.json 出现冲突或问题，建议删除本地 package-lock.json 文件, 引入远程的 package-lock.json 和 package.json 文件, 再执行 &lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt; .&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Yarn&lt;/h2&gt;
&lt;p&gt;Yarn 是在 NPM 处于 v3 时为了解决 NPM 在依赖包的版本确定性(无 lock 文件)、扁平化安装、网络性能、缓存机制等方面的问题而出现的包管理器.&lt;/p&gt;
&lt;p&gt;目前 NPM 也吸收了 Yarn 的很多优势特点, 改进了本身存在的诸多问题, 所以二者目前并没有明显的优劣之分.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;yarn.lock&lt;/code&gt; 与 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 相比, 除了文件格式不同, 另一个显著区别是其中的 &lt;strong&gt;子依赖&lt;/strong&gt; 的版本号不是固定版本, 而是类似于 &lt;code class=&quot;language-text&quot;&gt;^4.0.1&lt;/code&gt; 这样的版本规则, 这意味着 &lt;code class=&quot;language-text&quot;&gt;yarn.lock&lt;/code&gt; 必须和 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 文件相配合才能确定 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 目录结构.&lt;/p&gt;
&lt;p&gt;Yarn 和 NPM 的另一个显著区别是: Yarn 默认使用 &lt;code class=&quot;language-text&quot;&gt;prefer-online&lt;/code&gt; 模式, 即优先使用网络资源, 请求失败后才去读取缓存资源.&lt;/p&gt;
&lt;h3&gt;Yarn 安装机制&lt;/h3&gt;
&lt;p&gt;Yarn 的安装过程可分为 5 个步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Checking&lt;/p&gt;
&lt;p&gt;检查项目中是否存在 npm 相关文件如 &lt;code class=&quot;language-text&quot;&gt;package-lock.json&lt;/code&gt; 等, 若有会提示用户可能导致冲突; 也会检查当前环境的操作系统、CPU 等信息.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Resolving&lt;/p&gt;
&lt;p&gt;解析依赖树:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取首层依赖, 即 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt; 中的 &lt;code class=&quot;language-text&quot;&gt;dependencies&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;devDependencies&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;optionalDependencies&lt;/code&gt; 内容&lt;/li&gt;
&lt;li&gt;遍历首层依赖, 逐个递归查找嵌套依赖: 对于每个包, 尝试从 &lt;code class=&quot;language-text&quot;&gt;yarn.lock&lt;/code&gt; 中获取版本信息, 若获取不到, 则从远程仓库获取满足版本规则的最高版本的版本信息.&lt;/li&gt;
&lt;li&gt;通过步骤 b 最终得到所有依赖的具体版本信息和下载地址.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fetching&lt;/p&gt;
&lt;p&gt;检查缓存中是否存在当前依赖包, 对于不存在的包会维护一个 fetch 队列, 将依赖包下载到缓存目录.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linking&lt;/p&gt;
&lt;p&gt;将依赖包从缓存目录 &lt;strong&gt;扁平化&lt;/strong&gt; 复制到项目 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 下.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Building&lt;/p&gt;
&lt;p&gt;对存在二进制包的依赖包进行编译.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;依赖嵌套问题&lt;/h2&gt;
&lt;h3&gt;早期 NPM 的树形依赖&lt;/h3&gt;
&lt;p&gt;早期 NPM 的依赖包采用自然的树形依赖: 将项目的直接依赖放到项目 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 根目录, 若直接依赖 A 还依赖模块 B, 则将模块 B 放在模块 A 的 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 下. 在稍复杂的项目中形成“嵌套地狱”:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;依赖树层级过深, 一方面难以调试, 另一方面可能出现文件路径过长导致的一些问题;&lt;/li&gt;
&lt;li&gt;依赖树的不同分支可能存在重复的依赖包, 导致安装过慢、浪费空间.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;扁平化依赖&lt;/h3&gt;
&lt;p&gt;对于没有版本冲突的依赖包, 扁平化地将依赖包放在 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 根目录.&lt;/p&gt;
&lt;p&gt;存在版本冲突时则嵌套安装, 如 模块 A 依赖 模块 B-v1.0 , 模块 C 依赖 模块 B-v2.0 , 则将 模块 B-v2.0 安装在 模块 C 的 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 中.&lt;/p&gt;
&lt;p&gt;冲突模块 B 不同版本的安装路径取决于模块 A 和 C 的安装顺序, 先安装的版本放在根目录.&lt;/p&gt;
&lt;p&gt;此时, 依赖包的安装顺序对依赖树影响很大: 若 模块 A 依赖 模块 B-v1.0 , 而 模块 C、D、E 都依赖 模块 B-2.0 , 则会导致 C、D、E 模块下都存在重复性的 模块 B-v2.0 .&lt;/p&gt;
&lt;p&gt;执行 &lt;code class=&quot;language-text&quot;&gt;npm dedupe&lt;/code&gt; 会尝试通过将依赖关系向上移动来尽可能删除重复依赖.&lt;/p&gt;
&lt;p&gt;Yarn 则会在安装依赖时自动执行 &lt;code class=&quot;language-text&quot;&gt;dedupe&lt;/code&gt; 命令.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Clean Architecture]]></title><description><![CDATA[第一部分 概述 第…]]></description><link>https://hrayd.github.io/clean-architecture/</link><guid isPermaLink="false">https://hrayd.github.io/clean-architecture/</guid><pubDate>Fri, 18 Jun 2021 22:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;第一部分 概述&lt;/h2&gt;
&lt;h3&gt;第 1 章 设计与架构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;随着软件版本的更迭: 需要的工程师人数越来越多、人均生产效率显著降低(以同期代码行数作为统计)、每行代码的变更成本显著增高.&lt;/li&gt;
&lt;li&gt;对于重构的过于乐观: 为了快速上线而容忍混乱的代码, 忽略软件架构, 而寄希望于未来的重构工作. 事实上, 新功能源源不断, 混乱的架构又会导致新功能的开发成本急速上升, 生产效率持续下降, 陷入恶性循环, 导致重构的成本越来越大, 重构的时机几乎不会存在.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 2 章 两个价值维度&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;两个价值纬度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;系统行为, 即软件功能是否满足需求&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;系统架构, 即软件是否足够灵活&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;何者更重要?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是系统正常工作更重要, 还是系统易于修改更重要?&lt;/li&gt;
&lt;li&gt;对于业务部门来说, 答案一般是前者, 而一旦开发人员也选择了前者, 紧接着就会面临源源不断的新增需求和需求变更, 导致生产效率直线下降.&lt;/li&gt;
&lt;li&gt;所以对于开发人员来说, 系统架构大于系统行为: 只要保持系统的灵活性, 系统行为总会以平和的方式得到满足.&lt;/li&gt;
&lt;li&gt;开发团队同市场、销售、运营团队一样需要“长期抗争”, 保护系统的灵活性/可维护性, 是开发团队的职责.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第二部分 编程范式&lt;/h2&gt;
&lt;h3&gt;第 3 章 编程范式总览&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;三大编程范式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构化编程&lt;/li&gt;
&lt;li&gt;对程序控制权的直接转移进行了限制和规范&lt;/li&gt;
&lt;li&gt;限制了 goto: 使用 if、for、while 等流程控制&lt;/li&gt;
&lt;li&gt;面向对象编程&lt;/li&gt;
&lt;li&gt;对程序控制权的间接转移进行了限制和规范&lt;/li&gt;
&lt;li&gt;限制了函数指针&lt;/li&gt;
&lt;li&gt;函数式编程&lt;/li&gt;
&lt;li&gt;对程序中的赋值进行了限制和规范&lt;/li&gt;
&lt;li&gt;限制了赋值语句&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编程范式与架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;架构的三大关注点&lt;/li&gt;
&lt;li&gt;功能性&lt;/li&gt;
&lt;li&gt;组件独立性&lt;/li&gt;
&lt;li&gt;数据管理&lt;/li&gt;
&lt;li&gt;编程范式的作用&lt;/li&gt;
&lt;li&gt;结构化编程: 实现逻辑功能&lt;/li&gt;
&lt;li&gt;面向对象: 封装与多态&lt;/li&gt;
&lt;li&gt;函数式: 规范数据存放与访问权限&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 4 章 结构化编程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可推导性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三种基本结构&lt;/li&gt;
&lt;li&gt;顺序结构&lt;/li&gt;
&lt;li&gt;分支结构&lt;/li&gt;
&lt;li&gt;循环结构&lt;/li&gt;
&lt;li&gt;可以用三种基本结构构造出任何程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不受限制的直接控制转移语句——goto 是有害的, 可被三种基本结构替代&lt;/li&gt;
&lt;li&gt;结构化编程范式使得可以将大型系统设计拆分为模块和组件, 然后可递归拆分为更小的、可证明的函数&lt;/li&gt;
&lt;li&gt;结构化编程范式促使将一段程序递归降解为一系列小单元, 程序的测试过程即证伪过程.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 5 章 面向对象编程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;面向对象编程语言&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;封装性: 较 C 而言实际上减弱了封装性&lt;/li&gt;
&lt;li&gt;继承性: 提供了一定便利,但没有开创出新&lt;/li&gt;
&lt;li&gt;多态: C 本来就有,只是提供了安全性和便利&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面向对象的多态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插件式架构&lt;/li&gt;
&lt;li&gt;程序应与设备无关&lt;/li&gt;
&lt;li&gt;依赖反转&lt;/li&gt;
&lt;li&gt;原本: 层层依赖-上层组件依赖下层组件&lt;/li&gt;
&lt;li&gt;多态: 上层组件提供需求接口, 底层组件实现接口&lt;/li&gt;
&lt;li&gt;例子&lt;/li&gt;
&lt;li&gt;原本: 业务逻辑引入(依赖)用户界面和数据库&lt;/li&gt;
&lt;li&gt;应用多态: 用户界面和数据库作为业务逻辑的插件,从而可以各自独立部属&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;架构师眼中的面向对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以多态为手段来对源代码中的依赖关系进行控制, 构建出某种插件式架构, 让高层策略性组件和底层实现性组件相分离, 底层组件可以作为插件, 独立于高层组件进行开发和部属&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 6 章 函数式编程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;变量不可变&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不可变性与软件架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果变量不可变, 一切并发问题都会不复存在: 竞争、死锁、并发更新等.&lt;/li&gt;
&lt;li&gt;不可变性是否可行? 如果能忽略存储器和处理器的速度限制,则可行; 否则只有一定情况下可行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可变形隔离&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个架构设计良好的应用程序应该将状态修改的部分和不需要修改状态的部分隔离成单独的组件，然后用合适的机制来保护可变量&lt;/li&gt;
&lt;li&gt;软件架构师应该着力于将大部分处理逻辑都归于不可变组件中，可变状态组件的逻辑应该越少越好&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件溯源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果有足够大的存储量和处理能力，应用程序就可以用完全不可变的、纯函数式的方式来编程&lt;/li&gt;
&lt;li&gt;只存储事务记录, 不存储具体状态, 通过计算所有事务来获取当前状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第三部分 设计原则&lt;/h2&gt;
&lt;h3&gt;综述&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;构建中层结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使软件可容忍被改动&lt;/li&gt;
&lt;li&gt;使软件更容易被理解&lt;/li&gt;
&lt;li&gt;构建可复用的组件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SOLID 原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SRP: 单一职责原则——每个模块有且只有一个被改变的理由&lt;/li&gt;
&lt;li&gt;OCP: 开闭原则——允许通过新增代码来扩展功能,尽量减少代码修改&lt;/li&gt;
&lt;li&gt;LSP: 李氏替换原则——遵守同一约定的组件可相互替换&lt;/li&gt;
&lt;li&gt;ISP: 接口隔离原则——在设计中避免不必要的依赖&lt;/li&gt;
&lt;li&gt;DIP: 依赖反转原则——实现底层细节的代码应依赖高层策略性代码,而非反向依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 7 章 SRP: 单一职责原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;不仅仅是“每个模块只做一件事”&lt;/li&gt;
&lt;li&gt;任何一个软件模块都应该只对某一类行为者负责&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 8 章 OCP: 开闭原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;易于扩展(新增代码),抗拒修改&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;将需求分组,即 SRP&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;调整分组之间的依赖,即 DIP&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果 A(Father)组件不想被 B(Child)组件发生的修改所影响,那么就让 B 依赖于 A.&lt;/li&gt;
&lt;li&gt;分层设计: 高层组件更核心、更封闭, 低层依赖于高层.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 9 章 LSP: 李氏替换原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;子类型可以替代父类型被调用/使用, 即继承关系&lt;/li&gt;
&lt;li&gt;LSP 演变为更广泛的、指导接口与实现方式的设计原则&lt;/li&gt;
&lt;li&gt;反例: 当核心业务逻辑出现无法避免的例外情况时,避免在核心组件中进行特殊情况判断,而应该使用一个额外的调度组件来处理特殊情况&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 10 章 ISP: 接口隔离原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;尽量避免多个行为依赖并操作同一个接口: 在中间再做一层封装进行隔离.&lt;/li&gt;
&lt;li&gt;尽量减少不必要的依赖, 第 13 章再继续探讨更多细节&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 11 章 DIP: 依赖反转原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在源代码层次上只引用包含接口、抽象类或其他抽象类型声明的源文件, 而不引用任何具体实现.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编码守则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多使用抽象接口,避免使用多变的具体实现类&lt;/li&gt;
&lt;li&gt;不要在具体实现类上创建衍生类&lt;/li&gt;
&lt;li&gt;不要覆盖(override)包含具体实现的函数&lt;/li&gt;
&lt;li&gt;避免在代码中写入任何具体实现相关或其他容易变动的事务的名字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用抽象工厂模式创建对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第四部分 组件构建原则&lt;/h2&gt;
&lt;h3&gt;第 12 章 组件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;组件是软件在部属过程中的最小单元&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在编译运行语言中是一组二进制文件;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在解释运行语言中是一组源代码文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;设计良好的组件: 独立部署、单独开发&lt;/li&gt;
&lt;li&gt;组件概念的历史: 动态链接文件&lt;/li&gt;
&lt;li&gt;现状: 组件化的插件式架构&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 13 章 组件聚合&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;问题: 哪些类应该被合成一个组件?&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;REP: 复用/发布等同原则&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- 软件复用的最小粒度应等同于其发布的最小粒度
- 被复用的组件应有明确的发布版本号、适当的通知和发布文档
- 组件中包含的类与模块也应该可以同时发布,共享相同的版本号和版本跟踪,被包含在发布文档中.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CCP: 共同闭包原则&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- 将会同时修改、并且为相同目的而修改的类放入同一组件; 反之放入不同组件.
- SRP原则在组件层面的阐述
- 一个组件应该只有一个变更原因;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一次变更最好都体现在一个组件中 - 一般来说, 可维护性比可复用性重要得多&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CRP: 共同复用原则&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;- 将经常共同复用的类和模块放入同一个组件
- 不是紧密相连的类不应被放入同一组件
- 是ISP原则的普适版&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;组件聚合原则张力图&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;REP 和 CCP 使组件更大, CRP 使组件更小, 架构师的任务就是在三原则中进行取舍, 并且是随着项目状态逐步调整&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目早期一般偏向右侧, 主要牺牲复用性&lt;/li&gt;
&lt;li&gt;随着项目逐渐成熟,其他项目对其产生依赖,会逐渐向左侧滑动&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 14 章 组件耦合&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无依赖环原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决方案&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;将项目划分为可独立发布的组件&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;组件独立发布,打版本号并通知其他成员&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;其他开发者基于组件公开发布的版本进行开发,并可以选择是否采用新版本&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;组件依赖图: 有向无环图(DAG)&lt;/li&gt;
&lt;li&gt;可以直观地判断出某个组件变更的影响范围&lt;/li&gt;
&lt;li&gt;无环: 从任意节点开始沿依赖线都回不到起始点&lt;/li&gt;
&lt;li&gt;发布过程从下至上进行编译、测试、发布&lt;/li&gt;
&lt;li&gt;循环依赖: 组件依赖图存在环, 组件的独立维护工作以及单元测试、发布流程都将十分困难&lt;/li&gt;
&lt;li&gt;消除循环依赖&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;应用依赖反转原则(DIP), 将环形依赖反转&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;创建新的上层组件, 将相互依赖的类进行抽象提取&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;当循环依赖出现时,必须立刻进行消除,调整组件结构&lt;/li&gt;
&lt;li&gt;组件结构图的构建&lt;/li&gt;
&lt;li&gt;不可能在系统构建之初就被完美设计, 因为它不是描述软件功能的,而是软件构建性和维护性的地图&lt;/li&gt;
&lt;li&gt;隔离频繁的变更: 将稳定的高价值组件与常变的组件进行隔离&lt;/li&gt;
&lt;li&gt;随着项目的逻辑设计一起扩张和演进&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;稳定依赖原则(SDP)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;稳定性&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直观上&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果组件不依赖其他组件, 或被多个其他组件依赖, 则是稳定的组件.&lt;/li&gt;
&lt;li&gt;如果组件依赖多个组件, 则是不稳定的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I(不稳定性) = FanOut / (FanIn + FanOut)&lt;/li&gt;
&lt;li&gt;FanIn: 入向依赖,组件内部类被外部类依赖的数量&lt;/li&gt;
&lt;li&gt;FanOut: 出向依赖, 组件内部类依赖外部类的数量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;要求: 每个组件的 I 指标都大于其所依赖组件的 I 指标. 即: 越高层的组件越稳定.&lt;/li&gt;
&lt;li&gt;高阶组件 &gt;&gt; I=0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;稳定抽象原则(SAP)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组件的抽象化程度应与其稳定性保持一致,&lt;/li&gt;
&lt;li&gt;如何使一个趋于无限稳定(I=0)的组件接收变更?&lt;/li&gt;
&lt;li&gt;抽象类(与接口)&lt;/li&gt;
&lt;li&gt;指标&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A(抽象化程度) = Na / Nc&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Na: 组件中类的数量&lt;/li&gt;
&lt;li&gt;Nc: 组件中抽象类和接口的数量&lt;/li&gt;
&lt;li&gt;0 表示没有抽象类; 1 表示只有抽象类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SDP 与 SAP&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I/A 图&lt;/li&gt;
&lt;li&gt;最稳定、包含无限抽象类的组件位于左上角(0,1)&lt;/li&gt;
&lt;li&gt;最不稳定、最具体的组件位于右下角(1,0)&lt;/li&gt;
&lt;li&gt;主序列、痛苦区与无用区&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;痛苦区: 稳定且具体, 涉及很多具体业务但又难以修改&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;典型: 数据库的表结构、工具型类库&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;无用区: 无限抽象、但没有被其他组件依赖, 多为无用代码&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主序列线: 合适的位置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽量让组件贴近主序列线&lt;/li&gt;
&lt;li&gt;最优位置是线的两端&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;D 指标 = |A + I - 1|&lt;/li&gt;
&lt;li&gt;组件与主序列线的距离: 0 表示在主序列上; 1 表示最远位置&lt;/li&gt;
&lt;li&gt;可用“D 指标小于 xx”来指导组件的重构&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用途&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重点分析 D 指标处于平均值的标准差之外的组件: 要么过于抽象但依赖不足, 要么过于具体而被依赖太多&lt;/li&gt;
&lt;li&gt;按时间跟踪每个组件的 D 指标, 及时发现组件架构隐患&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第五部分 软件架构&lt;/h2&gt;
&lt;h3&gt;第 15 章 什么是软件架构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;软件架构师: 坚持一线程序员、更多的编程任务&lt;/li&gt;
&lt;li&gt;实质: 如何将系统切分成组件, 并安排好组件之间的排列关系及互相通信的方式.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目的: 更好地对组件进行研发、部属、运行及维护&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发: 当开发人员组成复杂、系统体量较大时, 清晰的组件和稳定的接口是开发顺利的必要条件&lt;/li&gt;
&lt;li&gt;部属: 一键式的轻松部属应该是设计软件架构的目标.&lt;/li&gt;
&lt;li&gt;微服务架构虽然有利于开发, 但要考虑其部属和通信带来的隐患&lt;/li&gt;
&lt;li&gt;运行: 软件架构对运行的影响较小, 但架构应该将系统中的用例、功能和核心行为设为开发者可见的一级实体, 简化理解&lt;/li&gt;
&lt;li&gt;维护: 成本最高的部分&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主要成本&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;探秘: 对现系统的挖掘, 确定新增功能或被修复问题的最佳位置和方式&lt;/li&gt;
&lt;li&gt;风险: 进行修改时, 对可能衍生出新问题的风险成本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过架构设计(切分、隔离组件)降低以上成本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;策略: 保持可选项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件系统的主要元素&lt;/li&gt;
&lt;li&gt;策略: 业务规则与操作过程, 是系统的价值所在&lt;/li&gt;
&lt;li&gt;细节: 用户、程序员或第三方与策略进行交互的行为, 包括 I/O 设备、数据库、Web 系统、服务器、框架、交互协议等&lt;/li&gt;
&lt;li&gt;架构: 以策略为基本元素, 让细节与策略脱离关系, 并允许在具体决策过程中推迟或延迟与细节相关的内容&lt;/li&gt;
&lt;li&gt;方法: 做高层的策略决策时,尽可能摆脱并推迟对细节的决策(如数据库、框架和设备的选型等)&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;好处&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对策略的信息越多, 对细节的决策越合理&lt;/li&gt;
&lt;li&gt;保持可选项, 可尝试不同的细节决策&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;示范: 设备无关性的应用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 16 章 独立性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;架构的支持目标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用例: 架构的首要目标是为所有系统用例提供支持&lt;/li&gt;
&lt;li&gt;运行: 架构需要支持系统的运行条件&lt;/li&gt;
&lt;li&gt;如为了支持系统的吞吐量和响应时间要求, 使用微服务或多进程、多线程架构&lt;/li&gt;
&lt;li&gt;开发: 将系统切分为隔离良好、可独立开发的组件&lt;/li&gt;
&lt;li&gt;部属: 设计目标是“一键部属”, 减少部属脚本与配置文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;挑战: 无法预知所有用例、运行条件、开发团队结构和部属需求; 并且这些需求会发生变化&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;策略: 保留可选项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用例: 解耦模式&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;水平分层解耦&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UI 界面&lt;/li&gt;
&lt;li&gt;应用独有的业务逻辑&lt;/li&gt;
&lt;li&gt;领域通用的业务逻辑&lt;/li&gt;
&lt;li&gt;数据库&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;垂直解耦: 按用例(如新增、删除)对系统进行垂直切分, 每个用例都可能涉及 UI 界面、业务逻辑和数据库&lt;/li&gt;
&lt;li&gt;运行: 按用例解耦后, 可以将高吞吐量和低吞吐量的组件、UI 和数据库等按需分开部属在不同的环境中&lt;/li&gt;
&lt;li&gt;开发: 解耦后可按水平分层或用例分别独立开发&lt;/li&gt;
&lt;li&gt;部属: 解耦后可独立部署、热更新等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重复的代码不一定是坏事&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用例之间的重复代码: 可能之后的变更速率和变更缘由会完全不同, 必须加倍小心地避免在用例之间复用代码&lt;/li&gt;
&lt;li&gt;水平分层的重复代码: 当数据库结构与 UI 界面的数据接口非常相似时(几乎一定是表面性的重复),也不要省略中间的视图模型,要保持水平分层之间的隔离&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解耦&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模式&lt;/li&gt;
&lt;li&gt;水平分层&lt;/li&gt;
&lt;li&gt;用例解耦&lt;/li&gt;
&lt;li&gt;解耦层次&lt;/li&gt;
&lt;li&gt;源码层次: 源代码模块之间通过函数调用来交互&lt;/li&gt;
&lt;li&gt;部属层次: 部属单元(jar 包、DLL、共享库)之间通过函数调用、跨进程通信、socket 或共享内存通信&lt;/li&gt;
&lt;li&gt;服务层次: 组件之间仅通过网络数据包通信&lt;/li&gt;
&lt;li&gt;解决方案&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单一层次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源码层次: 适合系统只运行在一台服务器上(单体结构), 但之后可能需要进行部属层次和服务层次的解耦&lt;/li&gt;
&lt;li&gt;服务层次: 资源成本、研发成本、人力成本高昂&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态层次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源码层次 -&gt; 部属层次 -&gt; 服务层次&lt;/li&gt;
&lt;li&gt;根据系统开发和部属需要进行变更&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;良好的架构&lt;/li&gt;
&lt;li&gt;允许从单体结构向可部属单元、独立的服务或微服务进行转变&lt;/li&gt;
&lt;li&gt;允许从部属和服务层次回退到单体结构&lt;/li&gt;
&lt;li&gt;在层次转变过程中保持系统的大部分源码不受影响&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 17 章 划分边界&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;划分边界的目的: 尽量将一些决策延后, 并确保这些决策不对核心业务逻辑产生干扰&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统最消耗人力资源的问题: 耦合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尤其是与系统业务需求无关的决策造成的耦合, 如过早决策系统框架、数据库、服务器等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;范例分析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;过早地做出决策去适应一个并不存在的大型服务器集群环境,导致开发成本急剧上升.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;过早地采用一整套域对象服务体系,需要将一整套服务全部运行起来才能进行开发,导致开发效率急剧下降&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;成功案例: 延后数据库相关决策,采用一种与数据库无关的设计,并预留空的数据访问方法,使得开发过程中不需要面对表结构问题、查询问题、数据库服务器问题、密码问题、链接时间等一系列数据库带来的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在何处划分?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GUI 与业务逻辑之间&lt;/li&gt;
&lt;li&gt;数据库与 GUI 之间&lt;/li&gt;
&lt;li&gt;数据库与业务逻辑之间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插件式架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心业务逻辑与其他组件隔离&lt;/li&gt;
&lt;li&gt;其他组件要么是可去掉的, 要么是有多种实现的&lt;/li&gt;
&lt;li&gt;GUI 与数据库都应可作为插件进行替换&lt;/li&gt;
&lt;li&gt;是单一职责原则(SRP)的具体实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 18 章 边界剖析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;跨边界调用: 边界一侧的函数调用另一侧的函数,并同时传递数据&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单体结构/源码层次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单体结构: 各组件合并产生一个单独的可执行文件&lt;/li&gt;
&lt;li&gt;一般利用某种动态形式的多态来管理内部依赖关系&lt;/li&gt;
&lt;li&gt;最简单的调用形式: 低层客户端调用高层服务函数&lt;/li&gt;
&lt;li&gt;当高层组件需要调用低层组件中的服务时,可以运行动态形式的多态来反转依赖关系&lt;/li&gt;
&lt;li&gt;高层组件提供接口&lt;/li&gt;
&lt;li&gt;低层组件实现接口并被高层组件调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;部属层次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跨边界调用方式与单体结构类似, 只是普通的函数调用.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程模型: 单体结构和按部属层次划分的组件都可以采用线程模型&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本地进程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不同进程拥有不同的地址空间, 无法共享内存&lt;/li&gt;
&lt;li&gt;进程间通信&lt;/li&gt;
&lt;li&gt;用某种独立的内存区域实现共享&lt;/li&gt;
&lt;li&gt;socket(最常见)&lt;/li&gt;
&lt;li&gt;一些操作系统提供的方式,如共享邮件、消息队列&lt;/li&gt;
&lt;li&gt;进程间的隔离策略与单体结构类似, 依赖关系始终指向更高层次组件&lt;/li&gt;
&lt;li&gt;高层进程源码中不应包含低层进程的名称、物理地址或注册表键名.&lt;/li&gt;
&lt;li&gt;设计目标: 低层进程作为高层进程的插件&lt;/li&gt;
&lt;li&gt;进程间通信成本相对较高,需要谨慎控制通信次数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统架构中最强的边界形式&lt;/li&gt;
&lt;li&gt;不依赖于具体的运行位置,始终假设服务之间的通信全部通过网络进行&lt;/li&gt;
&lt;li&gt;跨边界通信速度缓慢,尽可能控制通信次数并适应高延时情况&lt;/li&gt;
&lt;li&gt;目标: 低层服务成为高层服务的插件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 19 章 策略与层次&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;策略&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序 = 策略语句的集合&lt;/li&gt;
&lt;li&gt;策略语句&lt;/li&gt;
&lt;li&gt;描述计算部分的业务逻辑&lt;/li&gt;
&lt;li&gt;描述计算报告的格式&lt;/li&gt;
&lt;li&gt;描述输入数据的校验策略&lt;/li&gt;
&lt;li&gt;架构设计&lt;/li&gt;
&lt;li&gt;将策略语句彼此分离, 按变更方式(原因、时间、层次)重新分组(组件)&lt;/li&gt;
&lt;li&gt;将组件重新组合为一个有向无环图, 低层依赖于高层&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;层次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按输入与输出之间的距离来分层, 距离越远层次越高&lt;/li&gt;
&lt;li&gt;高层提供接口, 低层实现接口并依赖高层&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;涉及原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单一职责原则（SRP）、开闭原则（OCP）、共同闭包原则（CCP）、依赖反转原则（DIP）、稳定依赖原则（SDP）以及稳定抽象原则（SAP）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 20 章 业务逻辑&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;应用程序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;业务逻辑&lt;/li&gt;
&lt;li&gt;插件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;业务实体(Entity)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构成&lt;/li&gt;
&lt;li&gt;关键业务逻辑&lt;/li&gt;
&lt;li&gt;关键业务数据: 包含或容易访问&lt;/li&gt;
&lt;li&gt;接口&lt;/li&gt;
&lt;li&gt;实现关键业务逻辑的函数&lt;/li&gt;
&lt;li&gt;操作关键业务数据的属性或函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用例(Usecase)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义输入、输出及产生输出的过程&lt;/li&gt;
&lt;li&gt;描述某种特定应用场景下的业务逻辑&lt;/li&gt;
&lt;li&gt;用例属于低层概念, 依赖于业务实体&lt;/li&gt;
&lt;li&gt;只描述业务逻辑, 不描述交互方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求/响应模型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入输出都是简单的数据结构&lt;/li&gt;
&lt;li&gt;不派生任何 HTTP 接口和用户界面细节&lt;/li&gt;
&lt;li&gt;避免引用业务实体, 即使二者有很多相同的数据&lt;/li&gt;
&lt;li&gt;因为两个对象会以不同原因和速率发生变更&lt;/li&gt;
&lt;li&gt;会违反共同闭包原则(CCP)和单一职责原则(SRP)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 21 章 尖叫的软件架构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;架构设计的主题应该是业务, 而非架构/框架本身&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;推荐阅读《Object Oriented Software Engineering: A Use Case Driven Approach》&lt;/li&gt;
&lt;li&gt;系统的架构图基于用例, 而不是框架&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;良好的架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;围绕用例, 可以在脱离框架、工具和使用环境的情况下完整地描述用例.&lt;/li&gt;
&lt;li&gt;尽可能允许推迟和延后决定细节: 框架、数据库、Web 服务等. 并且容易改变&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Web 只是一种交付手段, 而非架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统应尽量保持它与交付方式之间的无关性&lt;/li&gt;
&lt;li&gt;应该可以将应用程序交付成命令行程序、Web 程序、富客户端程序、Web 服务程序等任何一种形式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;框架是工具而非信条&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;待着怀疑的态度审视每一个框架&lt;/li&gt;
&lt;li&gt;权衡使用框架、保护系统&lt;/li&gt;
&lt;li&gt;保持对系统用例的关注,避免让框架主导架构设计&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可测试的架构设计&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;架构设计应围绕用例展开, 应该可以在不依赖框架、Web 服务、数据库的情况下对用例进行单元测试&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 22 章 整洁架构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;几种架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;六边形架构/端口与适配器架构&lt;/li&gt;
&lt;li&gt;《Growing Object Oriented Software with Tests》&lt;/li&gt;
&lt;li&gt;DCI 架构&lt;/li&gt;
&lt;li&gt;BEC 架构&lt;/li&gt;
&lt;li&gt;《Object Oriented Software Engineering: A Use Case Driven Approach》&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;设计目标: 按照不同的关注点对软件进行切割&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;独立于框架: 框架作为工具而非依赖&lt;/li&gt;
&lt;li&gt;可被测试: 脱离框架、数据库、Web 服务测试&lt;/li&gt;
&lt;li&gt;独立于 UI: UI 变更很容易&lt;/li&gt;
&lt;li&gt;独立于数据库: 轻易替换数据库&lt;/li&gt;
&lt;li&gt;独立于外部机构: 不依赖任何外部接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;整洁架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分层: 中心为高层&lt;/li&gt;
&lt;li&gt;内层: 策略&lt;/li&gt;
&lt;li&gt;外层: 机制&lt;/li&gt;
&lt;li&gt;依赖关系: 由外指向内&lt;/li&gt;
&lt;li&gt;业务实体: 封装关键业务逻辑, 可以是带有方法的对象或一组数据结构和函数的集合&lt;/li&gt;
&lt;li&gt;用例: 特定应用场景下的业务逻辑, 封装了系统的所有用例, 引导业务实体的数据流&lt;/li&gt;
&lt;li&gt;接口适配器: 一组数据转换器, 负责在内部(用例和业务实体)和外部(数据库、Web)之间进行数据转换, 本层内部的同心圆不依赖任何数据库&lt;/li&gt;
&lt;li&gt;框架与驱动程序: 包含所有实现细节(Web 和数据库等), 实现不影响内层, 只有一些与内层沟通的黏合性代码&lt;/li&gt;
&lt;li&gt;跨越边界: 如图像右下角, 控制流从控制器开始, 穿过用例, 最后执行展示器代码&lt;/li&gt;
&lt;li&gt;当用例代码需要调用展示器时, 不能违反依赖关系直接调用, 可以使用依赖反转原则(DIP)来解决.&lt;/li&gt;
&lt;li&gt;跨越边界的数据: 数据结构应独立、简单, 避免直接传递业务实体或数据库记录对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 23 章 展示器和谦卑对象&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;谦卑对象模式: 按照是否难以测试将行为拆分成两组模块, 其中包含系统中所有难以测试的行为的一组模块称为谦卑(Humble)组.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;谦卑对象模式应用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;展示器与视图&lt;/li&gt;
&lt;li&gt;GUI 难以进行单元测试, 但可以利用谦卑对象模式将 GUI 拆分成展示器与视图两部分&lt;/li&gt;
&lt;li&gt;视图: 难以测试的谦卑对象, 代码越简单越好, 只负责将数据填充到 GUI 而不做任何处理&lt;/li&gt;
&lt;li&gt;展示器: 可测试的对象, 负责接收和处理数据, 以便视图将其呈现在屏幕上&lt;/li&gt;
&lt;li&gt;数据库网关&lt;/li&gt;
&lt;li&gt;用例交互器与数据库中间的组件, 是一个多态接口, 包含了应用程序在数据库上要执行的所有操作&lt;/li&gt;
&lt;li&gt;SQL 不应出现在用例层代码中, 需要由数据库网关接口提供, 其实现由数据库层来负责, 这些实现(SQL 或其他数据库提供的接口)属于谦卑对象&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据映射器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ORM(对象关系映射器)只是将数据从关系数据库加载到了对应的数据结构中, 属于数据库层, 是在数据库和数据库网关接口之间构建了一种谦卑对象的边界&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务监听器: 从服务接口中接收并处理数据, 使得数据可以跨服务边界传输. 也属于谦卑对象模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;谦卑对象模式将最难以测试的跨边界的数据交互行为分割出来, 可以大幅提高整个系统的可测试性.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 24 章 不完全边界&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;架构边界的挑战——
引入不完全边界的原因&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建完整的架构边界成本极高: 设计双向多态边界接口、输入输出数据结构、依赖关系管理、分割组件等&lt;/li&gt;
&lt;li&gt;为了应对将来可能的需要, 希望预留边界&lt;/li&gt;
&lt;li&gt;违背YAGNI原则(You aren’t going to need it, 不要预测未来的需要)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构建不完全边界&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;省掉最后一步: 将系统分割为可独立编译、部属的组件之后, 再将其合并起来构建成一个组件&lt;/li&gt;
&lt;li&gt;设计工作量和代码量与构建完整边界相同&lt;/li&gt;
&lt;li&gt;省去了多组件发布管理的工作&lt;/li&gt;
&lt;li&gt;危险性: 组件之间的独立性逐渐降低、隔离弱化&lt;/li&gt;
&lt;li&gt;单向边界: 在设计时就进行必要的依赖反转, 使得跨边界调用保持单向&lt;/li&gt;
&lt;li&gt;危险性: 只能依赖于开发者和架构师的自律性来保证组件的持久隔离&lt;/li&gt;
&lt;li&gt;门户模式: 边界由一个统一的类来定义, 这个类中包含了所有的服务函数列表, 负责将外层的调用传递给外层不可见的服务函数&lt;/li&gt;
&lt;li&gt;危险性: 外层组件传递性地依赖于所有服务函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 25 章 层次与边界&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;本章示例: 将一个简单的小程序逐步扩展为具有系统架构边界的复杂程序&lt;/li&gt;
&lt;li&gt;架构边界可以存在于任何地方, 需要小心审视何时需要设计架构边界&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;困难之处&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完全实现边界需要很高的成本, 且违反 YAGNI 原则, 容易过度设计&lt;/li&gt;
&lt;li&gt;如果事先忽略了某些边界, 后续再添加可能极为困难&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;架构师&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;权衡哪里需要设计架构边界&lt;/li&gt;
&lt;li&gt;权衡需要完整边界 or 不完整的边界&lt;/li&gt;
&lt;li&gt;持续观察系统演进、权衡架构边界成本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 26 章 Main 组件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;负责创建、协调、监督其他组件运转&lt;/li&gt;
&lt;li&gt;最底层、最细节的策略, 没有其他组件依赖于它&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置起始状态、配置信息、加载外部资源, 并将系统控制权交给最高抽象层的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可以以插件形式为系统设计多个 Main 组件对应于不同的配置&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 27 章 服务: 宏观与微观&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;面向服务的架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务只是一种跨进程/平台边界的函数调用, 不一定蕴含架构的意义&lt;/li&gt;
&lt;li&gt;架构是由跨越架构边界的关键函数调用来定义的, 并且必须遵守依赖关系规则&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务的好处谬论&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解耦合&lt;/li&gt;
&lt;li&gt;任何形式的共享数据行为都会导致强耦合&lt;/li&gt;
&lt;li&gt;服务的接口与函数接口类似, 并没有更好&lt;/li&gt;
&lt;li&gt;独立开发部属&lt;/li&gt;
&lt;li&gt;并非服务仅有的特性, 采用单体或组件模式同样可以独立开发和部属&lt;/li&gt;
&lt;li&gt;强耦合的服务并不能真正做到独立开发部属维护&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务与架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统的架构边界在服务内部的组件而不在服务上&lt;/li&gt;
&lt;li&gt;在服务内部应采用遵守依赖关系原则的组件设计方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 28 章 测试边界&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;测试也是一种系统组件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遵守依赖关系原则: 处于最外层, 向内依赖&lt;/li&gt;
&lt;li&gt;测试组件可以独立部署(测试环境)&lt;/li&gt;
&lt;li&gt;支持开发过程, 而非运行过程(往往不会部属到生产环境)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可测试性设计&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脆弱的测试问题&lt;/li&gt;
&lt;li&gt;测试代码与系统强耦合, 系统组件的小变化都需要测试组件做出相应变更&lt;/li&gt;
&lt;li&gt;GUI 是多变的, 通过 GUI 来验证系统的测试一定是脆弱的, 应该让业务逻辑不通过 GUI 也能被测试&lt;/li&gt;
&lt;li&gt;测试专用 API&lt;/li&gt;
&lt;li&gt;拥有超级用户权限, 允许测试代码忽视安全限制、绕过成本高昂的资源(数据库), 强制将系统设置到可测试状态中&lt;/li&gt;
&lt;li&gt;将测试代码从应用程序中分离&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免结构性耦合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果每个产品函数都有一个对应的测试函数, 那么测试套件与应用程序在结构上是紧耦合的, 导致脆弱的测试问题. 测试专用 API 使测试代码与应用程序解耦.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安全性: 具有超级权限的测试专用 API 应该放置在单独的、可独立部属的组件中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 29 章 整洁的嵌入式结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;软件与固件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件本身不会随时间而磨损, 周期很长&lt;/li&gt;
&lt;li&gt;但硬件和固件会随着硬件演进而过时, 进而可能导致软件无法使用.&lt;/li&gt;
&lt;li&gt;固件代码&lt;/li&gt;
&lt;li&gt;对特定硬件平台 API 依赖的代码都属于固件代码, 如未分离业务与系统 API 调用的 Android 开发&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分离固件代码: 延长软件代码的生命周期&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;”程序适用测试“&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果代码只有在特定硬件平台上才能被测试, 那么即使通过了“适用性测试”, 仍不能说其拥有整洁的嵌入式架构. 除非这个产品永远不需要迁移到其他硬件平台&lt;/li&gt;
&lt;li&gt;目标硬件瓶颈: 嵌入式开发面临的特有的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;整洁的嵌入式架构就是可测试的嵌入式架构&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目标硬件瓶颈解决方案&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分层&lt;/li&gt;
&lt;li&gt;硬件、固件、[操作系统]、软件&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;边界&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码与硬件: 边界比较清晰&lt;/li&gt;
&lt;li&gt;软件(操作系统)与固件&lt;/li&gt;
&lt;li&gt;硬件抽象层(HAL): 为软件提供服务, 隐藏硬件实现细节&lt;/li&gt;
&lt;li&gt;软件与操作系统&lt;/li&gt;
&lt;li&gt;操作系统抽象层(OSAL): 隐藏操作系统实现细节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;面向接口编程与可替代性&lt;/li&gt;
&lt;li&gt;模块之间定义接口进行通信&lt;/li&gt;
&lt;li&gt;每一个借口都为平台之外的测试提供替换点&lt;/li&gt;
&lt;li&gt;DRY 条件性编译命令&lt;/li&gt;
&lt;li&gt;问题: 如果程序中多次使用了重复的条件性编译命令来为不同平台启用/禁用一段代码&lt;/li&gt;
&lt;li&gt;方案: 使用硬件抽象层(HAL)隐藏硬件类型, 然后使用链接器或某种运行时加载器进行软硬件组合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第六部分 实现细节&lt;/h2&gt;
&lt;h3&gt;第 30 章 数据库只是实现细节&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据库不是数据模型, 而只是存储数据的工具&lt;/li&gt;
&lt;li&gt;依赖数据库表结构的代码应该被局限在系统架构的最外层的工具函数中&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库溯源: 优化磁盘存储&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件系统: 便于存储和检索文档, 但对文档内容难以关注&lt;/li&gt;
&lt;li&gt;数据库系统: 关注文档/记录的内容/属性&lt;/li&gt;
&lt;li&gt;存储的未来&lt;/li&gt;
&lt;li&gt;基于 RAM, 将数据组织成最合适的数据结构&lt;/li&gt;
&lt;li&gt;基于文件和表格(数据库)的形式被逐渐取代&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统架构不应关心数据在磁盘上如何存储这种实现细节&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;性能考量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能是系统架构的一个考量标准&lt;/li&gt;
&lt;li&gt;数据存储方面的性能是底层问题, 不需要与系统架构相关联&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 31 章 Web 是实现细节&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Web 的振荡式发展&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;将计算资源集中在服务器集群中, 浏览器保持简单&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Web2.0 用 Ajax 和 JavaScript 将很多计算挪到浏览器中执行&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;用 Nodejs 技术将 JavaScript 代码挪回到服务器中执行&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GUI 只是实现细节, 而 Web 是 GUI 中的一种&lt;/li&gt;
&lt;li&gt;作为软件架构师, 需要将其与核心业务逻辑进行隔离&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将 Web 应用抽象为设备无关架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;业务逻辑 -&gt; 一组用例&lt;/li&gt;
&lt;li&gt;用例 -&gt; 输入、处理、输出数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 32 章 应用程序框架是实现细节&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;框架的目的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决框架作者所侧重的一些问题, 而不是解决你的问题——只是这些问题有较大的重合性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单向约定&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发者需要遵守框架的一系列约定&lt;/li&gt;
&lt;li&gt;框架作者不需要遵守什么约定&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;风险&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;框架自身的架构设计可能不正确&lt;/li&gt;
&lt;li&gt;产品的演进可能超出框架提供的能力范围&lt;/li&gt;
&lt;li&gt;框架本身可能朝着我们不需要的方向演进, 被迫进行不必要的升级或悄悄改变了行为&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决方案&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将框架作为实现细节, 不要将其引入内圈&lt;/li&gt;
&lt;li&gt;不要基于框架的基类创建派生类, 可以创造一些代理类作为业务逻辑的插件&lt;/li&gt;
&lt;li&gt;根据依赖关系原则, 将框架作为核心代码的插件&lt;/li&gt;
&lt;li&gt;可以在最外层的 Main 组件中引入、依赖框架&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于不得不接受的框架依赖, 需要慎重决定&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 33 章 案例分析: 视频销售网站&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;识别系统中的各种角色和用例&lt;/li&gt;
&lt;li&gt;角色: 单一职责原则(SRP)&lt;/li&gt;
&lt;li&gt;角色作为系统变更的主要驱动力, 一个角色的变更需求不影响其他角色&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;构造组件架构图&lt;/li&gt;
&lt;li&gt;构建系统架构边界&lt;/li&gt;
&lt;li&gt;分割组件&lt;/li&gt;
&lt;li&gt;每个组件对应一个潜在的独立部署文件, 包含视图、展示器、交互器、控制器文件&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;独立部属&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个组件独立交付部属是否过于繁琐?&lt;/li&gt;
&lt;li&gt;将组件组合为多个交付单元来部属, 如交付为视图、展示器、交互器、控制器和工具类 5 个.jar 文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;依赖关系管理&lt;/li&gt;
&lt;li&gt;控制流: 从控制器输入数据, 经由交互器处理, 再由展示器格式化出结果, 最后由视图展示结果&lt;/li&gt;
&lt;li&gt;依赖关系: 与控制流方向相反, 由低层指向高层&lt;/li&gt;
&lt;li&gt;使用关系: 与控制流一致&lt;/li&gt;
&lt;li&gt;“继承”关系: 与控制流相反&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总结: 架构实现了两个维度上的隔离&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据单一职责原则隔离各个角色&lt;/li&gt;
&lt;li&gt;应用依赖关系原则&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第 34 章 拾遗&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;代码结构设计&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;水平分层&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;层次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web 代码&lt;/li&gt;
&lt;li&gt;业务逻辑&lt;/li&gt;
&lt;li&gt;持久化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在项目初期合适, 不会过于复杂; 一旦软件规模扩展, 就需要进一步进行模块化&lt;/li&gt;
&lt;li&gt;问题: 无法展现具体的业务领域信息&lt;/li&gt;
&lt;li&gt;垂直切分&lt;/li&gt;
&lt;li&gt;按功能、业务概念或聚合根(DDD 术语)切分, 每一类放在一个包中, 以业务概念命名&lt;/li&gt;
&lt;li&gt;水平分层与垂直切分都很不好&lt;/li&gt;
&lt;li&gt;隔离业务领域与实现细节(数据库、框架等)&lt;/li&gt;
&lt;li&gt;端口和适配器模式&lt;/li&gt;
&lt;li&gt;六边形架构&lt;/li&gt;
&lt;li&gt;边界、控制器、实体&lt;/li&gt;
&lt;li&gt;按组件封装&lt;/li&gt;
&lt;li&gt;将一个粗粒度组件相关的所有类放入一个包, 类似于微服务架构, 将 UI 与粗粒度组件分离&lt;/li&gt;
&lt;li&gt;新的组件定义: 在一个执行环境（应用程序）中的、一个干净、良好的接口背后的一系列相关功能的集合&lt;/li&gt;
&lt;li&gt;优点: 一类业务的变更只需要修改一个粗粒度组件&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C4 软件架构模型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统由一个或多个容器组成(Web 应用、移动 App、数据库、独立应用、文件系统等)&lt;/li&gt;
&lt;li&gt;容器包含一个或多个组件&lt;/li&gt;
&lt;li&gt;组件包含一个或多个类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将代码分散到不同的代码树&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如端口与适配器架构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例 1&lt;/li&gt;
&lt;li&gt;业务代码树: 所有技术和框架无关的代码&lt;/li&gt;
&lt;li&gt;Web 源代码树&lt;/li&gt;
&lt;li&gt;持久化源代码树&lt;/li&gt;
&lt;li&gt;例 2&lt;/li&gt;
&lt;li&gt;业务(Domain)代码(内部)&lt;/li&gt;
&lt;li&gt;基础设施(Infrastructure)代码(外部)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;中心思想: 要将架构设计映射到具体的代码结构上&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;思维导图&lt;/h2&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/3457995e0cfaad5f5403c78a3c1797c5/044d8/CleanArchitecture.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 877.2151898734178%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAACvCAYAAAD9hP67AAAACXBIWXMAABYlAAAWJQFJUiTwAAAL7ElEQVRo3p2byW9jWRXG8w/yHyDECtESEmpALVoNEmoJFggQYtMNGxatlrolFmzYsCmpKKqTqlSqkso820lsJ07iOGNVbOeg30194fj63jfE0tPz+L0zfGe45z5PmXvc3d09PL+5ubGjoyN7/vy5PXnyxJaWlh6+oyP1mIrBbm9v7fj4OJwHg4HNzc3Z/Py8ra2t2bt37yYunAT0V0Syq6urcFxcXIT3m81mkHB3d9dGo5HFvymU8P379+E8HA4D6OXlpS0sLNjLly/t9evXY1JmAf2H/EBS6AKrq6u2vr5um5ubpWpP+Q8BSv0AKbvdru3v71ur1QqS50ALATmw4+npqR0cHATHYM/r6+v6gHi51+s9eLvT6QQJ9d3aKgPEa9Q7Pz8PkuJlr25tCXnNAZXgZqPRsHa7XShlFhA15XXAdnZ2JhxWC5AzakIVSL21tTXmjFo25MyPUXVjY8MWFxcDYErCGHgq/kK/37fDw8Nw5oFD8O7y8nIgdxEHk4AAyCkKvbOzM9vb2wvSQh8+qyQhqgLIa9TjOaDXNzfBw2/fvg325AKVAPGsl5D3sSWgawtv7MWzp7Y8N2vX5/3HAfIgyfbPzqzTbln74MBOjrtmd6NqtPGAqIxj8DRx/PTpU/tuejo8L8rcWUBFCPaC1NiPoygxFALqPQDIMnAR2nCRyrHsAWVHUhdJAROQxX0JqCUhmRoQeEeUYE/Pv9IilXIK6sI/SgAxXcS/SrThNRlaYadwfJSEGB8JiWuqHsBlDkkCIoUyNXFMGUBtYlk5srKEeJHIIKHiXexIpkFC1MZBtSQEEDDvFC4Aod+8eRO8neqDsoDqa7wNkerFixc2Ozsb6klZwzQVtyEeEClPTk5CpJC2sGUtYntAnlNTcBLdwsrKSuCi93QtQG8GAMkySIvnK2ebGBDqAEQsA4aD4GURfbKASl/YDcqoOMW0qSwhgKirPpEIApxCFbcklQF5zSEK4RiaTryec04hINLde/o8SAh1VlZWC5vOQkBAhoNbs7uh9Xpntr6+asvLi2OOqyzhcDiy66tLa+4f29pWx96/u7T5xS3b3Dl8HG0Gw2Eol9uNI5ue24SRtrDStNXNzgcN0v3NBCB8+//iB1uNwvGfmXW7vb2x3EIpmxxIAKQugCEw+bDdbtnzl+t22uvZ+Xk/2NaTOyshgOQ/0QTHYAK4d3jYCrFMKeCieL8UEDoQt3pPVY5Ht3scihXgMQezgHxRgHBQgEiDpMo6hCIxXSphChCpSQq0I1qnkHEwR4o6WUCFHsCAUpOxn3rE1JqP81TcxyjNCxBvcsaz9DcAppa6Ok8AqrJ5CcVRdbG5Gj0hISlJxhagUhcqK8nCTZ6TfGXTJCAf8AMBUk/UZ6tQAaBSgPSYxBeuCUCWsV4V3gMYqaAOJtne3n6QKg7DMUDxTe8pJ95TiP5wEGyHhFwkps2EhAAqOQgQLl5fX9loROa+ZwFSxhImAbEXiWEMcDCwy4sL6/VO7fLqItjMr1R5jQZJlQHEVjGVyDBH/a71L/vWbDRtt7H70NVqLZ0ElPHj1VUfwONuoBTqojbtncidVRnAVNuLlGe9s1A+kYzwjPNhUkLAfNvrvYedkAw+Qps422QB43UKTiKxEnZ87h1R6mV+oEys9+Edh1IZ4CRaLiCnaAWblNDHJZJoDoYdcRgJljQGINLzfS5YCkhi0GupyHtIxXtabog+WS+rCVLQK/CRgs8pYnibJAKwilnWhlptqvPiNUCEJNwjHzJPpFiRSOIWeQwQG8WDIGUhqAL/dAFqTDytm5AQI2t+KAnVTaAmEpJUkcwnh2yRQkIBqpYAhnR4FvthO6SK2+Ksl1WL+YGWFeRIeRzpUoOgbHLwgH58iu0ARsp4bpNVGcbry77QQyVUxbMQ2mekwv6QsBMgQPwQMJGYuhxno0JARYUiBTA+A/jVq1fBMbmephTQdwwAshqF1IAWzbInCr0AUV02xBF4G3VrjVnwpPIcYFIbQIo8EkLsXOdVCqiRAaCEHaBk7CI7ToX0Hq44CchnSIkNSVN4OZ59ZfcC7h+DJCDSQRsSQlwiJiTsHF3Zf2da9t1sx+bmW2OAPCchkFUAo0gplrMqr2/17Ot/rNq3/9ywf/17wwaDcQmRiORA6qeW4OnS9XJKZeih1oStD3Z+SKylMweWWIMhqZ7QG48UVOOMM9T564K1I0U2hDYkV+/dyoA+23hAwo3pUm5uUyl9CZCEiqcBxcMKvdwCMpu+FClECcTG0+RDUhlSY9tSCQH02UaLR5IqjgEQMJWEFH0mnKK07wu7MrWSa2WVtUMh2mhcxYXUganU5ga8E2s93zlokKFRFapiS8DxeKnKHhApBKj1nXKh73kKVY4BeR+qMPyRDT1AqZcBiwE5QxVUlcPiKKlsQ79RiJQQXJWwUuh5wND5n50FABxA+kLSoiJfakN1rPCQXIiEtXYeU15GIp+ta6WvlA0htVapGpo/ClCbM1rNw0PUTk2UsgufmDbaXm+126Emtz7kw1QsJwHVunEGTJFysL9nSwvz1u20x5ZqpbGM3QAiqWrFHt67OLfBZd+ueyfW3Nm2xaWlQPTU/GtCQl0VW2nDkCXt5taWNZp71mg0g7cxjSd4FlC04DkHXsbD62trtry0FOjjy0BhcvCA8rI8jRlIW5A73rSuJKFqiwZBFCkOTU0qTTg9oCIFSSnwdF+EoPamKk3aYwl5jnTaBUJtldpcwZ8Y6sbtnEamHGGuHcVyIbFVi/0WEslBy7K70V29SNGQR14OlOl2A/+2dratc9h5qHpcyBM7uw3nOwceX3/zjX38y1/YJ7/5zH77+9/ZF19+EeoLCRdHxcu0iV0z1Q2d//K3v9pPvv89++lHP7Cff/qp/flPfwzl4NmzZ+Hs91kK73MQ4N+/+sp+9OMf2s8++dh+9evP7A+ffx5imX4RKVFbmQmBCgFHd6MQFUura7a2sWE7O9vWbrXs+OQkvI/X6R3ZpqN2E1WlEvK62WhY60PnoO1NfU8zxqSX45tPfBcGhagtbBiSvZWIK98r4m+G0qYh5J6ZmQmlIF5aJL2cAsTomhFCF27bmp6ertYs5VTmYDVKF0bjicq5nbNCp2iYRtdF0w6QRqqVQi8lIVSQZICidtGGYaENteDWIhy7oTpScqTuKihUWRFAHiRuVQIUJfEQvVRlzRCRDO8CCIhm2UhZWWVlb8jMAMOnfs24U01nqQ0BQTJIjR0VkinHVFIZUqd2bCuVgFhlDuzFOhknxLvftWOZcMOr2kuBMn7EUlpGU8TWBpdmX2VtcRZQo1E5BrpgSxyUmsZXIraGkjgG3iEhqhPbuXtvKqlM54AdOfwGTi1A3xJr1EL4xY6pzEONWUQfSE1i5eB5bRsqG0MdraY0rtKuRS0J/WBc42dyIcUdkkOf2qEnKQDEhiRYPKzdidLlbSqW1bSTbTQVye1+V6YNeU/jKoBT6+bS5KCBrqodHMQhmm7mJiOFd+pq51F21O2/mm/7SVSphL7vRsqLsPvYC3kRtXEO0tYC9Kpo3xQ70t9wruVl34Rqs1pnSI50qbVzKSBpjBhGVZziB261vayl2f2G63mQDC76DevKkaKVFD/EszgB+mhHPGfr0kjhPeii+4n9hK723c7qHFBXs2xAczu3lQo90qEqQCJ00ei50IZQRmQmdQFK4/6oqudvjdG9sCQIPP1oCXkOsCoeIVd2p+nE7dO+FdFOLWqzsKGli++STObD1GTEq0w+1ECt8k3yHlC00QoJQG2D4ByRvpDYfv6FWiKwkgP0wdsceDq3BTKVWh5oeKHRlWZiAAOopim78El1o7qNXzUYtfU/FdT2+wJJwNjQurruPyQ5aOfROyyrcuqvOVq6AqgtdSTTKiubsYsApT5gqO3Xxo8C5DV2pP2gc0Dl0n8u5ADlcTmETK12ruKu2SSgJAQU6SB30Z82soB+O5h4xsP6v1Rqw3+sSOUA/YYr0YPaiufcPDsLqCm7tjoAJ/w0vtcdLsmBZC5a5GkiRrfJoD7JlrLg+ZgFjNXW30k4lHRJDiJ4JRt6Y2sh7sMtFa4C/B8OhyBNRMOINgAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Clean Architecture 思维导图&quot;
        title=&quot;Clean Architecture 思维导图&quot;
        src=&quot;/static/3457995e0cfaad5f5403c78a3c1797c5/f058b/CleanArchitecture.png&quot;
        srcset=&quot;/static/3457995e0cfaad5f5403c78a3c1797c5/c26ae/CleanArchitecture.png 158w,
/static/3457995e0cfaad5f5403c78a3c1797c5/6bdcf/CleanArchitecture.png 315w,
/static/3457995e0cfaad5f5403c78a3c1797c5/f058b/CleanArchitecture.png 630w,
/static/3457995e0cfaad5f5403c78a3c1797c5/40601/CleanArchitecture.png 945w,
/static/3457995e0cfaad5f5403c78a3c1797c5/78612/CleanArchitecture.png 1260w,
/static/3457995e0cfaad5f5403c78a3c1797c5/044d8/CleanArchitecture.png 3366w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[GTD之二：实践要点]]></title><description><![CDATA[经过两个月的 GTD 实践，发现 GTD 其实并不是想象中那么高深和繁琐，只要能做到两个关键点，就可以使整个流程顺利执行下来。 关键点一：收集一切 GTD 的核心目的是解放大脑、提升效率，一旦决定使用 GTD…]]></description><link>https://hrayd.github.io/gtd-2/</link><guid isPermaLink="false">https://hrayd.github.io/gtd-2/</guid><pubDate>Thu, 20 May 2021 22:00:00 GMT</pubDate><content:encoded>&lt;p&gt;经过两个月的 GTD 实践，发现 GTD 其实并不是想象中那么高深和繁琐，只要能做到两个关键点，就可以使整个流程顺利执行下来。&lt;/p&gt;
&lt;h2&gt;关键点一：收集一切&lt;/h2&gt;
&lt;p&gt;GTD 的核心目的是解放大脑、提升效率，一旦决定使用 GTD 系统，就应该完全信赖它，将自己的一切想法第一时间纳入系统：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个新的工作任务&lt;/li&gt;
&lt;li&gt;一个新的学习计划&lt;/li&gt;
&lt;li&gt;一个待办事项&lt;/li&gt;
&lt;li&gt;一篇待阅读文章&lt;/li&gt;
&lt;li&gt;一个刚刚看到的待深入了解的新词汇&lt;/li&gt;
&lt;li&gt;一个学习或生活小窍门&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;就是两个字：一切。将一切想法和事务先放入收集篮并释放大脑，集中精力于当前事务。&lt;/p&gt;
&lt;h2&gt;关键点二：每周回顾&lt;/h2&gt;
&lt;p&gt;这是整个 GTD 系统中唯一需要花费一整段时间的步骤，需要做的有三点（详情参照《GTD 之一：GTD 的理论笔记》）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;清空 &lt;strong&gt;收集篮&lt;/strong&gt;：将收集篮中的事务逐个理清，纳入系统；&lt;/li&gt;
&lt;li&gt;回顾未完成的 &lt;strong&gt;日程表&lt;/strong&gt; 和 &lt;strong&gt;下一步行动清单&lt;/strong&gt;，重新纳入系统；&lt;/li&gt;
&lt;li&gt;回顾 &lt;strong&gt;将来/也许清单&lt;/strong&gt;，决定是否将其纳入系统并开始执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于我个人来说，每周的收集篮大约新增 10 条左右，逐条进行分解和规划，一般在一个小时左右处理完毕，处理完毕后基本上也就将下周任务规划好了。&lt;/p&gt;
&lt;h2&gt;关于工具&lt;/h2&gt;
&lt;p&gt;我个人认为选择工具（此处特指 APP）有以下要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;覆盖个人的全平台；&lt;/li&gt;
&lt;li&gt;APP 数量尽可能少，尽可能集中在三个 APP 以内：如一个清单类、一个导图类、一个笔记类；&lt;/li&gt;
&lt;li&gt;支持标签系统，根据所处场景可以快速找到当前可执行任务&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;标签系统示例&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;地点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;办公室&lt;/li&gt;
&lt;li&gt;家中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时长：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;10 分钟&lt;/li&gt;
&lt;li&gt;30 分钟&lt;/li&gt;
&lt;li&gt;1 小时&lt;/li&gt;
&lt;li&gt;3 小时&lt;/li&gt;
&lt;li&gt;1 天&lt;/li&gt;
&lt;li&gt;3 天&lt;/li&gt;
&lt;li&gt;1 周&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动作类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阅读&lt;/li&gt;
&lt;li&gt;代码&lt;/li&gt;
&lt;li&gt;思考&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[GTD之一：GTD的理论笔记]]></title><description><![CDATA[引言 网络上关于 GTD 系统的文章琳琅满目，但大多都经过了作者的主观简化或加工，本人在最初学习 GTD 时参考了大量的知乎问答和博客专栏，但总是不得要领，没多久 GTD 就变成了单纯的 Todo…]]></description><link>https://hrayd.github.io/gtd-1/</link><guid isPermaLink="false">https://hrayd.github.io/gtd-1/</guid><pubDate>Tue, 09 Mar 2021 22:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;引言&lt;/h2&gt;
&lt;p&gt;网络上关于 GTD 系统的文章琳琅满目，但大多都经过了作者的主观简化或加工，本人在最初学习 GTD 时参考了大量的知乎问答和博客专栏，但总是不得要领，没多久 GTD 就变成了单纯的 Todo 清单，接着就是未完成事项越攒越多，被催促的焦虑感越来越强，最终系统“爆炸”、崩溃。&lt;/p&gt;
&lt;p&gt;在若干次失败之后，决定从头开始把 GTD 作为一门科学的方法论认真学习一遍。“GTD”系统源于一本书籍——《Getting Things Done》，中文书名《搞定》，本文系本书的读书笔记。&lt;/p&gt;
&lt;h2&gt;读书笔记&lt;/h2&gt;
&lt;p&gt;阅读本书用时约 6 小时，本书分为三个部分，Part1 部分的前三章为全书理论核心，基本囊括了 GTD 系统的所有知识；Part2 部分从第 4 章至第 10 章，是将 GTD 每个阶段的具体做法详细讲述了一遍；Part3 部分对 GTD 进行了总结和评价。&lt;/p&gt;
&lt;h3&gt;8 个容器&lt;/h3&gt;
&lt;p&gt;所谓容器，就是事务清单，可以是记录在随身笔记本上的纸质清单，可以是简单便携的手机备忘录，也可以是专业的 GTD 软件产品。&lt;/p&gt;
&lt;p&gt;GTD 系统总的来说是一套周期性流水线式的事务管理方法论，其中涉及 8 个清单，一般的专业 GTD 工具也就是能将以下容器有机结合起来的软件，个人推荐新手使用纸质清单+手机日历的方式来熟悉和执行 GTD。&lt;/p&gt;
&lt;p&gt;8 个容器列举如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;收集篮：未经处理过的原始“材料”，定期清空&lt;/li&gt;
&lt;li&gt;项目清单：决定执行、且需要多步执行的事务清单&lt;/li&gt;
&lt;li&gt;项目计划本：对项目清单中每个项目的行动方案规划&lt;/li&gt;
&lt;li&gt;也许/将来清单：以后可能执行的事务清单&lt;/li&gt;
&lt;li&gt;日程表：记录指定日期或时间需要执行或提醒执行的事务&lt;/li&gt;
&lt;li&gt;下一步行动清单：可执行的待办事项清单&lt;/li&gt;
&lt;li&gt;等待清单：需要等待他人完成才能继续执行的待办事项清单&lt;/li&gt;
&lt;li&gt;参考资料库：个人资料库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在实际的执行中，这 8 个清单也可以进行简化处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;收集篮需要随身携带随手记录，可以用随身小本或手机备忘录作为载体；&lt;/li&gt;
&lt;li&gt;项目清单、项目计划本、也许/将来清单、等待清单都是在每周回顾中对事务进行分析和规划，可以使用一个笔记本或电子版的思维导图或树状清单来实现；&lt;/li&gt;
&lt;li&gt;日程表可以直接使用手机自带日历或全平台的日历 APP(如 outlook)；&lt;/li&gt;
&lt;li&gt;下一步行动清单即传统的待办事项，任何一个有提醒功能的待办事项 APP 都可以；&lt;/li&gt;
&lt;li&gt;参考资料库其实是 GTD 系统之外的个人知识库，可以使用任何带标签和搜索功能的笔记 APP 来实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;事务的横向管理&lt;/h3&gt;
&lt;p&gt;事务的横向管理即对多个事务的并行管理，是 GTD 系统的核心。其流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;收集：收集一切未竟之事加入【收集篮】，清空大脑&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;理清：抽出两个小时以上的时间块，对【收集篮】的事务挨个执行以下述流程进行清空：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;想清楚事情具体是什么，一个目标？一项工作？一次活动？一些资料？&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;事情需要采取行动吗？是转 3，否转 9；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;需要多步行动才能完成吗？若是，加入【项目清单】转 4，否转 5；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;将事务划分为有序或无序的多步行动计划，加入【项目计划本】，转 5；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;明确下一步行动，写入【下一步行动清单】，转 6；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;下一步行动是否可以在两分钟内完成？若是，立即执行，然后继续下一步行动，若否转 7；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;下一步行动是否需要等待他人完成？若是，加入【等待列表】，并在【日程表】中设定下一次跟进时间，若否转 8；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;下一步行动是否在指定日期或时间完成？若是，加入【日程表】；若否，加入【也许/将来清单】；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;是否希望在将来采取行动？若是，加入【也许/将来清单】，若否转 10；&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;是否是有意义的参考资料？若是，加入【参考资料库】；若否，扔进垃圾箱。&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每周回顾：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;执行整个理清流程，清空收集篮，更新各清单容器&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;回顾未完成的【日程表】和【下一步行动清单】，重新纳入系统&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;回顾【也许/将来清单】，决定是否开始执行&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;依据场景（办公室、家中）、时间约束、个人状态、重要性等来选择执行&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;可以通过事先给项目、行动打标签的形式来筛选&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;优先执行当日【日程表】、【下一步行动清单】与其他突发紧急事件&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;事务的纵向管理&lt;/h3&gt;
&lt;p&gt;所谓纵向管理，即对单个事务流程的管理，由于每个人的事务所处的领域、规模、专业程度等因素天差地别，很难总结出一套通用的方法，而 GTD 对于事务纵向管理的描述我个人认为过于泛泛而谈，意义有限。但还是将书中内容记录如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务纵向管理的目标：将事务纳入 GTD 系统，清空大脑。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;哪些事务需要计划？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;80%简单的事务：直接列出行动清单，概括预期结果与各阶段行动步骤；&lt;/li&gt;
&lt;li&gt;15%复杂的事务：运用参考资料或辅助工具规划事务；&lt;/li&gt;
&lt;li&gt;5%需要认真权衡的事务：实施如下 &lt;strong&gt;自然计划法&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;自然计划法&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;定义目标与限定条件&lt;/li&gt;
&lt;li&gt;展望成功场景或结果&lt;/li&gt;
&lt;li&gt;头脑风暴/集思广益&lt;/li&gt;
&lt;li&gt;组织整理，将事务划分为有序或无序的若干步骤&lt;/li&gt;
&lt;li&gt;明确 &lt;strong&gt;下一步行动&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;GTD 的执行方案建议&lt;/h2&gt;
&lt;p&gt;首先需要牢记 GTD 的目标：&lt;strong&gt;将一切事务纳入 GTD 系统，清空大脑&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为了达到这一点，一个可随取随用的 &lt;strong&gt;收集篮&lt;/strong&gt; 至关重要，可以选择随身手帐、手机备忘录或其他 APP，我的建议是选择一个全平台的清单应用，当然这个“全平台”是相对个人来说的，我自己日常平台 Mac+iPhone+iPad，收集篮就用 iOS 自带备忘录来做（后来改成了 Things3）。&lt;/p&gt;
&lt;p&gt;另一个重要容器是 &lt;strong&gt;下一步行动清单&lt;/strong&gt; ，理论上任何 Todo 类应用都符合要求，但我建议选择全平台（同收集篮）、支持标签、支持设定开始和截止时间、支持三层以上嵌套的树形清单，如果能支持同步到日历就更好了，可以把 &lt;strong&gt;日程表&lt;/strong&gt; 也合并到一起了。我之前使用 iOS 自带待办事项，但功能上还是过于简陋，就选择了很久以前买的 Things3 来用，一些优秀的待办事项 APP 如 Microsoft ToDo、滴答清单、Any.do、Sorted 等都可以满足要求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;也许/将来清单&lt;/strong&gt;和&lt;strong&gt;等待清单&lt;/strong&gt;也可以合并到待办事项 APP 中，与下一步行动清单的区别是，它们处于等待执行的状态，在每周回顾中进行重新思考，决定执行时再将其转移到项目清单或下一步行动清单中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;项目清单&lt;/strong&gt;、&lt;strong&gt;项目计划本&lt;/strong&gt; 我是使用思维导图来做的，它们的主要任务是在每周回顾中对项目进行规划和分解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料库&lt;/strong&gt; 使用任何笔记类软件都可以，我个人是印象笔记长期用户，也可以选择 OneNote、语雀、Notion 等，我的建议是：至少要支持标签系统、全局搜索和本地数据库。&lt;/p&gt;
&lt;p&gt;当然，在对 GTD 系统熟悉和进阶到一定程度后，也可以选择更为专业的 Omnifocus 神器，我在 Mac 端试用过一段时间，相当满意，但全平台的价格劝退了我。。等以后觉得这套 GTD 系统值得了再做考虑吧。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[HTML5技术扫盲]]></title><description><![CDATA[元素 语义元素 HTML 语义化标签              音视频元素   表单优化：内置数据校验 校验属性： :   : 正则校验   校验效果 通过：CSS 伪类  ，提交数据 不通过：CSS 伪类  ，显示错误信息并阻止提交 iframe…]]></description><link>https://hrayd.github.io/html5/</link><guid isPermaLink="false">https://hrayd.github.io/html5/</guid><pubDate>Mon, 11 May 2020 22:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;元素&lt;/h2&gt;
&lt;h3&gt;语义元素&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HTML 语义化标签&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;article&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;aside&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;details&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;figcaption&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;figure&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;footer&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;header&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;main&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;mark&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;nav&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;section&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;summary&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;time&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;音视频元素&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;表单优化：内置数据校验&lt;/h3&gt;
&lt;p&gt;校验属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt;: &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input type=&amp;quot;email&amp;quot;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;required&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;pattern&lt;/code&gt;: 正则校验&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;min / max&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;minlength / maxlength&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;校验效果&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过：CSS 伪类 &lt;code class=&quot;language-text&quot;&gt;:valid&lt;/code&gt; ，提交数据&lt;/li&gt;
&lt;li&gt;不通过：CSS 伪类 &lt;code class=&quot;language-text&quot;&gt;:invalid&lt;/code&gt; ，显示错误信息并阻止提交&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;iframe 增强安全性和渲染&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;sandbox&lt;/code&gt; 对 frame 中的内容添加额外限制，如 &lt;code class=&quot;language-text&quot;&gt;allow-downloads&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;allow-same-origin&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;allow-scripts&lt;/code&gt; 等&lt;/li&gt;
&lt;li&gt;seamless: 无缝嵌入 iframe&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;srcdoc&lt;/code&gt; 直接嵌入内联 HTML 文本，如:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; iframe &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;iframe&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
iframe&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;srcdoc &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&amp;lt;!DOCTYPE html&gt;&amp;lt;p&gt;Hello World!&amp;lt;/p&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;
document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;body&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;iframe&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;MathML&lt;/h3&gt;
&lt;p&gt;参考 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/MathML/Authoring&quot;&gt;MDN-MathML&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;支持使用 MathML 书写数学公式：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;html&quot;&gt;&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;math&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;msqrt&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;mn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;2&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;mn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;msqrt&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;math&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;通信&lt;/h2&gt;
&lt;h3&gt;WebSockets&lt;/h3&gt;
&lt;p&gt;客户端和服务器建立持久的 TCP 连接，用得比较多了不再赘述。&lt;/p&gt;
&lt;h3&gt;Server-Sent Events(SSE)&lt;/h3&gt;
&lt;p&gt;允许服务器向客户端推送事件，可用于数据仪表盘、实时股票价格展示等场景。&lt;/p&gt;
&lt;h3&gt;WebRTC&lt;/h3&gt;
&lt;p&gt;浏览器之间建立点对点通信，可用于实时音视频和数据共享等场景。&lt;/p&gt;
&lt;h2&gt;离线与存储&lt;/h2&gt;
&lt;h3&gt;在线/离线事件&lt;/h3&gt;
&lt;p&gt;读取属性值: &lt;code class=&quot;language-text&quot;&gt;navigator.online: boolean&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;ononline&lt;/code&gt; / &lt;code class=&quot;language-text&quot;&gt;onoffline&lt;/code&gt; 事件注册：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件注册：在 window, document 或 document.body 上 &lt;code class=&quot;language-text&quot;&gt;addEventListener(&amp;quot;ononline&amp;quot;, fn);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;事件函数: &lt;code class=&quot;language-text&quot;&gt;document.[body.]ononline = function(){...}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;内联事件: &lt;code class=&quot;language-text&quot;&gt;&amp;lt;body ononline=&amp;quot;fn1()&amp;quot; onoffline=&amp;quot;fn2()&amp;quot;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;DOM Storage&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;LocalStorage：同域跨浏览器窗口和选项卡共享&lt;/li&gt;
&lt;li&gt;SessionStorage：仅本次会话可用&lt;/li&gt;
&lt;li&gt;GlobalStorage(仅 Firefox)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;IndexedDB&lt;/h3&gt;
&lt;p&gt;用于在浏览器端存储大量结构化数据的事务型数据库系统。&lt;/p&gt;
&lt;p&gt;可以和 &lt;strong&gt;Web Workers&lt;/strong&gt; 结合使用以提高性能。&lt;/p&gt;
&lt;p&gt;可用于构建 &lt;strong&gt;PWA&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;File API&lt;/h3&gt;
&lt;p&gt;文件上传：&lt;code class=&quot;language-text&quot;&gt;&amp;lt;input type=&amp;quot;file&amp;quot; multiple onchange=&amp;quot;handleFiles(this.files)&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ObjectURL:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;window.URL.createObjectURL(file)&lt;/code&gt; 创建 ObjectURL 使得文件可以通过 URL 来引用(如 a、img 元素等)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;window.URL.revokeObjectURL(objURL)&lt;/code&gt; ObjectURL 使用完毕后应释放&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;多媒体&lt;/h2&gt;
&lt;p&gt;上文已提到过的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; 与 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;WebRTC&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Camera API&lt;/h3&gt;
&lt;p&gt;调用系统自带相机: &lt;code class=&quot;language-text&quot;&gt;&amp;lt;input type=&amp;quot;file&amp;quot; id=&amp;quot;take-picture&amp;quot; accept=&amp;quot;image/*&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;Track 和 WebVTT&lt;/h3&gt;
&lt;p&gt;用于时序文本或其他基于时间的数据, 如视频字幕等.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;track&amp;gt;&lt;/code&gt;元素作为 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;video&amp;gt;&lt;/code&gt; 元素的子元素,用于指定时序文本字幕.&lt;/p&gt;
&lt;p&gt;WebVTT 表示 Web 视频文本字幕格式(.vtt).&lt;/p&gt;
&lt;h2&gt;图像与效果&lt;/h2&gt;
&lt;h3&gt;Canvas Text API&lt;/h3&gt;
&lt;p&gt;新增 &lt;code class=&quot;language-text&quot;&gt;fillText()&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;strokeText()&lt;/code&gt; 方法&lt;/p&gt;
&lt;h3&gt;WebGL 3D&lt;/h3&gt;
&lt;p&gt;用于特定领域, 这里不做详述.&lt;/p&gt;
&lt;h3&gt;SVG&lt;/h3&gt;
&lt;p&gt;基于 XML 语法的矢量图, 可用于绘制简单的 LOGO 或流程图绘制等场景.&lt;/p&gt;
&lt;h2&gt;性能与集成&lt;/h2&gt;
&lt;h3&gt;Web Workers&lt;/h3&gt;
&lt;p&gt;创建后台线程执行一个 JS 文件, 一般用于执行大量耗时的计算任务.&lt;/p&gt;
&lt;h3&gt;XMLHttpRequest Level 2&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;支持 &lt;code class=&quot;language-text&quot;&gt;timeout&lt;/code&gt; 超时设定&lt;/li&gt;
&lt;li&gt;支持使用 FormData 对象管理表单数据&lt;/li&gt;
&lt;li&gt;支持文件上传&lt;/li&gt;
&lt;li&gt;支持跨域请求&lt;/li&gt;
&lt;li&gt;支持获取二进制数据&lt;/li&gt;
&lt;li&gt;支持数据传输进度信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;History API&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;window.history&lt;/code&gt; 对象提供了一些有用的方法来操作浏览器访问历史:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;history.back()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;history.forward()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;history.go()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ContentEditable&lt;/h3&gt;
&lt;p&gt;可编辑元素, 可用于实现富文本编辑器, 详情查看另一篇文章 &amp;#x3C;在线编辑器实现浅析&gt;.&lt;/p&gt;
&lt;h3&gt;拖拽 API&lt;/h3&gt;
&lt;p&gt;用于实现拖拽元素, 主要包括 &lt;code class=&quot;language-text&quot;&gt;ondrop&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;ondrag&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;ondragstart&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;ondragend&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;ondragenter&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;ondragleave&lt;/code&gt; 等事件及相关属性方法.&lt;/p&gt;
&lt;h3&gt;焦点管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;document.activeElement&lt;/code&gt; 查找当前聚焦的 Element&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;document.hasFocus&lt;/code&gt; 判断当前元素是否是焦点&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;基于 Web 的协议处理程序&lt;/h3&gt;
&lt;p&gt;实现在 Web 中可以使用非 HTTP 协议将网页链接到其他资源, 如发邮件等.&lt;/p&gt;
&lt;p&gt;属于特定领域功能, 用到时再研究.&lt;/p&gt;
&lt;h3&gt;动画渲染控制&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;window.requestAnimationFrame(callback)&lt;/code&gt; 执行动画, 并在下一次浏览器重绘前调用 callback.&lt;/p&gt;
&lt;p&gt;一般 callback 会更新动画, 用于在不同的渲染时机中触发不同的动画.&lt;/p&gt;
&lt;h3&gt;全屏 API&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;element.requestFullscreen()&lt;/code&gt;
&lt;code class=&quot;language-text&quot;&gt;document.exitFullscreen()&lt;/code&gt;
&lt;code class=&quot;language-text&quot;&gt;document.onfullscreenchange&lt;/code&gt;
&lt;code class=&quot;language-text&quot;&gt;document.onfullscreenerror&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;鼠标锁定 API&lt;/h3&gt;
&lt;p&gt;使鼠标指针不离开指定区域, 如游戏场景中, 鼠标指针移到最左侧后, 鼠标不会移出游戏窗口, 而是保持在边缘移动画面.&lt;/p&gt;
&lt;p&gt;兼容性问题: 只有 Chrome 和 Firefox 实现了有限功能.&lt;/p&gt;
&lt;h2&gt;设备访问&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Camera API 见上文&lt;/li&gt;
&lt;li&gt;鼠标锁定 API 见上文&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;触摸事件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;TouchEvent 界面触摸状态发生变化时的事件回调&lt;/li&gt;
&lt;li&gt;Touch 单个触摸对象&lt;/li&gt;
&lt;li&gt;TouchList 一组触摸对象, 如多点触摸时&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;地理位置 API&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;navigator.geolocation&lt;/code&gt; 对象提供了一套地理相关 API:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Geolocation.getCurrentPosition()&lt;/code&gt; 获取设备当前位置&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Geolocation.watchPosition()&lt;/code&gt; 设备位置改变时的触发事件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;设备方向&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;deviceorientation&lt;/code&gt; 设备方向改变时的触发事件&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;devicemotion&lt;/code&gt; 设备移动时的触发事件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;CSS&lt;/h2&gt;
&lt;h3&gt;Background&lt;/h3&gt;
&lt;p&gt;已经用得很普遍了.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;box-shadow&lt;/code&gt; 阴影&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;background&lt;/code&gt; 属性支持多背景&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Border&lt;/h3&gt;
&lt;p&gt;同样早就用过&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;border-image&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;border-radius&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;CSS Animations&lt;/h3&gt;
&lt;p&gt;CSS 动画的灵活性和可玩性都极大, 后面会专门抽时间研究一下.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations&quot;&gt;MDN - CSS Animations&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;排版相关&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;文字溢出处理: &lt;code class=&quot;language-text&quot;&gt;text-overflow&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连字符(长单词)处理: &lt;code class=&quot;language-text&quot;&gt;hyphens&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hyphens 属性值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;hyphens: none; 单词不断行
hyphens: manual; 有连字符时换行
hyphens: auto; 浏览器自动处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;文字阴影: &lt;code class=&quot;language-text&quot;&gt;text-shadow&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;文字装饰(下划线/中划线): &lt;code class=&quot;language-text&quot;&gt;text-decoration&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指定在线字体: &lt;code class=&quot;language-text&quot;&gt;@font-face&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;多列布局&lt;/h3&gt;
&lt;p&gt;参考: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Multiple-column_Layout&quot;&gt;MDN-多列布局&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;column-count: n;&lt;/code&gt; 设置后浏览器自动将当前元素分为 n 列&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;column-width: 200px;&lt;/code&gt; 最小列宽&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;columns: n 200px;&lt;/code&gt; 合并列数与列宽设置&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;column-gap: 20px;&lt;/code&gt; 列间隙, 默认 1em&lt;/p&gt;</content:encoded></item><item><title><![CDATA[TypeScript Type Guards]]></title><description><![CDATA[场景: 当一个变量拥有复合类型, 在某些情况下我们需要对其进行类型断言. 比如: 学生体检时, 除了若干公共体检项目外, 男生还需要检查 A 项目, 女生需要检查 B 项目, 男女生体检结果汇总在一个表中. 在实际操作中, 我们需要根据体检人的 sex(性别)字段来确定展示 A…]]></description><link>https://hrayd.github.io/typescript-type-guards/</link><guid isPermaLink="false">https://hrayd.github.io/typescript-type-guards/</guid><pubDate>Sun, 09 Feb 2020 22:00:00 GMT</pubDate><content:encoded>&lt;p&gt;场景: 当一个变量拥有复合类型, 在某些情况下我们需要对其进行类型断言.&lt;/p&gt;
&lt;p&gt;比如: 学生体检时, 除了若干公共体检项目外, 男生还需要检查 A 项目, 女生需要检查 B 项目, 男女生体检结果汇总在一个表中. 在实际操作中, 我们需要根据体检人的 sex(性别)字段来确定展示 A 项目还是 B 项目的体检结果. 代码如下:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;tsx&quot;&gt;&lt;pre class=&quot;language-tsx&quot;&gt;&lt;code class=&quot;language-tsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Boy&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;
  sex&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; SexEnum
  itemA&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Girl&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt;
  sex&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; SexEnum
  itemB&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Boy &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; Girl

&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; s&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Student &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getOne&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sex &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; SexEnum&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Boy&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token builtin&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;itemA&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// error!&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在代码中, 编译器无法确定 &lt;code class=&quot;language-text&quot;&gt;s&lt;/code&gt; 为 &lt;code class=&quot;language-text&quot;&gt;Boy&lt;/code&gt; 类型, 似乎只能通过丑陋的 &lt;code class=&quot;language-text&quot;&gt;as unknow as Boy&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;@ts-ignore&lt;/code&gt; 来绕过错误.&lt;/p&gt;
&lt;h2&gt;Build-in Type Guards&lt;/h2&gt;
&lt;p&gt;JS 中内置的 Type Guards 有 &lt;code class=&quot;language-text&quot;&gt;typeof&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;instanceof&lt;/code&gt; , 但都无法解决问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;typeof&lt;/code&gt; 只能判断基本类型&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;instanceof&lt;/code&gt; 只能应用在 class 中, 函数式编程中极少使用 class, 所以作用有限&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;解决方案: Custom Type Guards&lt;/h2&gt;
&lt;p&gt;示例代码:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;tsx&quot;&gt;&lt;pre class=&quot;language-tsx&quot;&gt;&lt;code class=&quot;language-tsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; isBoy &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;student&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Student&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; student &lt;span class=&quot;token keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;Boy&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; student&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sex &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; SexEnum&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Boy

&lt;span class=&quot;token comment&quot;&gt;// 另一种写法&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; isBoy &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;student&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Student&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; student &lt;span class=&quot;token keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;Boy&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;student &lt;span class=&quot;token keyword&quot;&gt;as&lt;/span&gt; Boy&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;itemA &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; undefine

&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; s&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Student &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getOne&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isBoy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token builtin&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;itemA&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// no error&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关键点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回值应声明为 &lt;code class=&quot;language-text&quot;&gt;variable is Type&lt;/code&gt; 的形式, 如  &lt;code class=&quot;language-text&quot;&gt;student is Boy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;函数体返回一个可以进行类型断言的 bool 值, 如  &lt;code class=&quot;language-text&quot;&gt;student.sex === SexEnum.Boy&lt;/code&gt; .&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;A generic(范型) type guard&lt;/h2&gt;
&lt;p&gt;如果需要编写许多 Type Guards, 使用 custom 的方式将会十分繁复, 不够 DRY.&lt;/p&gt;
&lt;p&gt;Generic Type Guard:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; isOfType &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token plain-text&quot;&gt;(
  varToBeChecked: any,
  propertyToCheckFor: keyof T
): varToBeChecked is T =&gt;
  (varToBeChecked as T)[propertyToCheckFor] !== undefined;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Use case:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;jsx&quot;&gt;&lt;pre class=&quot;language-jsx&quot;&gt;&lt;code class=&quot;language-jsx&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;isOfType &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; Car &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;item&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;turnSteeringWheel&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 此处item被成功断言为Car&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Dude, where&apos;s my car?!&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;问题: 只通过一个属性来断言类型, 有时不够安全. 需要根据实际情况进行修改, 如传入属性列表或其他配置项.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[CAGED Guitar System]]></title><description><![CDATA[CAGED 概述 CAGED 代表五种基本和弦手型，即 C-A-G-E-D 和弦. 通过转换把位移调, 任意和弦都可以用这五种手型弹奏. 例: 五种手型弹 C 和弦: 第一把位的 C 手型 五弦三品作为根音的 A 手型 六弦八品作为根音的 G 手型和 E 手型(G 和 E…]]></description><link>https://hrayd.github.io/caged/</link><guid isPermaLink="false">https://hrayd.github.io/caged/</guid><pubDate>Tue, 17 Sep 2019 22:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;CAGED 概述&lt;/h2&gt;
&lt;p&gt;CAGED 代表五种基本和弦手型，即 C-A-G-E-D 和弦.&lt;/p&gt;
&lt;p&gt;通过转换把位移调, 任意和弦都可以用这五种手型弹奏.&lt;/p&gt;
&lt;p&gt;例: 五种手型弹 C 和弦:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一把位的 C 手型&lt;/li&gt;
&lt;li&gt;五弦三品作为根音的 A 手型&lt;/li&gt;
&lt;li&gt;六弦八品作为根音的 G 手型和 E 手型(G 和 E 根音都在六弦)&lt;/li&gt;
&lt;li&gt;四弦十品作为根音的 D 手型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;由根音推和弦&lt;/h2&gt;
&lt;p&gt;由根音可以快速找到一组相同和弦：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C 指型与 A 指型根音相同时为同一和弦&lt;/li&gt;
&lt;li&gt;E 指型与 G 指型根音相同时为同一和弦&lt;/li&gt;
&lt;li&gt;以 E 指型的四弦为根音，可找到 D 指型的同一和弦&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;知识点：十二品为一个八度&lt;/p&gt;
&lt;p&gt;知识点：由调弦方法可推出相邻弦的音高关系，如五弦零品=六弦五品&lt;/p&gt;
&lt;p&gt;应用：由根音快速找到所有的 C 和弦&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;最基本 C 指型，根音为五弦三品&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;根音不动，变为 A 指型&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;五弦零品=六弦五品 =&gt; 五弦三品=六弦八品，以六弦八品为根音的 G 指型与 E 指型&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;十二品为一个八度，以五弦十五品为根音的 C 指型与 A 指型&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同理推出其他大调和弦&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;搞清楚每个基本和弦对应的小调和弦、挂留和弦与七和弦等基本变化, 就可以推出整个指板的所有封闭和弦!&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;由根音推音阶&lt;/h2&gt;
&lt;p&gt;理论都很简单, 但需要集中练习.&lt;/p&gt;
&lt;h3&gt;相对音阶&lt;/h3&gt;
&lt;p&gt;给定一个位置的音, 可以迅速推出周围乃至整个指板的音.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;研究同音/八度位置:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;六弦和四弦, 五弦和三弦差两品&lt;/li&gt;
&lt;li&gt;四弦和二弦, 三弦和一弦差三品&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过八度位置推导并记熟常用的五度和三度位置&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;绝对音阶&lt;/h3&gt;
&lt;p&gt;绝对音阶一般只需要记住特定的几个, 然后与相对音阶位置相结合, 就可以迅速得到指定音阶.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先熟记第一把位的所有音阶, 一般基本和弦练熟了都没问题.&lt;/li&gt;
&lt;li&gt;顺势推出并熟记十二品附近音阶, 与第一把位相同.&lt;/li&gt;
&lt;li&gt;通过八度相对音阶的位置, 就近在第一把位或十二品把位找到对应的同音音阶&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;熟悉之后可以在中间选择一些常用位置进行记忆, 如五品或九品.&lt;/p&gt;
&lt;p&gt;推出音阶之后, 与前一节的 &lt;strong&gt;由根音推和弦&lt;/strong&gt; 相结合, 基本就摸透整个指板了.&lt;/p&gt;
&lt;h2&gt;高把位按弦技巧&lt;/h2&gt;
&lt;p&gt;根音位置不变，这意味着：记住指法与和弦的对应关系，也就记住了指板上对应的根音。&lt;/p&gt;
&lt;p&gt;C 指型在大横按时较为困难，可以只按 2、3、4、5 弦。&lt;/p&gt;
&lt;p&gt;G 指型可以只用小指和食指按 2、3、4、6 弦或 1、2、3、4 弦。&lt;/p&gt;
&lt;p&gt;D 指型一般不用来弹所有和弦，可以只弹 1、2、3 弦的高音，一般为扫弦。&lt;/p&gt;</content:encoded></item></channel></rss>