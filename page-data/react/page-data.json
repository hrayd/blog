{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/","result":{"data":{"site":{"siteMetadata":{"title":"按太阳穴轮刮眼眶"}},"markdownRemark":{"id":"d825e2a6-c130-5b73-b187-efe1310eb54d","excerpt":"1. JSX与虚拟DOM 我们从React官方文档开头最基本的一段Hello World代码入手: 很明显, 这段代码的意思是通过  方法将  包裹的JSX元素渲染到id为“root”的HTML元素上. 除了在JS中早已熟知的  方法外, 这段代码中还包含两个知识点: 以  标签包裹的JSX…","html":"<h1>1. JSX与虚拟DOM</h1>\n<p>我们从React官方文档开头最基本的一段Hello World代码入手:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello, world!</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">,</span>\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>很明显, 这段代码的意思是通过 <code class=\"language-text\">ReactDOM.render()</code> 方法将 <code class=\"language-text\">h1</code> 包裹的JSX元素渲染到id为“root”的HTML元素上. 除了在JS中早已熟知的 <code class=\"language-text\">document.getElementById()</code> 方法外, 这段代码中还包含两个知识点:</p>\n<ul>\n<li>以 <code class=\"language-text\">h1</code> 标签包裹的JSX元素</li>\n<li><code class=\"language-text\">ReactDOM.render()</code> 方法</li>\n</ul>\n<p>而这两个知识点则对应着React中要解决的核心问题:</p>\n<ul>\n<li>为何以及如何使用(JSX表示的)虚拟DOM?</li>\n<li>如何对虚拟DOM进行处理, 使其高效地渲染出来?</li>\n</ul>\n<h3>1.1 虚拟DOM是什么? 为何要使用虚拟DOM?</h3>\n<p>虚拟DOM其实就是用JavaScript对象表示的一个DOM节点, 内部包含了节点的 <code class=\"language-text\">tag</code> , <code class=\"language-text\">props</code> 和 <code class=\"language-text\">children</code> .</p>\n<p>为何使用虚拟DOM? 因为直接操作真实DOM繁琐且低效, 通过虚拟DOM, 将一部分昂贵的浏览器重绘工作转移到相对廉价的存储和计算资源上.</p>\n<h3>1.2 如何将JSX转换成虚拟DOM?</h3>\n<p>通过babel可以将JSX编译为特定的JavaScript对象, 示例代码如下:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// JSX</span>\n<span class=\"token keyword\">const</span> e <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>\n\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>root<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n\t\t</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>title<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Title</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// babel编译结果(React17之前), 注意子元素的嵌套结构</span>\n<span class=\"token keyword\">var</span> e <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span>\n\t<span class=\"token string\">\"div\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span> id<span class=\"token operator\">:</span> <span class=\"token string\">\"root\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\tReact<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span>\n\t\t<span class=\"token string\">\"h1\"</span><span class=\"token punctuation\">,</span>\n\t\t<span class=\"token punctuation\">{</span> className<span class=\"token operator\">:</span> <span class=\"token string\">\"title\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\t\t<span class=\"token string\">\"Title\"</span>\n\t<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// React17之后编译结果有所区别, 创建节点的方法由react导出, 但基本原理大同小异</span></code></pre></div>\n<h3>1.3 如何将虚拟DOM渲染出来?</h3>\n<p>很明显, 虚拟DOM中包含了创建DOM所需的各种信息, 对于首次渲染, 直接依照这些信息创建DOM节点即可.</p>\n<p>但虚拟DOM的真正价值在于“更新”: 当一个list中的某些项发生了变化, 或删除或增加了若干项, 如何通过对比前后的虚拟DOM树, 最小化地更新真实DOM? 这就是React的核心目标.</p>\n<h1>2. React Diffing</h1>\n<p>“Diffing”即“找不同”, 就是解决上文引出的React的核心目标——如何通过对比新旧虚拟DOM树, 以在最小的操作次数下将旧DOM树转换为新DOM树.</p>\n<p>在算法领域中, 两棵树的转换目前最优的算法复杂度为 <code class=\"language-text\">O(n**3)</code> , n为节点个数. 这意味着当树上有1000个元素时, 需要10亿次比较, 显然远远不够高效.</p>\n<p>React在基于以下两个假设的基础上, 提出了一套复杂度为 <code class=\"language-text\">O(n)</code> 的启发式算法</p>\n<ol>\n<li>不同类型(即标签名、组件名)的元素会产生不同的树;</li>\n<li>通过设置 <code class=\"language-text\">key</code> 属性来标识一组同级子元素在渲染前后是否保持不变.</li>\n</ol>\n<p>在实践中, 以上两个假设在绝大多数场景下都成立.</p>\n<h2>2.1 Diffling算法描述</h2>\n<h3>不同类型的元素/组件</h3>\n<p>当元素的标签或组件名发生变化, 直接卸载并替换以此元素作为根节点的整个子树.</p>\n<h3>同一类型的元素</h3>\n<p>当元素的标签相同时, React保留此DOM节点, 仅对比和更新有改变的属性, 如className、title等, 然后递归对比其子节点.</p>\n<p>对于 <code class=\"language-text\">style</code> 属性, React会继续深入对比, 仅更新有改变的属性, 如color、fontSize等.</p>\n<h3>同一类型的组件</h3>\n<p>当组件的props更新时, 组件实例保持不变, React调用组件的 <code class=\"language-text\">componentWillReceiveProps()</code> <code class=\"language-text\">componentWillUpdate()</code> 和 <code class=\"language-text\">componentDidUpdate()</code> 生命周期方法, 并执行 <code class=\"language-text\">render()</code> 方法.</p>\n<p>Diffing算法会递归比对新旧 <code class=\"language-text\">render()</code> 执行的结果.</p>\n<h3>对子节点的递归</h3>\n<p>当一组同级子节点(列表)的末尾添加了新的子节点时, 上述Diffing算法的开销较小; 但当新元素被插入到列表开头时, Diffing算法只能按顺序依次比对并重建从新元素开始的后续所有子节点, 造成极大的开销浪费.</p>\n<p>解决方案是为一组列表项添加 <code class=\"language-text\">key</code> 属性, 这样React就可以方便地比对出插入或删除项了.</p>\n<p>关于 <code class=\"language-text\">key</code> 属性, 应稳定、可预测且在列表内唯一(无需全局唯一), 如果数据有ID的话直接使用此ID作为 <code class=\"language-text\">key</code>, 或者利用数据中的一部分字段哈希出一个key值.</p>\n<p>避免使用数组索引值作为 <code class=\"language-text\">key</code>, 因为当插入或删除元素后, 之后的元素和索引值的对应关系都会发生错乱, 导致错误的比对结果.</p>\n<p>避免使用不稳定的key(如随机数), 因为每次渲染都会发生改变, 从而导致列表项被不必要地重建.</p>\n<h2>2.2 递归的Diffing</h2>\n<p>在1.2节中的虚拟DOM对象中可以得知: 虚拟DOM树的每个节点通过 <code class=\"language-text\">children</code> 属性构成了一个嵌套的树结构, 这意味着要以递归的形式遍历和比较新旧虚拟DOM树.</p>\n<p>2.1节的策略解决了Diffing算法的时间复杂度的问题, 但我们还面临着另外一个重大的性能问题——浏览器的渲染线程和JS的执行线程是互斥的, 这意味着DOM节点过多时, 虚拟DOM树的构建和处理会长时间占用主线程, 使得一些需要高优先级处理的操作如用户输入、平滑动画等被阻塞, 严重影响使用体验. </p>\n<h3>时间切片(Time Slice)</h3>\n<p>为了解决浏览器主线程的阻塞问题, 引出 <strong>时间切片</strong> 的策略——将整个工作流程分解成小的工作单元, 并在浏览器空闲时交由浏览器执行这些工作单元, 每个执行单元执行完毕后, 浏览器都可以选择中断渲染并处理其他需要更高优先级处理的工作.</p>\n<p>浏览器中提供了 <code class=\"language-text\">requestIdleCallback</code> 方法实现此功能, 将待调用的函数加入执行队列, 浏览器将在不影响关键事件处理的情况下逐个调用.</p>\n<p>考虑到浏览器的兼容性以及 <code class=\"language-text\">requestIdleCallback</code> 方法的不稳定性, React自己实现了专用于React的类似 <code class=\"language-text\">requestIdleCallback</code> 且功能更完备的 <code class=\"language-text\">Scheduler</code> 来实现空闲时触发回调, 并提供了多种优先级供任务设置.</p>\n<h3>递归与时间切片</h3>\n<p>时间切片策略要求我们将虚拟DOM的更新操作分解为小的工作单元, 同时具备以下特性:</p>\n<ul>\n<li>可暂停、可恢复的更新;</li>\n<li>可跳过的重复性、覆盖性更新;</li>\n<li>具备优先级的更新.</li>\n</ul>\n<p>对于递归形式的程序来说, 这些是难以实现的. 于是就需要一个处于递归形式的虚拟DOM树上层的数据结构, 来辅助完成这些特性. </p>\n<p>这就是React16引入的重构后的算法核心——Fiber.</p>\n<h1>3. Fiber</h1>\n<p>从概念上来说, Fiber就是重构后的虚拟DOM节点, 一个Fiber就是一个JS对象.</p>\n<p>Fiber节点之间构成 <strong>单向链表</strong> 结构, 以实现前文提到的几个特性: 更新可暂停/恢复、可跳过、可设优先级. </p>\n<h2>3.1 Fiber节点</h2>\n<p>一个Fiber节点就是一个JS对象, 其中的关键属性可分类列举如下:</p>\n<ul>\n<li>\n<p>结构信息(构成链表的指针属性)</p>\n<ul>\n<li>return: 父节点</li>\n<li>child: 第一个子节点</li>\n<li>sibling: 右侧第一个兄弟节点</li>\n<li>alternate: 本节点在相邻更新时的状态, 用于比较节点前后的变化, 3.3节详述</li>\n</ul>\n</li>\n<li>\n<p>组件信息</p>\n<ul>\n<li>tag: 组件创建类型, 如FunctionComponent、ClassComponent、HostComponent等</li>\n<li>key: 即key属性</li>\n<li>type: 组件类型, Function/Class组件的type就是对应的Function/Class本身, Host组件的type就是对应元素的TagName</li>\n<li>stateNode: 对应的真实DOM节点</li>\n</ul>\n</li>\n<li>\n<p>本次更新的props和state相关信息</p>\n<ul>\n<li>pendingProps、memoizedProps</li>\n<li>memoizedState</li>\n<li>dependencies</li>\n<li>updateQueue</li>\n</ul>\n</li>\n<li>\n<p>更新标记</p>\n<ul>\n<li>effectTag: 节点更新类型, 如替换、更新、删除等</li>\n<li>nextEffect、firstEffect、lastEffect</li>\n</ul>\n</li>\n<li>优先级相关: lanes、childrenLanes</li>\n</ul>\n<h2>3.2 Fiber树</h2>\n<p>前文说到, Fiber节点通过 <code class=\"language-text\">return</code> , <code class=\"language-text\">child</code> 和 <code class=\"language-text\">slibling</code> 属性构成了单向链表结构, 为了与DOM树对应, 习惯上仍称其为“树”. </p>\n<p>如一棵DOM树:</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\n\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span>Title<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span>\n\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>section</span><span class=\"token punctuation\">></span></span>\n\t\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h2</span><span class=\"token punctuation\">></span></span>Section<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h2</span><span class=\"token punctuation\">></span></span>\n\t\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>Content<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>section</span><span class=\"token punctuation\">></span></span>\n\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>footer</span><span class=\"token punctuation\">></span></span>Footer<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>footer</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>其 <code class=\"language-text\">section</code> 节点的Fiber可表示为:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> sectionFiber <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n\tkey<span class=\"token operator\">:</span> <span class=\"token string\">\"SECTION_KEY\"</span><span class=\"token punctuation\">,</span>\n\tchild<span class=\"token operator\">:</span> h2Fiber<span class=\"token punctuation\">,</span>\n\tsibling<span class=\"token operator\">:</span> footerFiber<span class=\"token punctuation\">,</span>\n\t<span class=\"token keyword\">return</span><span class=\"token operator\">:</span> divFiber<span class=\"token punctuation\">,</span>\n\talternate<span class=\"token operator\">:</span> oldSectionFiber<span class=\"token punctuation\">,</span>  \n\t<span class=\"token operator\">...</span>otherFiberProps<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>整体的Fiber结构:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 351px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b3457a432995dc057094ab9e3bb38373/7c2a6/DOM.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 79.74683544303798%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAABwklEQVQ4y5WU12oDUQxE9/9/y2D8YGxccO+9994mHAWZzWYdiECsb5E0M9J1MBgMhLdaLS0WC81mMz0eD2Gv10v/teB0Omk4HKpUKtnG4XDQ7Xb7mJA93/ffYQ9Go5FWq5V2u52KxaL2+33sxTiPRdjv95XNZo1uKpXS5XL5ge6vYO7CkC8OmKDT6Qi/Xq+aTqdar9dG+fl8mruxdzweLRCNz+ezMZvP5+r1eppMJmq32wo2m43wSqVigclkUrlczpJ3u11lMhnl83lbFwoFIRE6w4g9ktVqNWtqtVr9TujVQMAaFNAECcFU986HDYrENhoNi6WIacgG0BOJhB1EOxztfFTX5XL5XgdAhgqJoO1NCdt2u9X9fv84e+HJMIQMM5Q5ADaI6B5UOUO38Xhs80rTKO4yMWro5+gDDukwARgJaEI6nbbLJCmXy4aexDSARADhHmuPtYQkYKhxqvN1AyX6eFebzaY1jUDO0B0pkORN2bvpHhWdoQcNCEEc9yQp8n4pcSJ7QjoLXZCgL5TD44OO7MPC2QR/vVNoQol/I28WmjJmFEICCqAhxev1+m+E4TeMNuEBJjko6D6vCOSuNUaxL8UZzYzW8I5pAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"./DOM.png\"\n        title=\"./DOM.png\"\n        src=\"/static/b3457a432995dc057094ab9e3bb38373/7c2a6/DOM.png\"\n        srcset=\"/static/b3457a432995dc057094ab9e3bb38373/c26ae/DOM.png 158w,\n/static/b3457a432995dc057094ab9e3bb38373/6bdcf/DOM.png 315w,\n/static/b3457a432995dc057094ab9e3bb38373/7c2a6/DOM.png 351w\"\n        sizes=\"(max-width: 351px) 100vw, 351px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h2>3.3 Fiber架构</h2>\n<p>基于Fiber构成的虚拟DOM树就是Fiber架构.</p>\n<p>在3.1节中我们介绍过, 在Fiber节点中有一个重要属性 <code class=\"language-text\">alternate</code> , 单词意为“备用”. </p>\n<p>实际上, 在React中最多会同时存在两棵Fiber树:</p>\n<ul>\n<li>当前显示在屏幕上、已经构建完成的Fiber树称为“Current Fiber Tree”,  我们将其中的Fiber节点简写为 <code class=\"language-text\">currFiber</code>;</li>\n<li>当前正在构建的Fiber树称为“WorkInProgress Fiber Tree”, 我们将其Fiber节点节点简写为 <code class=\"language-text\">wipFiber</code>.</li>\n</ul>\n<p>而这两棵树中节点的 <code class=\"language-text\">alternate</code> 属性互相指向对方树中的对应节点, 即: <code class=\"language-text\">currFiber.alternate === wipFiber; wipFiber.alternate === currFber;</code> 他们用于对比更新前后的节点以决定如何更新此节点.</p>\n<p>在React中, 整个应用的根节点为 <code class=\"language-text\">fiberRoot</code> , 当wipFiber树构建完成后, <code class=\"language-text\">fiberRoot.current</code> 将从currFiber树的根节点切换为wipFiber的根节点, 以完成更新操作.</p>\n<h3>3.1 基于Fiber的调度——时间切片</h3>\n<p>在2.2节我们讨论了采用拆分工作单元并以时间切片的方式执行, 以避免阻塞主线程. 在Fiber架构下, 每个Fiber节点就是一个工作单元. </p>\n<p>在以下示例代码中, 我们使用浏览器提供的 <code class=\"language-text\">requestIdleCallback</code> 方法演示这个过程, 它会在浏览器空闲时执行一个workLoop、处理一个Fiber节点, 然后可以根据实际情况继续执行或暂停等待执行下一个workLoop.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">workLoop</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">deadline</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> shouldYield <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>nextUnitOfWork <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>shouldYield<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">// 处理一个Fiber节点, 返回下一个Fiber节点, 详见3.3节</span>\n    nextUnitOfWork <span class=\"token operator\">=</span> <span class=\"token function\">performUnitOfWork</span><span class=\"token punctuation\">(</span>nextUnitOfWork<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 暂停处理的演示: 当时间不足时取消循环处理过程</span>\n    shouldYield <span class=\"token operator\">=</span> deadline<span class=\"token punctuation\">.</span><span class=\"token function\">timeRemaining</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// 当执行完毕(不存在下一个执行单元), 提交整个DOM树</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>nextUnitOfWork <span class=\"token operator\">&amp;&amp;</span> wipRoot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">commitRoot</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">requestIdleCallback</span><span class=\"token punctuation\">(</span>workLoop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">requestIdleCallback</span><span class=\"token punctuation\">(</span>workLoop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>3.2 对Fiber节点的处理顺序——DFS</h3>\n<p>由前文我们可知, Fiber节点通过 <code class=\"language-text\">return</code> <code class=\"language-text\">child</code> <code class=\"language-text\">sibling</code> 三个属性相互连接, 整体构成一个单向链表结构,其调度方式就是 深度优先遍历 :</p>\n<ol>\n<li>以wipFiber树的Root节点作为第一个执行单元;</li>\n<li>若当前执行单元存在child节点, 则将child节点作为下一个执行单元;</li>\n<li>重复2, 直至当前执行单元无child;</li>\n<li>若当前执行单元存在sibling节点, 则将sibling节点作为下一个执行单元, 并回到2;</li>\n<li>若当前执行单元无child且无sibling, 返回到父节点, 并回到4;</li>\n<li>重复5; 直至回到Root节点, 执行完毕, 将 <code class=\"language-text\">fiberRoot.current</code> 只为wipFiber树的根节点.</li>\n</ol>\n<p>以上步骤说明, Fiber节点通过 <code class=\"language-text\">child</code> → <code class=\"language-text\">sibling</code> → <code class=\"language-text\">return</code> 的顺序进行深度优先遍历“处理”, 而后更新Fiber树. 那么如何“处理”Fiber节点呢?</p>\n<h3>3.3 对Fiber节点的处理过程</h3>\n<p>对Fiber节点的处理就是执行一个 <code class=\"language-text\">performUnitOfWork</code> 方法, 它接收一个将要处理的Fiber节点, 然后完成以下工作:</p>\n<ol>\n<li>\n<p>完善构建Fiber节点: 创建DOM并获取 <code class=\"language-text\">children</code></p>\n<ul>\n<li>对于HostComponent和ClassComponent, 根据Fiber中的相关属性, 创建DOM节点并赋给 <code class=\"language-text\">Fiber.stateNode</code> 属性;</li>\n<li>对于FunctionComponent, 直接通过函数调用获取其children: <code class=\"language-text\">Fiber.type(Fiber.props)</code></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 执行工作单元,并返回下一个工作单元</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">performUnitOfWork</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fiber</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 构建当前节点的fiber</span>\n  <span class=\"token keyword\">const</span> isFunctionComponent <span class=\"token operator\">=</span> fiber<span class=\"token punctuation\">.</span>type <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isFunctionComponent<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">updateFunctionComponent</span><span class=\"token punctuation\">(</span>fiber<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">updateHostComponent</span><span class=\"token punctuation\">(</span>fiber<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 处理子节点, 构建Fiber树</span>\n  <span class=\"token keyword\">const</span> elements <span class=\"token operator\">=</span> fiber<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">reconcileChildren</span><span class=\"token punctuation\">(</span>fiber<span class=\"token punctuation\">,</span> elements<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// TODO: 返回下一个执行单元</span>\n  <span class=\"token comment\">// fiber.child || fiber.sibling || fiber.return</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Class/Host组件: 创建DOM</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">updateHostComponent</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fiber</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>fiber<span class=\"token punctuation\">.</span>dom<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    fiber<span class=\"token punctuation\">.</span>dom <span class=\"token operator\">=</span> <span class=\"token function\">createDom</span><span class=\"token punctuation\">(</span>fiber<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">reconcileChildren</span><span class=\"token punctuation\">(</span>fiber<span class=\"token punctuation\">,</span> fiber<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 更新Function组件, Function组件需要从返回值获取子组件</span>\n<span class=\"token comment\">// 注意: Function组件无DOM</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">updateFunctionComponent</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fiber</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 初始化hooks</span>\n  wipFiber <span class=\"token operator\">=</span> fiber<span class=\"token punctuation\">;</span>\n  hookIndex <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  fiber<span class=\"token punctuation\">.</span>hooks <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> children <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>fiber<span class=\"token punctuation\">.</span><span class=\"token function\">type</span><span class=\"token punctuation\">(</span>fiber<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Function组件返回children</span>\n  <span class=\"token function\">reconcileChildren</span><span class=\"token punctuation\">(</span>fiber<span class=\"token punctuation\">,</span> children<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// TODO: reconcileChildren处理子节点,见第3步</span></code></pre></div>\n</li>\n<li>\n<p>通过 <code class=\"language-text\">Fiber.alternate</code> 获取 <code class=\"language-text\">oldFiber</code> , 即上一次更新后的Fiber值, 然后在下一步中构建和Diff当前Fiber的 <code class=\"language-text\">children</code> .</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">reconcileChildren</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">wipFiber<span class=\"token punctuation\">,</span> elements</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> oldFiber <span class=\"token operator\">=</span> wipFiber<span class=\"token punctuation\">.</span>alternate\n\t\t\t<span class=\"token operator\">&amp;&amp;</span> wipFiber<span class=\"token punctuation\">.</span>alternate<span class=\"token punctuation\">.</span>child<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>构建 <code class=\"language-text\">children</code> Fibers, 对于每个子Fiber, 同步地完成以下工作:</p>\n<ul>\n<li>构建Fiber链表: 为每个子元素创建Fiber, 并将父Fiber的 <code class=\"language-text\">child</code> 属性指向第一个子Fiber, 然后按顺序将子Fiber的 <code class=\"language-text\">sibling</code> 属性指向下一个子Fiber;</li>\n<li>对比(Diffing)新旧Fiber节点的 <code class=\"language-text\">type</code> <code class=\"language-text\">props</code> <code class=\"language-text\">key</code> 等属性, 确定节点是可以直接复用、替换、更新还是删除, 需要更新的Fiber节点在其 <code class=\"language-text\">effectTag</code> 属性中打上 <code class=\"language-text\">Update</code> <code class=\"language-text\">Placement</code> <code class=\"language-text\">PlacementAndUpdate</code> <code class=\"language-text\">Deletion</code> 等标记, 以在提交更新阶段进行处理.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">reconcileChildren</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">wipFiber<span class=\"token punctuation\">,</span> elements</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> oldFiber <span class=\"token operator\">=</span> wipFiber<span class=\"token punctuation\">.</span>alternate <span class=\"token operator\">&amp;&amp;</span> wipFiber<span class=\"token punctuation\">.</span>alternate<span class=\"token punctuation\">.</span>child<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> prevSibling <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">&lt;</span> elements<span class=\"token punctuation\">.</span>length <span class=\"token operator\">||</span> oldFiber <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span> elements<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> newFiber <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// Compare oldFiber to element</span>\n    <span class=\"token keyword\">const</span> sameType <span class=\"token operator\">=</span> oldFiber <span class=\"token operator\">&amp;&amp;</span> element <span class=\"token operator\">&amp;&amp;</span> element<span class=\"token punctuation\">.</span>type <span class=\"token operator\">===</span> oldFiber<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sameType<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// update the node</span>\n      newFiber <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        type<span class=\"token operator\">:</span> oldFiber<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">,</span>\n        props<span class=\"token operator\">:</span> element<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">,</span>\n        dom<span class=\"token operator\">:</span> oldFiber<span class=\"token punctuation\">.</span>dom<span class=\"token punctuation\">,</span>\n        parent<span class=\"token operator\">:</span> wipFiber<span class=\"token punctuation\">,</span>\n        alternate<span class=\"token operator\">:</span> oldFiber<span class=\"token punctuation\">,</span>\n        effectTag<span class=\"token operator\">:</span> <span class=\"token string\">\"UPDATE\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>element <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>sameType<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// add this node</span>\n      newFiber <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        type<span class=\"token operator\">:</span> element<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">,</span>\n        props<span class=\"token operator\">:</span> element<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">,</span>\n        dom<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n        parent<span class=\"token operator\">:</span> wipFiber<span class=\"token punctuation\">,</span>\n        alternate<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n        effectTag<span class=\"token operator\">:</span> <span class=\"token string\">\"PLACEMENT\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldFiber <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>sameType<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// delete the oldFiber's node</span>\n      oldFiber<span class=\"token punctuation\">.</span>effectTag <span class=\"token operator\">=</span> <span class=\"token string\">\"DELETION\"</span><span class=\"token punctuation\">;</span>\n      deletions<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>oldFiber<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldFiber<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      oldFiber <span class=\"token operator\">=</span> oldFiber<span class=\"token punctuation\">.</span>sibling<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      wipFiber<span class=\"token punctuation\">.</span>child <span class=\"token operator\">=</span> newFiber<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      prevSibling <span class=\"token operator\">=</span> newFiber<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    prevSibling <span class=\"token operator\">=</span> newFiber<span class=\"token punctuation\">;</span>\n    index<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>按DFS顺序返回下一个工作单元, 示例代码如下:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>fiber<span class=\"token punctuation\">.</span>child<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> fiber<span class=\"token punctuation\">.</span>child<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">let</span> nextFiber <span class=\"token operator\">=</span> fiber<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>nextFiber<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextFiber<span class=\"token punctuation\">.</span>sibling<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> nextFiber<span class=\"token punctuation\">.</span>sibling<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    nextFiber <span class=\"token operator\">=</span> nextFiber<span class=\"token punctuation\">.</span>parent<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ol>\n<p>当DFS过程回到根节点时, 表明本次更新的 wipFiber树 构建完成, 进入下一步的提交更新阶段.</p>\n<h3>3.4 提交更新阶段</h3>\n<p>在进入本阶段时, 新的Fiber树已构建完成, 需要进行替换、更新或删除的Fiber节点也在其 <code class=\"language-text\">effectTag</code> 中进行了标记, 所以本阶段第一个工作就是根据 <code class=\"language-text\">effectTag</code> 操作真实DOM.</p>\n<p>为了避免从头再遍历Fiber树寻找具有 <code class=\"language-text\">effectTag</code> 属性的Fiber, 在上一步Fiber树的构建过程中保存了一条需要更新的Fiber节点的单向链表 <code class=\"language-text\">effectList</code> , 并将此链表的头节点存储在Fiber树根节点的 <code class=\"language-text\">firstEffect</code> 属性中, 同时这些Fiber节点的 <code class=\"language-text\">updateQueue</code> 属性中也保存了需要更新的 <code class=\"language-text\">props</code> .</p>\n<p>除了更新真实DOM外, 在提交更新阶段还需要在特定阶段调用和处理生命周期方法、执行Hooks操作, 本文不再详述.</p>\n<p>在此参考了 <a href=\"https://pomb.us/build-your-own-react/\">https://pomb.us/build-your-own-react/</a> 中提供的 <code class=\"language-text\">useState</code> Hook的实现代码, 有助于理解在执行 <code class=\"language-text\">setState</code> 方法后都发生了什么: </p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">initial</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 判断上一次渲染是否存在此Hook,如果存在就使用上一个state,否则创建新的hook并更新索引</span>\n  <span class=\"token keyword\">const</span> oldHook <span class=\"token operator\">=</span>\n    wipFiber<span class=\"token punctuation\">.</span>alternate <span class=\"token operator\">&amp;&amp;</span>\n    wipFiber<span class=\"token punctuation\">.</span>alternate<span class=\"token punctuation\">.</span>hooks <span class=\"token operator\">&amp;&amp;</span>\n    wipFiber<span class=\"token punctuation\">.</span>alternate<span class=\"token punctuation\">.</span>hooks<span class=\"token punctuation\">[</span>hookIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> hook <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    state<span class=\"token operator\">:</span> oldHook <span class=\"token operator\">?</span> oldHook<span class=\"token punctuation\">.</span>state <span class=\"token operator\">:</span> initial<span class=\"token punctuation\">,</span>\n    queue<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 每次执行setState时,将action加入此队列,并在下一次渲染时执行</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 下一次渲染时, 获取执行队列并逐步执行, 使得state保持最新</span>\n  <span class=\"token keyword\">const</span> actions <span class=\"token operator\">=</span> oldHook <span class=\"token operator\">?</span> oldHook<span class=\"token punctuation\">.</span>queue <span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  actions<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">action</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    hook<span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token function\">action</span><span class=\"token punctuation\">(</span>hook<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// setState方法: 将action添加到执行队列并触发渲染, 在下一次渲染时执行此action</span>\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">setState</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">action</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    hook<span class=\"token punctuation\">.</span>queue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>action<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 执行setState后应重新触发渲染</span>\n    wipRoot <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      dom<span class=\"token operator\">:</span> currentRoot<span class=\"token punctuation\">.</span>dom<span class=\"token punctuation\">,</span>\n      props<span class=\"token operator\">:</span> currentRoot<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">,</span>\n      alternate<span class=\"token operator\">:</span> currentRoot<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    nextUnitOfWork <span class=\"token operator\">=</span> wipRoot<span class=\"token punctuation\">;</span>\n    deletions <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  wipFiber<span class=\"token punctuation\">.</span>hooks<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>hook<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  hookIndex<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>hook<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">,</span> setState<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h1>参考文献</h1>\n<ul>\n<li>React官方文档与相关源码</li>\n<li><a href=\"https://pomb.us/build-your-own-react/\">https://pomb.us/build-your-own-react/</a></li>\n<li><a href=\"https://react.iamkasong.com/renderer/beforeMutation.html#commitbeforemutationeffects\">https://react.iamkasong.com</a></li>\n</ul>","frontmatter":{"title":"React核心原理浅析","date":"July 18, 2021","description":"对React的核心原理进行分析,包括JSX、Diffing、Fiber、Time Slice等."}},"previous":{"fields":{"slug":"/online-editor/"},"frontmatter":{"title":"在线编辑器实现浅析"}},"next":null},"pageContext":{"id":"d825e2a6-c130-5b73-b187-efe1310eb54d","previousPostId":"30b2715f-aa77-5298-97be-8587fe5d1c54","nextPostId":null}},"staticQueryHashes":["2841359383","3257411868"]}