{"componentChunkName":"component---src-templates-blog-post-js","path":"/http-2/","result":{"data":{"site":{"siteMetadata":{"title":"按太阳穴轮刮眼眶"}},"markdownRemark":{"id":"79d2e07e-9544-55b6-a161-bf95ddf8e04d","excerpt":"数据类型与编码 MIME type 全称“多用途互联网邮件扩展”(Multipurpose Internet Mail Extensions), 用于标记 body 的数据类型, 形式是  的字符串, 常用的有: text:    image:    audio/video:   application…","html":"<h2>数据类型与编码</h2>\n<h3>MIME type</h3>\n<p>全称“多用途互联网邮件扩展”(Multipurpose Internet Mail Extensions), 用于标记 body 的数据类型, 形式是 <code class=\"language-text\">type/subtype</code> 的字符串, 常用的有:</p>\n<ul>\n<li>text: <code class=\"language-text\">text/html</code> <code class=\"language-text\">text/css</code> <code class=\"language-text\">text/plain</code></li>\n<li>image: <code class=\"language-text\">image/gif</code> <code class=\"language-text\">image/jpeg</code> <code class=\"language-text\">image/png</code></li>\n<li>audio/video: <code class=\"language-text\">audio/mpeg</code> <code class=\"language-text\">video/mp4</code></li>\n<li>application: <code class=\"language-text\">application/json</code> <code class=\"language-text\">application/javascript</code> <code class=\"language-text\">application/pdf</code> <code class=\"language-text\">application/octet-stream</code></li>\n</ul>\n<h3>数据编码/压缩</h3>\n<ul>\n<li>gzip: GNU zip, 对于文本数据通常超过 60%压缩率</li>\n<li>deflate: zlib</li>\n<li>br: 专为 HTTP 优化的新压缩算法 Brotli, 通常比 gzip 还好</li>\n</ul>\n<h3>数据类型相关 Headers</h3>\n<ul>\n<li>\n<p>请求头: 客户端声明希望/能够接收的数据类型</p>\n<ul>\n<li>Accept: text/html, application/json, image/png, image/webp</li>\n<li>Accept-Encoding: gzip, deflate, br</li>\n</ul>\n</li>\n<li>\n<p>响应头: 服务端告知实际发送的数据类型</p>\n<ul>\n<li>Content-Type: text/html</li>\n<li>Content-Encoding: gzip</li>\n</ul>\n</li>\n</ul>\n<h2>国际化 i18n</h2>\n<p>主要分为语言和字符集:</p>\n<ul>\n<li>\n<p>请求头</p>\n<ul>\n<li>Accept-Language: zh-CN, zh, en</li>\n<li>Accept-Charset: utf-8, gbk</li>\n</ul>\n</li>\n<li>\n<p>响应头</p>\n<ul>\n<li>Content-Language: zh-CN</li>\n<li>Content-Type: text/html; charset=utf-8</li>\n<li>字符集在响应头中没有单独的字段, 而是作为 Content-Type 的后半部分</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><code class=\"language-text\">Accept-Charset</code> 和 <code class=\"language-text\">Content-Language</code> 通常不会发送.</p>\n</blockquote>\n<h3>优先级</h3>\n<p>可以在 <code class=\"language-text\">Accept</code> <code class=\"language-text\">Accept-Encoding</code> <code class=\"language-text\">Accept-Language</code> 等请求头字段中的内容中添加 <code class=\"language-text\">q</code> 参数来设定优先级, 如 <code class=\"language-text\">Accept: text/html, application/xml;q=0.9</code> .</p>\n<p>优先级默认以及最大为 1, 最小为 0.01.</p>\n<p>注: 在此处 <code class=\"language-text\">;</code> 的断句小于 <code class=\"language-text\">,</code> , 表示仅作用于分号之前的一个内容.</p>\n<h3>响应头中的 Vary</h3>\n<p>表示服务器在内容协商时参考的请求头字段, 如:</p>\n<p><code class=\"language-text\">Vary: Accept-Encoding,User-Agent,Accept</code></p>\n<p>请求头变化时, Vary 也可能变化, 主要用于在传输链路中间的代理服务器实现缓存服务, 后文 <strong>缓存代理</strong> 部分详述.</p>\n<h2>大文件传输</h2>\n<h3>分块传输/Transfer-Encoding</h3>\n<ul>\n<li>\n<p>响应头: <code class=\"language-text\">Transfer-Encoding: chunked</code></p>\n<ul>\n<li>与 <code class=\"language-text\">Content-Length</code> 字段互斥, 要么长度已知, 要么是 chunked(长度未知).</li>\n<li><code class=\"language-text\">Transfer-Encoding</code> 字段值可以是 <code class=\"language-text\">gzip</code> <code class=\"language-text\">deflate</code> 等, 表示压缩编码; 与 <code class=\"language-text\">Content-Encoding</code> 相比, <code class=\"language-text\">Transfer-Encoding</code> 在传输后将被自动解码.</li>\n</ul>\n</li>\n<li>\n<p>每个分块内容:</p>\n<ul>\n<li>length + CRLF</li>\n<li>chunked data + CRLF</li>\n</ul>\n</li>\n<li>\n<p>分块末尾</p>\n<ul>\n<li>0 + CRLF (length 为 0)</li>\n<li>CRLF (空行结尾)</li>\n<li>末尾允许有拖尾数据 <code class=\"language-text\">Trailer</code></li>\n</ul>\n</li>\n</ul>\n<h3>范围请求/Range</h3>\n<p>获取文件的一部分, 如视频进度拖拽、多线程并发下载、断点续传.</p>\n<p>服务器在响应头中添加 <code class=\"language-text\">Accept-Ranges: bytes</code> 来告知客户端支持范围请求.</p>\n<p>客户端在请求头中添加 <code class=\"language-text\">Range: bytes=x-y</code> 来进行范围请求.</p>\n<ul>\n<li>x、y 表示从 0 开始的偏移量</li>\n<li>x、y 可省略其中之一, 但 <code class=\"language-text\">-</code> 不能省略, 如: <code class=\"language-text\">bytes=10-</code> <code class=\"language-text\">bytes=-20</code></li>\n</ul>\n<p>服务器接收到 <code class=\"language-text\">Range</code> 字段后,</p>\n<ol>\n<li>检查范围是否合法, 不合法返回 416;</li>\n<li>若范围合法, 根据 Range 头偏移量读取文件片段, 确定状态码 206(Partial Content);</li>\n<li>服务器添加响应头字段 <code class=\"language-text\">Content-Range: bytes x-y/length</code> , length 表示总长度;</li>\n<li>通过 TCP 发送数据</li>\n</ol>\n<p>Range 是针对原文件的范围, 而不是压缩后的文件范围(除非原文件就是 gzip 的).</p>\n<p>条件范围请求 <code class=\"language-text\">If-Range</code> 在后文详述.</p>\n<h3>多段数据</h3>\n<p>在 <code class=\"language-text\">Range</code> 请求头中添加逗号分隔的多段范围, 如: <code class=\"language-text\">Range: bytes=0-9, 20-29</code>.</p>\n<p>响应头中多段数据得到的数据 MIME 类型为 <code class=\"language-text\">multipart/byteranges</code> , 同时需要给出段之间的 <code class=\"language-text\">boundary=xxx</code> , 如: <code class=\"language-text\">Content-Type: multipart/byterange; boundary=00000000001</code>.</p>\n<p>具体的数据如下</p>\n<ul>\n<li>以双“-”开头的分隔符: <code class=\"language-text\">--{boundary}</code> + CRLF</li>\n<li>数据类型: <code class=\"language-text\">Content-Type: type/subtype</code> + CRLF</li>\n<li>Range: <code class=\"language-text\">Content-Range: types x-y/length</code> + CRLF</li>\n<li>空行 CRLF</li>\n<li>分段数据 multipart data + CRLF</li>\n<li>(下一段数据)分隔符: <code class=\"language-text\">--{boundary}</code> + CRLF</li>\n<li>…其他数据</li>\n<li>分段结束: <code class=\"language-text\">--{boundary}--</code> + CRLF</li>\n</ul>\n<h2>连接管理/Connection</h2>\n<h3>短连接和长连接</h3>\n<p>HTTP 0.9/1.0 使用短连接, 收到响应后立刻关闭连接, 效率很低:</p>\n<ul>\n<li>TCP 三次握手建立连接 → 请求 → 响应 → TCP 四次握手断开连接</li>\n</ul>\n<p>HTTP/1.1 默认使用长连接, 在一次连接中收发多个请求-响应.</p>\n<ul>\n<li>请求头和响应头加 <code class=\"language-text\">Connection: keep-alive</code> 表示支持长连接</li>\n<li>请求头和响应头加 <code class=\"language-text\">Connection: close</code> 告知对方本次通信后关闭连接</li>\n<li>请求头和响应头加 <code class=\"language-text\">Keep-Alive: timeout=value</code> 限定超时时间(约束力不强,可能不遵守)</li>\n<li>Nginx 可以设置 <code class=\"language-text\">keepalive_timeout</code> 和 <code class=\"language-text\">keepalive_request</code> 规定一次连接的超时时间和最大请求数</li>\n<li>Connection 的另一个值 <code class=\"language-text\">Upgrade</code> 配合状态码 101, 表示协议升级, 如 HTTP 升级为 WebSocket</li>\n<li>HTTP 还有第三种连接方式 “pipeline”, 但主流浏览器都未实现, 事实上“废弃”了.</li>\n</ul>\n<h3>队首阻塞问题</h3>\n<p>HTTP 规定的“请求-响应”模型是先进先出的串行队列, 即 <strong>同域名</strong> 下收到前一次的响应后才能发起新请求, 一次收发过慢时会导致后续所有请求被阻塞.</p>\n<ul>\n<li>利用 HTTP 长连接特性对服务器发起大量请求, 导致服务器耗尽资源, 就是 <strong>DDoS</strong> .</li>\n</ul>\n<p>由于 HTTP/1.1 的“请求-应答”模型不能变, 只能通过数量来暂时“解决”质量问题:</p>\n<ul>\n<li>并发连接数: 浏览器支持 6~8 个同域并发长连接</li>\n<li>域名分片: 使用多个域名指向同一台服务器</li>\n</ul>\n<h2>重定向和跳转/Location</h2>\n<p>当状态码 301/302 时为重定向, 响应头 <code class=\"language-text\">Location</code> 标记重定向 URL.</p>\n<p><code class=\"language-text\">Location</code> 支持绝对和相对 URI, 如 <code class=\"language-text\">Location: /index.html</code> .</p>\n<p>循环跳转: 几个 URI 连续重定向导致无限循环, 浏览器可以检测循环跳转并提示失败.</p>\n<p><code class=\"language-text\">Refresh</code> 延时重定向, 如 <code class=\"language-text\">Refresh: 5; url=xxx</code> 表示 5 秒后跳转.</p>\n<p><code class=\"language-text\">Referer</code> 和 <code class=\"language-text\">Referrer-Policy</code> 表示浏览器跳转来源, 用于统计分析或防盗链.</p>\n<p><code class=\"language-text\">3xx</code> 状态码重定向由浏览器执行, 对于服务器来说是“外部重定向”, 服务器的“内部重定向”是在服务器中直接跳转 URI.</p>\n<h3>重定向相关状态码</h3>\n<ul>\n<li>301: 永久重定向, 会更新浏览器历史记录和书签;</li>\n<li>302: 临时重定向, 仅本次访问有效;</li>\n<li>\n<p>其他状态码, 浏览器和服务器不一定支持:</p>\n<ul>\n<li>303 See Other: 类似 302, 但要改为 <code class=\"language-text\">GET</code> 方法避免重复操作;</li>\n<li>307 Temporary Redirect: 类似 302, 要求重定向后的方法和实体不变;</li>\n<li>308 Permanent Redirect: 301 + 307, 永久重定向且方法和实体不变.</li>\n<li>300 Multiple Choices: 返回一个有多个链接选项的页面, 用户自行选择跳转</li>\n</ul>\n</li>\n</ul>\n<h2>Cookie</h2>\n<p>服务器在响应头添加 <code class=\"language-text\">Set-Cookie: key=value</code> , 给予客户端身份标识, 响应头可具有多个 <code class=\"language-text\">Set-Cookie</code> .</p>\n<p>客户端保存 Cookie 并在之后的请求头中添加 <code class=\"language-text\">Cookie: key1=value1; key2=value2</code> , 请求头的 <code class=\"language-text\">Cookie</code> 将多个 Cookie 合并为 <code class=\"language-text\">;</code> 分隔的形式.</p>\n<p>Cookie 最大 4K.</p>\n<p>Cookie 不属于 HTTP 标准, 所以语法上与别的属性不一致(分隔符是分号而非逗号).</p>\n<h3>Cookie 属性</h3>\n<p>一个真实 Cookie: <code class=\"language-text\">Set-Cookie: favorite=humburger; Max-Age=10; Expires=Fri, 07-Jun-19 08:19:00 GMT; Domain=www.xxx.com; Path=/; HttpOnly; SameSite=Strict</code></p>\n<p>有效期:</p>\n<ul>\n<li><code class=\"language-text\">Expires</code> 过期的时间点</li>\n<li><code class=\"language-text\">Max-Age</code> 有效时间(秒数)</li>\n<li>浏览器优先采用 <code class=\"language-text\">Max-Age</code> , 如果不指定有效期, 则为会话 Cookie 关闭失效.</li>\n</ul>\n<p>作用域:</p>\n<ul>\n<li><code class=\"language-text\">Domain</code> 域名</li>\n<li><code class=\"language-text\">Path</code> 路径, 使用 <code class=\"language-text\">/</code> 表示该域名下任意路径</li>\n<li>浏览器会进行对比, 如果请求 URI 不相符则不会发送 Cookie.</li>\n</ul>\n<p>安全性:</p>\n<ul>\n<li><code class=\"language-text\">HttpOnly</code> 禁止非 HTTP 协议方式访问,禁用 <code class=\"language-text\">document.cookie</code> 相关 API.</li>\n<li>\n<p><code class=\"language-text\">SameSite</code> 防范“跨站请求伪造”(XSRF)攻击</p>\n<ul>\n<li><code class=\"language-text\">SameSite=Strict</code> 限定 Cookie 不能随着跳转链接跨站发送</li>\n<li><code class=\"language-text\">SameSite=Lax</code> 允许 GET/HEAD 等安全方法, 禁止 POST 跨站发送</li>\n</ul>\n</li>\n<li><code class=\"language-text\">Secure</code> 该 Cookie 只能用 HTTPS 协议加密传输, 但 Cookie 本身在浏览器中还是明文存在</li>\n</ul>\n<blockquote>\n<p>防范 XSS(跨站脚本攻击): <code class=\"language-text\">HttpOnly</code> 禁止 JS 脚本访问 Cookie; <code class=\"language-text\">Secure</code> 只在 HTTPS 时加密传输 Cookie.</p>\n</blockquote>\n<h3>Cookie 应用</h3>\n<ul>\n<li>身份识别: 登录信息、会话事务等</li>\n<li>广告追踪: 用户被广告商加上 Cookie, 实现精准推送</li>\n</ul>\n<h2>Cache-Control</h2>\n<h3>服务器端的缓存控制</h3>\n<p>服务器在响应头中添加 <code class=\"language-text\">Cache-Control</code> 控制浏览器缓存资源, 如 <code class=\"language-text\">Cache-Control: max-age=30</code> .</p>\n<ul>\n<li><code class=\"language-text\">max-age</code> 有效期(秒), 从响应报文的创建时刻开始计算.</li>\n<li><code class=\"language-text\">no_store</code> 不允许缓存</li>\n<li>\n<p><code class=\"language-text\">no_cache</code> (语义相反)可以缓存, 需在服务器验证缓存是否有新版本</p>\n<ul>\n<li>相当于 <code class=\"language-text\">max-age=0, must_revalidate</code></li>\n</ul>\n</li>\n<li><code class=\"language-text\">must-revalidate</code> 缓存未过期可使用, 过期需验证</li>\n</ul>\n<h3>浏览器端的缓存控制</h3>\n<p>不使用缓存数据:</p>\n<ul>\n<li>刷新按钮: 浏览器在请求头中添加 <code class=\"language-text\">Cache-Control: max-age=0</code> , 表示越过缓存获取新数据;</li>\n<li>强制刷新(Ctrl+F5 或 Command+R): 请求头添加 <code class=\"language-text\">Cache-Control: no-cache</code> , 通常与刷新效果相同, 取决于服务器处理.</li>\n</ul>\n<p>使用缓存数据的情况: 请求头中无 <code class=\"language-text\">Cache-Control</code> 属性</p>\n<ul>\n<li>前进/后退 按钮</li>\n<li>重定向跳转</li>\n</ul>\n<h3>条件请求</h3>\n<p>先验证缓存是否有效, 若无效再请求新数据 需要两次请求, 成本过高. 所以 HTTP 定义了一系列 <code class=\"language-text\">If</code> 开头的条件请求字段来合并数据验证和请求.</p>\n<p>在首次请求中, 服务器在响应头中添加 <code class=\"language-text\">Last-Modified</code> 和 <code class=\"language-text\">ETag</code> 属性</p>\n<p>通过缓存的更新时间:</p>\n<ul>\n<li>浏览器在请求头添加 <code class=\"language-text\">If-Modified-Since</code> 属性</li>\n<li>若缓存无更新, 服务器在响应头添加 <code class=\"language-text\">Last-Modified</code> 属性并返回”304 Not Modified”, 浏览器更新缓存有效期</li>\n</ul>\n<p>通过 ETag(资源标识):</p>\n<ul>\n<li>浏览器在请求头添加 <code class=\"language-text\">If-None-Match: &quot;xxxx&quot;</code></li>\n<li>若本资源无更新则返回”304 Not Modified”并更新有效期</li>\n<li>ETag 有”强” “弱”之分, 以 “W/”开头的为弱 ETag, 只要求资源在语义上无变化, 但内部可能发生变化; 强 ETag 要求资源在字节级别完全相符.</li>\n</ul>\n<h2>Proxy</h2>\n<p><code class=\"language-text\">Via</code> 在请求和响应头可以出现, 没经过一个代理就追加一个代理主机名/域名, 如 <code class=\"language-text\">Via: proxy1, proxy2</code> .</p>\n<ul>\n<li>有的响应报文会使用 <code class=\"language-text\">X-Via</code> , 与 <code class=\"language-text\">Via</code> 含义相同</li>\n</ul>\n<p>两个常用的事实上的标准(非 HTTP 标准):</p>\n<ul>\n<li>\n<p><code class=\"language-text\">X-Forwarded-For</code> 与 <code class=\"language-text\">Via</code> 类似, 但追加的是请求方的 IP 地址.</p>\n<ul>\n<li><code class=\"language-text\">X-Forwarded-Host</code> 记录主机名</li>\n<li><code class=\"language-text\">X-Forwarded-Proto</code> 记录协议名</li>\n</ul>\n</li>\n<li><code class=\"language-text\">X-Real-IP</code> 记录客户端 IP 地址, 无中间代理信息.</li>\n</ul>\n<h3>抓包含代理的通信过程</h3>\n<ul>\n<li>客户端与代理的 80 端口通过三次握手建立 TCP 连接;</li>\n<li>客户端向代理发送 HTTP 请求, 代理接收并返回 ACK 确认;</li>\n<li>代理与源服务器通过三次握手建立 TCP 连接;</li>\n<li>代理向源服务器发送 HTTP 请求, 源服务器接收并返回 ACK 确认;</li>\n<li>源服务器向代理发送 HTTP 响应, 代理接收并返回 ACK 确认;</li>\n<li>代理与源服务器通过四次挥手断开 TCP 连接;</li>\n<li>代理将响应数据发给客户端, 客户端接收并返回 ACK 确认.</li>\n</ul>\n<h3>代理协议</h3>\n<p>由于 <code class=\"language-text\">X-Forwarded-For</code> 要解析和修改 HTTP Headers, 会影响性能, 在加密通信中甚至无法实现, 所以出现了一个事实标准 <strong>代理协议/The PROXY protocol</strong> .</p>\n<p>代理协议有 v1 和 v2 两个版本:</p>\n<ul>\n<li>\n<p>v1: 明文, 在 HTTP 报文前增加一行 ASCII 码文本:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token constant\">PROXY</span> <span class=\"token constant\">TCP4</span> <span class=\"token number\">1.1</span><span class=\"token number\">.1</span><span class=\"token number\">.1</span> <span class=\"token number\">2.2</span><span class=\"token number\">.2</span><span class=\"token number\">.2</span> <span class=\"token number\">55555</span> <span class=\"token number\">80</span>\\r\\n\n<span class=\"token constant\">GET</span> <span class=\"token operator\">/</span> <span class=\"token constant\">HTTP</span><span class=\"token operator\">/</span><span class=\"token number\">1.1</span>\\r\\n\n<span class=\"token operator\">...</span></code></pre></div>\n<ul>\n<li>必须 <code class=\"language-text\">PROXY</code> 开头, 放在 HTTP 报文首行之前</li>\n<li><code class=\"language-text\">TCP4</code> 表示客户端的 IP 地址类型</li>\n<li>之后是请求方地址, 应答方地址, 请求方端口, 应答方端口号</li>\n<li>最后与 HTTP 报文一样以回车换行结束</li>\n</ul>\n</li>\n<li>v2: 非明文二进制格式, 相对复杂可自行查阅.</li>\n</ul>\n<h2>Cache Proxy</h2>\n<p>处于客户端和源服务器之间, 作为数据的中转站.</p>\n<p>面向源服务器时是客户端, 面相客户端时是服务器.</p>\n<h3>服务端的缓存控制</h3>\n<p>在<code class=\"language-text\">Cache-Control</code> 响应头中可以对客户端和代理的缓存策略进行配置.</p>\n<p>首先是四个基本属性 <code class=\"language-text\">max-age</code> <code class=\"language-text\">no_store</code> <code class=\"language-text\">no_cache</code> <code class=\"language-text\">must-revalidate</code> 可以通过添加 <code class=\"language-text\">private</code> 或 <code class=\"language-text\">public</code> 约束客户端和代理的缓存策略:</p>\n<ul>\n<li><code class=\"language-text\">private</code> 表示客户端私有缓存, 如用户信息 Cookie.</li>\n<li><code class=\"language-text\">public</code> 表示客户端与代理都可以进行缓存</li>\n</ul>\n<p>其次, <code class=\"language-text\">Cache-Control</code> 还可以添加 <code class=\"language-text\">must-revalidate</code> 或 <code class=\"language-text\">proxy-revalidate</code> 属性, 用于说明在缓存失效时必须回源服务器验证还是只验证代理即可.</p>\n<p><code class=\"language-text\">s-maxage</code> 用于单独标识代理端的缓存生效时间, 与客户端的 <code class=\"language-text\">max-age</code> 类似.</p>\n<p><code class=\"language-text\">no-transform</code> 代理专用属性, 表示禁止对数据进行优化处理(一些代理可能会对某些数据进行一些优化处理).</p>\n<p><strong>注意:</strong> 服务器设置完 <code class=\"language-text\">Cache-Control</code> 后要添加 <code class=\"language-text\">Last-modified</code> 或 <code class=\"language-text\">Etag</code> 响应头才能使用条件请求.</p>\n<h3>客户端的缓存控制</h3>\n<p>在 <strong>Cache-Control</strong> 部分讲述的的浏览器缓存控制对代理同样有效, 即通过 <code class=\"language-text\">max-age</code> <code class=\"language-text\">no_store</code> <code class=\"language-text\">no_cache</code> 属性作用于源服务器和代理来进行缓存控制.</p>\n<p>还有两个属性用于声明客户端对缓存有效期的偏移量限定:</p>\n<ul>\n<li><code class=\"language-text\">max-stale</code> 可接受缓存过期 x 秒</li>\n<li><code class=\"language-text\">min-fresh</code> 缓存必须在当前以及 x 秒后未过期</li>\n</ul>\n<p><code class=\"language-text\">only-if-cached</code> 属性表示客户端只接受代理缓存的数据, 如果代理没有缓存或缓存过期, 就返回 504.</p>\n<h3>缓存数据匹配</h3>\n<p>在 <strong>i18n</strong> 部分提到过 <code class=\"language-text\">Vary</code> 字段, 表示服务器在内容协商时参考的请求头字段, 可以作为报文的一个版本标记. 如: <code class=\"language-text\">Vary: Accept-Encoding,User-Agent,Accept</code> , 缓存代理会存储这些版本. 当再次收到相同请求时, 代理读取缓存的 <code class=\"language-text\">Vary</code> , 匹配时缓存数据.</p>\n<h3>缓存清理</h3>\n<p>常用的做法是使用自定义请求方发 <code class=\"language-text\">PURGE</code> 来告诉代理服务器删除本 URI 对应的缓存数据.</p>\n<p>需要进行缓存清理的场景: 缓存数据过期; 源服务器存在新数据; 一些无用或有害数据.</p>","frontmatter":{"title":"HTTP之二：HTTP Headers","date":"August 10, 2021","description":"按照数据编码、国际化、文件传输、连接管理、重定向、Cookie、缓存控制、代理、缓存代理等类别, 详细描述了常用HTTP Headers的使用方法和要点."}},"previous":{"fields":{"slug":"/npm/"},"frontmatter":{"title":"NPM/Yarn包管理策略与最佳实践"}},"next":null},"pageContext":{"id":"79d2e07e-9544-55b6-a161-bf95ddf8e04d","previousPostId":"b30c72fb-0f1d-5dd1-ab70-c98c5fa4ac3c","nextPostId":null}},"staticQueryHashes":["2841359383","3257411868"]}