{"componentChunkName":"component---src-templates-blog-post-js","path":"/typescript-type-guards/","result":{"data":{"site":{"siteMetadata":{"title":"按太阳穴轮刮眼眶"}},"markdownRemark":{"id":"418fed14-5d5e-52d4-947e-9bc82b303e7c","excerpt":"Build-in Type Guards 解决方案: Custom Type Guards A generic(范型) type guard 场景: 当一个变量拥有复合类型, 在某些情况下我们需要对其进行类型断言. 比如: 学生体检时, 除了若干公共体检项目外, 男生还需要检查 A 项目, 女生需要检查 B…","html":"<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#build-in-type-guards\">Build-in Type Guards</a></li>\n<li><a href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-custom-type-guards\">解决方案: Custom Type Guards</a></li>\n<li><a href=\"#a-generic%E8%8C%83%E5%9E%8B-type-guard\">A generic(范型) type guard</a></li>\n</ul>\n</div>\n<p>场景: 当一个变量拥有复合类型, 在某些情况下我们需要对其进行类型断言.</p>\n<p>比如: 学生体检时, 除了若干公共体检项目外, 男生还需要检查 A 项目, 女生需要检查 B 项目, 男女生体检结果汇总在一个表中. 在实际操作中, 我们需要根据体检人的 sex(性别)字段来确定展示 A 项目还是 B 项目的体检结果. 代码如下:</p>\n<pre><code class=\"language-tsx\">interface Boy {\n  name: string\n  sex: SexEnum\n  itemA: string\n}\ninterface Girl {\n  name: string\n  sex: SexEnum\n  itemB: number\n}\ntype Student = Boy | Girl\n\nlet s: Student = getOne()\nif (s.sex === SexEnum.Boy) {\n  console.log(s.itemA) // error!\n}\n</code></pre>\n<p>在代码中, 编译器无法确定 <code>s</code> 为 <code>Boy</code> 类型, 似乎只能通过丑陋的 <code>as unknow as Boy</code> 或 <code>@ts-ignore</code> 来绕过错误.</p>\n<h2 id=\"build-in-type-guards\" style=\"position:relative;\"><a href=\"#build-in-type-guards\" aria-label=\"build in type guards permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Build-in Type Guards</h2>\n<p>JS 中内置的 Type Guards 有 <code>typeof</code> 和 <code>instanceof</code> , 但都无法解决问题:</p>\n<ul>\n<li><code>typeof</code> 只能判断基本类型</li>\n<li><code>instanceof</code> 只能应用在 class 中, 函数式编程中极少使用 class, 所以作用有限</li>\n</ul>\n<h2 id=\"解决方案-custom-type-guards\" style=\"position:relative;\"><a href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-custom-type-guards\" aria-label=\"解决方案 custom type guards permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>解决方案: Custom Type Guards</h2>\n<p>示例代码:</p>\n<pre><code class=\"language-tsx\">const isBoy = (student: Student): student is Boy => student.sex === SexEnum.Boy\n\n// 另一种写法\nconst isBoy = (student: Student): student is Boy =>\n  (student as Boy).itemA !== undefine\n\nlet s: Student = getOne()\nif (isBoy(s)) {\n  console.log(s.itemA) // no error\n}\n</code></pre>\n<p>关键点:</p>\n<ul>\n<li>返回值应声明为 <code>variable is Type</code> 的形式, 如  <code>student is Boy</code></li>\n<li>函数体返回一个可以进行类型断言的 bool 值, 如  <code>student.sex === SexEnum.Boy</code> .</li>\n</ul>\n<h2 id=\"a-generic范型-type-guard\" style=\"position:relative;\"><a href=\"#a-generic%E8%8C%83%E5%9E%8B-type-guard\" aria-label=\"a generic范型 type guard permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>A generic(范型) type guard</h2>\n<p>如果需要编写许多 Type Guards, 使用 custom 的方式将会十分繁复, 不够 DRY.</p>\n<p>Generic Type Guard:</p>\n<pre><code class=\"language-jsx\">export const isOfType = &#x3C;T>(\n  varToBeChecked: any,\n  propertyToCheckFor: keyof T\n): varToBeChecked is T =>\n  (varToBeChecked as T)[propertyToCheckFor] !== undefined;\n</code></pre>\n<p>Use case:</p>\n<pre><code class=\"language-jsx\">if (isOfType &#x3C; Car > (item, \"turnSteeringWheel\")) {\n  // 此处item被成功断言为Car\n} else {\n  console.log(\"Dude, where's my car?!\")\n}\n</code></pre>\n<blockquote>\n<p>问题: 只通过一个属性来断言类型, 有时不够安全. 需要根据实际情况进行修改, 如传入属性列表或其他配置项.</p>\n</blockquote>","frontmatter":{"title":"TypeScript Type Guards","date":"February 09, 2020","description":"TypeScript中对复合类型进行类型断言"}},"previous":{"fields":{"slug":"/caged/"},"frontmatter":{"title":"CAGED Guitar System"}},"next":{"fields":{"slug":"/html5/"},"frontmatter":{"title":"HTML5技术扫盲"}}},"pageContext":{"id":"418fed14-5d5e-52d4-947e-9bc82b303e7c","previousPostId":"53de9a82-1068-5a59-9032-e1dbd0e16ad2","nextPostId":"7e8300d3-7450-56f6-9160-2f8a0da57a8b"}},"staticQueryHashes":["2841359383","3257411868"]}