{"componentChunkName":"component---src-templates-blog-post-js","path":"/npm/","result":{"data":{"site":{"siteMetadata":{"title":"按太阳穴轮刮眼眶"}},"markdownRemark":{"id":"b30c72fb-0f1d-5dd1-ab70-c98c5fa4ac3c","excerpt":"NPM NPM 安装机制 执行  : 读取 npm 配置文件  配置文件优先级: 项目级 > 用户级 > 全局 > npm…","html":"<h2>NPM</h2>\n<h3>NPM 安装机制</h3>\n<p>执行 <code class=\"language-text\">npm install</code> :</p>\n<ol>\n<li>\n<p>读取 npm 配置文件 <code class=\"language-text\">.npmrc</code></p>\n<p>配置文件优先级: 项目级 > 用户级 > 全局 > npm 内置</p>\n</li>\n<li>\n<p>检查是否存在 <code class=\"language-text\">package-lock.json</code> 文件:</p>\n<ul>\n<li>若不存在, 则根据 <code class=\"language-text\">package.json</code> 递归构建依赖树并从缓存或远程仓库下载相关资源, 并生成 <code class=\"language-text\">package-lock.json</code> 文件;</li>\n<li>若存在, 则对比 <code class=\"language-text\">package-lock.json</code> 和 <code class=\"language-text\">package.json</code> 文件中声明的依赖规范是否一致:</li>\n<li>若一致, 直接使用 <code class=\"language-text\">package-lock.json</code> 中的信息从缓存或远程仓库加载依赖文件;</li>\n<li>若不一致, NPM v5.4.2+ 会按照 <code class=\"language-text\">package.json</code> 文件安装依赖并更新 <code class=\"language-text\">package-lock.json</code> 文件(NPM 旧版本的处理方式有所不同, 详见下文).</li>\n</ul>\n</li>\n<li>\n<p>构建扁平化依赖树: 无论是直接依赖还是嵌套依赖, 都优先将依赖包放在 <code class=\"language-text\">node_modules</code> 根目录.</p>\n<p>当遇到相同模块且版本冲突时, 将后者放在当前模块的 <code class=\"language-text\">node_modules</code> 目录下.</p>\n</li>\n</ol>\n<p><strong>NPM 不同版本对于 <code class=\"language-text\">package-lock.json</code> 文件处理方式的不同, 可能导致安装的依赖包版本不一致, 所以团队内应保持 NPM 版本一致.</strong></p>\n<h3>NPM 缓存机制</h3>\n<p>获取 NPM 本地缓存路径: <code class=\"language-text\">npm config get cache</code> , 默认为 <code class=\"language-text\">~/.npm</code> .</p>\n<p>缓存路径下的 <code class=\"language-text\">_cacache</code> 目录下有三个子目录:</p>\n<ul>\n<li><code class=\"language-text\">content-v2</code> 二进制文件, 将此目录扩展名改为 <code class=\"language-text\">.tgz</code> 并解压则可以得到依赖包资源</li>\n<li><code class=\"language-text\">index-v5</code> 同样可通过修改扩展名解压, 是 <code class=\"language-text\">content-v2</code> 资源的索引文件</li>\n<li><code class=\"language-text\">tmp</code> 临时文件</li>\n</ul>\n<p>NPM 缓存策略: 执行 <code class=\"language-text\">npm install</code> 时, 若缓存中存在依赖包, 则通过 <code class=\"language-text\">pacote</code> 将依赖包解压到对应的 <code class=\"language-text\">node_modules</code> 目录下; 若缓存中不存在, 则先从远程仓库下载依赖包到缓存中, 再从缓存解压到项目 <code class=\"language-text\">node_modules</code> 中.</p>\n<p>在安装资源时, 根据 <code class=\"language-text\">package-lock.json</code> 中依赖包的 <code class=\"language-text\">integrity</code> <code class=\"language-text\">name</code> 和 <code class=\"language-text\">version</code> 信息生成一个唯一的 <code class=\"language-text\">key</code>, 根据这个 <code class=\"language-text\">key</code> 从 <code class=\"language-text\">index-v5</code> 目录中寻找缓存资源的 <code class=\"language-text\">hash</code> , 如果找到了就可以从 <code class=\"language-text\">content-v2</code> 中找到对应的 tar 包, 通过 <code class=\"language-text\">pacote</code> 将二进制文件解压到项目的 <code class=\"language-text\">node_modules</code> 中.</p>\n<blockquote>\n<p>NPM v5 之前的缓存文件是以 <code class=\"language-text\">{cache}/{name}/{version}</code> 的形式直接存储在 <code class=\"language-text\">.npm</code> 目录下.</p>\n</blockquote>\n<h3><code class=\"language-text\">npm link</code> 和 <code class=\"language-text\">npx</code></h3>\n<p><code class=\"language-text\">npm link</code> 为目标模块创建软连接, 将其链接到全局安装路径中, 可用于在模块发布之前在本地调试和使用.</p>\n<p><code class=\"language-text\">npx</code> 的两个作用:</p>\n<ul>\n<li>可直接执行 <code class=\"language-text\">node_modules/.bin</code> 和 环境变量 <code class=\"language-text\">PATH</code> 中的命令, 在之前只能通过在 <code class=\"language-text\">package.json</code> 中定义 <code class=\"language-text\">script</code> 或手动定位到命令所在目录来执行;</li>\n<li>执行一个需要安装依赖的命令, 在临时目录中安装依赖, 并在执行完成后删除相关依赖, 避免在全局安装模块. 可用于使用脚手架生成项目: <code class=\"language-text\">npx create-react-app my-app</code> .</li>\n</ul>\n<h3><code class=\"language-text\">package-lock.json</code> 中的依赖</h3>\n<p><code class=\"language-text\">package-lock.json</code> 文件中的 <code class=\"language-text\">dependency</code> 主要有以下属性:</p>\n<ul>\n<li>Version：版本号</li>\n<li>Resolved：安装源（下载地址）</li>\n<li>Integrity：表明包完整性的 Hash 值</li>\n<li>Dev：该依赖是否为顶级模块的开发依赖或者是传递依赖</li>\n<li>requires：需要的所有依赖项, 对应该依赖包 <code class=\"language-text\">package.json</code> 中 <code class=\"language-text\">dependencies</code> 中的依赖项</li>\n<li>dependencies：依赖包 <code class=\"language-text\">node_modules</code> 中依赖的包, 当子依赖的依赖与当前根目录中的依赖冲突后才有此属性</li>\n</ul>\n<h3><code class=\"language-text\">lockfiles</code> 与 NPM 版本问题总结</h3>\n<ul>\n<li>早期 NPM 使用 <code class=\"language-text\">npm-shrinkwrap.json</code> 锁定版本, 与 <code class=\"language-text\">package-lock.json</code> 不同点在于：NPM 包发布时默认将 <code class=\"language-text\">npm-shrinkwrap.json</code> 同时发布;</li>\n<li>\n<p><code class=\"language-text\">package-lock.json</code> 是 NPM v5.x 版本新增特性, 而 v5.6 以上才逐步稳定, 在 5.0 - 5.6 之间对 <code class=\"language-text\">package-lock.json</code> 的处理逻辑进行过几次更新:</p>\n<ul>\n<li>在 v5.0.x 中, <code class=\"language-text\">npm install</code> 时根据 <code class=\"language-text\">package-lock.json</code> 文件下载, 不考虑 <code class=\"language-text\">package.json</code> 内容;</li>\n<li>v5.1.0 - v5.4.2, <code class=\"language-text\">npm install</code> 会无视 <code class=\"language-text\">package-lock.json</code> 文件而下载最新的依赖包并更新 <code class=\"language-text\">package-lock.json</code> ;</li>\n<li>v5.4.2 后：</li>\n<li>如果项目只有 <code class=\"language-text\">package.json</code> 文件, <code class=\"language-text\">npm install</code> 后会根据它生成一个 <code class=\"language-text\">package-lock.json</code> 文件;</li>\n<li>如果存在 <code class=\"language-text\">package.json</code> 和 <code class=\"language-text\">package-lock.json</code> 文件，同时 <code class=\"language-text\">package.json</code> 的 <code class=\"language-text\">semver-range</code> 版本 和 <code class=\"language-text\">package-lock.json</code> 中版本兼容, <code class=\"language-text\">npm install</code> 会根据 <code class=\"language-text\">package-lock.json</code> 下载;</li>\n<li>如果存在 <code class=\"language-text\">package.json</code> 和 <code class=\"language-text\">package-lock.json</code> 且 <code class=\"language-text\">package.json</code> 的 <code class=\"language-text\">semver-range</code> 版本和 <code class=\"language-text\">package-lock.json</code> 中版本不兼容, <code class=\"language-text\">npm install</code> 时 <code class=\"language-text\">package-lock.json</code> 将会更新到兼容 <code class=\"language-text\">package.json</code> 的版本;</li>\n<li>如果 <code class=\"language-text\">package-lock.json</code> 和 <code class=\"language-text\">npm-shrinkwrap.json</code> 都存在于项目根目录, <code class=\"language-text\">package-lock.json</code> 将会被忽略.</li>\n</ul>\n</li>\n</ul>\n<h3><code class=\"language-text\">xxxDependencies</code> 声明总结</h3>\n<p>NPM 中共有 5 中依赖声明:</p>\n<ul>\n<li><code class=\"language-text\">dependencies</code> 项目依赖, NPM 包被下载时, 它的项目依赖会被一起下载.</li>\n<li><code class=\"language-text\">devDependencies</code> 开发依赖, 只在开发阶段或开发环境用到的依赖. 在实际业务中只是一个规范, 依赖是否被打包完全取决于项目中是否引入了该模块, 开发依赖在 <code class=\"language-text\">npm install</code> 时也会被下载.</li>\n<li><code class=\"language-text\">peerDependencies</code> 同版本依赖, 一般用于在基于某个框架或核心库做扩展库或中间件时, 来声明宿主环境, 如开发基于 React 的 UI 组件库时就可以声明 <code class=\"language-text\">&quot;peerDependencies&quot;: { &quot;react&quot;: &quot;^17.0.0&quot; }</code> .</li>\n<li><code class=\"language-text\">bundledDependencies</code> 捆绑依赖, 在 <code class=\"language-text\">npm pack</code> 时会在压缩包中包含捆绑依赖中声明的安装包; 业务方使用 <code class=\"language-text\">npm install xx</code> 安装压缩包时也会安装捆绑依赖中声明的包. 需要注意的是, 此包必须在 <code class=\"language-text\">dependencies</code> 或 <code class=\"language-text\">devDependencies</code> 中声明过.</li>\n<li><code class=\"language-text\">optionalDependencies</code> 可选依赖, 表示安装失败也不影响整个过程, 一般不建议使用.</li>\n</ul>\n<h2>CI 环境中的 NPM 优化</h2>\n<h3>使用 <code class=\"language-text\">npm ci</code> 代替 <code class=\"language-text\">npm install</code></h3>\n<p><code class=\"language-text\">npm ci</code> 是专用于 CI 环境的安装命令, 它与 <code class=\"language-text\">npm install</code> 的主要不同有:</p>\n<ul>\n<li>项目中必须存在 <code class=\"language-text\">package-lock.json</code> 和 <code class=\"language-text\">npm-shrinkwrap.json</code> ;</li>\n<li><code class=\"language-text\">npm ci</code> 完全根据 <code class=\"language-text\">package-lock.json</code> 安装依赖, 保证整个团队的依赖包完全一致, 同时安装过程也更迅速;</li>\n<li><code class=\"language-text\">npm ci</code> 执行安装时会删除现有的 <code class=\"language-text\">node_modules</code> 并重新安装;</li>\n<li><code class=\"language-text\">npm ci</code> 只能一次安装整个依赖包, 无法单独安装;</li>\n<li>若 <code class=\"language-text\">package-lock.json</code> 和 <code class=\"language-text\">package.json</code> 冲突会直接报错;</li>\n<li><code class=\"language-text\">npm ci</code> 不会修改 <code class=\"language-text\">package.json</code> 和 <code class=\"language-text\">package-lock.json</code> .</li>\n</ul>\n<p>基于 <code class=\"language-text\">npm ci</code> 命令的特性, 可得出以下 CI 环境中的 NPM 优化方法:</p>\n<ul>\n<li>提交 <code class=\"language-text\">package-lock.json</code> 到仓库;</li>\n<li>缓存 <code class=\"language-text\">node_modules</code> 文件;</li>\n</ul>\n<h3>适用于团队的 NPM 最佳实践</h3>\n<ul>\n<li>使用 NPM v5.4.2 以上的版本, 最好统一 Node.js 版本.</li>\n<li>项目初次搭建时使用 <code class=\"language-text\">npm install</code> 安装依赖, 并提交 package.json、package-lock.json, 不提交 node_modules 目录.</li>\n<li>其他成员首次 clone/checkout 项目后, 执行 <code class=\"language-text\">npm install</code> 安装依赖包.</li>\n<li>\n<p>升级依赖包：</p>\n<ul>\n<li>使用 <code class=\"language-text\">npm update</code> 升级到新的小版本;</li>\n<li>使用 <code class=\"language-text\">npm install @</code> 升级大版本;</li>\n<li>也可以手动修改 package.json 中的版本号并执行 <code class=\"language-text\">npm install</code> 升级版本;</li>\n<li>本地验证升级后无问题再提交新的 package.json、package-lock.json 文件.</li>\n</ul>\n</li>\n<li>降级依赖包：执行 <code class=\"language-text\">npm install @</code> 命令，验证没问题后提交新的 package.json、package-lock.json 文件.</li>\n<li>\n<p>删除依赖包：</p>\n<ul>\n<li>执行 <code class=\"language-text\">npm uninstall xx</code> 命令, 验证没问题后提交新的 package.json、package-lock.json 文件;</li>\n<li>或手动更改 package.json 删除依赖并执行 <code class=\"language-text\">npm install</code> 命令, 验证没问题后提交新的 package.json、package-lock.json 文件.</li>\n</ul>\n</li>\n<li>任何成员更新 package.json、package-lock.json 后, 其他成员在拉取代码后执行 <code class=\"language-text\">npm install</code> 更新依赖.</li>\n<li>禁止修改 package-lock.json.</li>\n<li>若 package-lock.json 出现冲突或问题，建议删除本地 package-lock.json 文件, 引入远程的 package-lock.json 和 package.json 文件, 再执行 <code class=\"language-text\">npm install</code> .</li>\n</ul>\n<h2>Yarn</h2>\n<p>Yarn 是在 NPM 处于 v3 时为了解决 NPM 在依赖包的版本确定性(无 lock 文件)、扁平化安装、网络性能、缓存机制等方面的问题而出现的包管理器.</p>\n<p>目前 NPM 也吸收了 Yarn 的很多优势特点, 改进了本身存在的诸多问题, 所以二者目前并没有明显的优劣之分.</p>\n<p><code class=\"language-text\">yarn.lock</code> 与 <code class=\"language-text\">package-lock.json</code> 相比, 除了文件格式不同, 另一个显著区别是其中的 <strong>子依赖</strong> 的版本号不是固定版本, 而是类似于 <code class=\"language-text\">^4.0.1</code> 这样的版本规则, 这意味着 <code class=\"language-text\">yarn.lock</code> 必须和 <code class=\"language-text\">package.json</code> 文件相配合才能确定 <code class=\"language-text\">node_modules</code> 目录结构.</p>\n<p>Yarn 和 NPM 的另一个显著区别是: Yarn 默认使用 <code class=\"language-text\">prefer-online</code> 模式, 即优先使用网络资源, 请求失败后才去读取缓存资源.</p>\n<h3>Yarn 安装机制</h3>\n<p>Yarn 的安装过程可分为 5 个步骤:</p>\n<ol>\n<li>\n<p>Checking</p>\n<p>检查项目中是否存在 npm 相关文件如 <code class=\"language-text\">package-lock.json</code> 等, 若有会提示用户可能导致冲突; 也会检查当前环境的操作系统、CPU 等信息.</p>\n</li>\n<li>\n<p>Resolving</p>\n<p>解析依赖树:</p>\n<ol>\n<li>获取首层依赖, 即 <code class=\"language-text\">package.json</code> 中的 <code class=\"language-text\">dependencies</code> <code class=\"language-text\">devDependencies</code> 和 <code class=\"language-text\">optionalDependencies</code> 内容</li>\n<li>遍历首层依赖, 逐个递归查找嵌套依赖: 对于每个包, 尝试从 <code class=\"language-text\">yarn.lock</code> 中获取版本信息, 若获取不到, 则从远程仓库获取满足版本规则的最高版本的版本信息.</li>\n<li>通过步骤 b 最终得到所有依赖的具体版本信息和下载地址.</li>\n</ol>\n</li>\n<li>\n<p>Fetching</p>\n<p>检查缓存中是否存在当前依赖包, 对于不存在的包会维护一个 fetch 队列, 将依赖包下载到缓存目录.</p>\n</li>\n<li>\n<p>Linking</p>\n<p>将依赖包从缓存目录 <strong>扁平化</strong> 复制到项目 <code class=\"language-text\">node_modules</code> 下.</p>\n</li>\n<li>\n<p>Building</p>\n<p>对存在二进制包的依赖包进行编译.</p>\n</li>\n</ol>\n<h2>依赖嵌套问题</h2>\n<h3>早期 NPM 的树形依赖</h3>\n<p>早期 NPM 的依赖包采用自然的树形依赖: 将项目的直接依赖放到项目 <code class=\"language-text\">node_modules</code> 根目录, 若直接依赖 A 还依赖模块 B, 则将模块 B 放在模块 A 的 <code class=\"language-text\">node_modules</code> 下. 在稍复杂的项目中形成“嵌套地狱”:</p>\n<ul>\n<li>依赖树层级过深, 一方面难以调试, 另一方面可能出现文件路径过长导致的一些问题;</li>\n<li>依赖树的不同分支可能存在重复的依赖包, 导致安装过慢、浪费空间.</li>\n</ul>\n<h3>扁平化依赖</h3>\n<p>对于没有版本冲突的依赖包, 扁平化地将依赖包放在 <code class=\"language-text\">node_modules</code> 根目录.</p>\n<p>存在版本冲突时则嵌套安装, 如 模块 A 依赖 模块 B-v1.0 , 模块 C 依赖 模块 B-v2.0 , 则将 模块 B-v2.0 安装在 模块 C 的 <code class=\"language-text\">node_modules</code> 中.</p>\n<p>冲突模块 B 不同版本的安装路径取决于模块 A 和 C 的安装顺序, 先安装的版本放在根目录.</p>\n<p>此时, 依赖包的安装顺序对依赖树影响很大: 若 模块 A 依赖 模块 B-v1.0 , 而 模块 C、D、E 都依赖 模块 B-2.0 , 则会导致 C、D、E 模块下都存在重复性的 模块 B-v2.0 .</p>\n<p>执行 <code class=\"language-text\">npm dedupe</code> 会尝试通过将依赖关系向上移动来尽可能删除重复依赖.</p>\n<p>Yarn 则会在安装依赖时自动执行 <code class=\"language-text\">dedupe</code> 命令.</p>","frontmatter":{"title":"NPM/Yarn包管理策略与最佳实践","date":"July 25, 2021","description":"详解npm包的安装机制和依赖管理策略, 并提出适用于团队的NPM最佳实践"}},"previous":{"fields":{"slug":"/http-1/"},"frontmatter":{"title":"HTTP探究之一:通识"}},"next":null},"pageContext":{"id":"b30c72fb-0f1d-5dd1-ab70-c98c5fa4ac3c","previousPostId":"9daf0fea-060c-53a0-a56b-4b40ea7eded5","nextPostId":null}},"staticQueryHashes":["2841359383","3257411868"]}