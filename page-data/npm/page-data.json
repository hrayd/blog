{"componentChunkName":"component---src-templates-blog-post-js","path":"/npm/","result":{"data":{"site":{"siteMetadata":{"title":"按太阳穴轮刮眼眶"}},"markdownRemark":{"id":"b30c72fb-0f1d-5dd1-ab70-c98c5fa4ac3c","excerpt":"NPM NPM 安装机制 NPM 缓存机制 npm link 和 npx package-lock.json 中的依赖 lockfiles 与 NPM 版本问题总结 xxxDependencies 声明总结 CI 环境中的 NPM 优化 使用 npm ci 代替 npm install 适用于团队的 NPM…","html":"<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#npm\">NPM</a></p>\n<ul>\n<li><a href=\"#npm-%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6\">NPM 安装机制</a></li>\n<li><a href=\"#npm-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6\">NPM 缓存机制</a></li>\n<li><a href=\"#npm-link-%E5%92%8C-npx\"><code>npm link</code> 和 <code>npx</code></a></li>\n<li><a href=\"#package-lockjson-%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96\"><code>package-lock.json</code> 中的依赖</a></li>\n<li><a href=\"#lockfiles-%E4%B8%8E-npm-%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93\"><code>lockfiles</code> 与 NPM 版本问题总结</a></li>\n<li><a href=\"#xxxdependencies-%E5%A3%B0%E6%98%8E%E6%80%BB%E7%BB%93\"><code>xxxDependencies</code> 声明总结</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#ci-%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84-npm-%E4%BC%98%E5%8C%96\">CI 环境中的 NPM 优化</a></p>\n<ul>\n<li><a href=\"#%E4%BD%BF%E7%94%A8-npm-ci-%E4%BB%A3%E6%9B%BF-npm-install\">使用 <code>npm ci</code> 代替 <code>npm install</code></a></li>\n<li><a href=\"#%E9%80%82%E7%94%A8%E4%BA%8E%E5%9B%A2%E9%98%9F%E7%9A%84-npm-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\">适用于团队的 NPM 最佳实践</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#yarn\">Yarn</a></p>\n<ul>\n<li><a href=\"#yarn-%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6\">Yarn 安装机制</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%E4%BE%9D%E8%B5%96%E5%B5%8C%E5%A5%97%E9%97%AE%E9%A2%98\">依赖嵌套问题</a></p>\n<ul>\n<li><a href=\"#%E6%97%A9%E6%9C%9F-npm-%E7%9A%84%E6%A0%91%E5%BD%A2%E4%BE%9D%E8%B5%96\">早期 NPM 的树形依赖</a></li>\n<li><a href=\"#%E6%89%81%E5%B9%B3%E5%8C%96%E4%BE%9D%E8%B5%96\">扁平化依赖</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h2 id=\"npm\" style=\"position:relative;\"><a href=\"#npm\" aria-label=\"npm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NPM</h2>\n<h3 id=\"npm-安装机制\" style=\"position:relative;\"><a href=\"#npm-%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6\" aria-label=\"npm 安装机制 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NPM 安装机制</h3>\n<p>执行 <code>npm install</code> :</p>\n<ol>\n<li>\n<p>读取 npm 配置文件 <code>.npmrc</code></p>\n<p>配置文件优先级: 项目级 > 用户级 > 全局 > npm 内置</p>\n</li>\n<li>\n<p>检查是否存在 <code>package-lock.json</code> 文件:</p>\n<ul>\n<li>若不存在, 则根据 <code>package.json</code> 递归构建依赖树并从缓存或远程仓库下载相关资源, 并生成 <code>package-lock.json</code> 文件;</li>\n<li>若存在, 则对比 <code>package-lock.json</code> 和 <code>package.json</code> 文件中声明的依赖规范是否一致:</li>\n<li>若一致, 直接使用 <code>package-lock.json</code> 中的信息从缓存或远程仓库加载依赖文件;</li>\n<li>若不一致, NPM v5.4.2+ 会按照 <code>package.json</code> 文件安装依赖并更新 <code>package-lock.json</code> 文件(NPM 旧版本的处理方式有所不同, 详见下文).</li>\n</ul>\n</li>\n<li>\n<p>构建扁平化依赖树: 无论是直接依赖还是嵌套依赖, 都优先将依赖包放在 <code>node_modules</code> 根目录.</p>\n<p>当遇到相同模块且版本冲突时, 将后者放在当前模块的 <code>node_modules</code> 目录下.</p>\n</li>\n</ol>\n<p><strong>NPM 不同版本对于 <code>package-lock.json</code> 文件处理方式的不同, 可能导致安装的依赖包版本不一致, 所以团队内应保持 NPM 版本一致.</strong></p>\n<h3 id=\"npm-缓存机制\" style=\"position:relative;\"><a href=\"#npm-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6\" aria-label=\"npm 缓存机制 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NPM 缓存机制</h3>\n<p>获取 NPM 本地缓存路径: <code>npm config get cache</code> , 默认为 <code>~/.npm</code> .</p>\n<p>缓存路径下的 <code>_cacache</code> 目录下有三个子目录:</p>\n<ul>\n<li><code>content-v2</code> 二进制文件, 将此目录扩展名改为 <code>.tgz</code> 并解压则可以得到依赖包资源</li>\n<li><code>index-v5</code> 同样可通过修改扩展名解压, 是 <code>content-v2</code> 资源的索引文件</li>\n<li><code>tmp</code> 临时文件</li>\n</ul>\n<p>NPM 缓存策略: 执行 <code>npm install</code> 时, 若缓存中存在依赖包, 则通过 <code>pacote</code> 将依赖包解压到对应的 <code>node_modules</code> 目录下; 若缓存中不存在, 则先从远程仓库下载依赖包到缓存中, 再从缓存解压到项目 <code>node_modules</code> 中.</p>\n<p>在安装资源时, 根据 <code>package-lock.json</code> 中依赖包的 <code>integrity</code> <code>name</code> 和 <code>version</code> 信息生成一个唯一的 <code>key</code>, 根据这个 <code>key</code> 从 <code>index-v5</code> 目录中寻找缓存资源的 <code>hash</code> , 如果找到了就可以从 <code>content-v2</code> 中找到对应的 tar 包, 通过 <code>pacote</code> 将二进制文件解压到项目的 <code>node_modules</code> 中.</p>\n<blockquote>\n<p>NPM v5 之前的缓存文件是以 <code>{cache}/{name}/{version}</code> 的形式直接存储在 <code>.npm</code> 目录下.</p>\n</blockquote>\n<h3 id=\"npm-link-和-npx\" style=\"position:relative;\"><a href=\"#npm-link-%E5%92%8C-npx\" aria-label=\"npm link 和 npx permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>npm link</code> 和 <code>npx</code></h3>\n<p><code>npm link</code> 为目标模块创建软连接, 将其链接到全局安装路径中, 可用于在模块发布之前在本地调试和使用.</p>\n<p><code>npx</code> 的两个作用:</p>\n<ul>\n<li>可直接执行 <code>node_modules/.bin</code> 和 环境变量 <code>PATH</code> 中的命令, 在之前只能通过在 <code>package.json</code> 中定义 <code>script</code> 或手动定位到命令所在目录来执行;</li>\n<li>执行一个需要安装依赖的命令, 在临时目录中安装依赖, 并在执行完成后删除相关依赖, 避免在全局安装模块. 可用于使用脚手架生成项目: <code>npx create-react-app my-app</code> .</li>\n</ul>\n<h3 id=\"package-lockjson-中的依赖\" style=\"position:relative;\"><a href=\"#package-lockjson-%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96\" aria-label=\"package lockjson 中的依赖 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>package-lock.json</code> 中的依赖</h3>\n<p><code>package-lock.json</code> 文件中的 <code>dependency</code> 主要有以下属性:</p>\n<ul>\n<li>Version：版本号</li>\n<li>Resolved：安装源（下载地址）</li>\n<li>Integrity：表明包完整性的 Hash 值</li>\n<li>Dev：该依赖是否为顶级模块的开发依赖或者是传递依赖</li>\n<li>requires：需要的所有依赖项, 对应该依赖包 <code>package.json</code> 中 <code>dependencies</code> 中的依赖项</li>\n<li>dependencies：依赖包 <code>node_modules</code> 中依赖的包, 当子依赖的依赖与当前根目录中的依赖冲突后才有此属性</li>\n</ul>\n<h3 id=\"lockfiles-与-npm-版本问题总结\" style=\"position:relative;\"><a href=\"#lockfiles-%E4%B8%8E-npm-%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93\" aria-label=\"lockfiles 与 npm 版本问题总结 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>lockfiles</code> 与 NPM 版本问题总结</h3>\n<ul>\n<li>早期 NPM 使用 <code>npm-shrinkwrap.json</code> 锁定版本, 与 <code>package-lock.json</code> 不同点在于：NPM 包发布时默认将 <code>npm-shrinkwrap.json</code> 同时发布;</li>\n<li>\n<p><code>package-lock.json</code> 是 NPM v5.x 版本新增特性, 而 v5.6 以上才逐步稳定, 在 5.0 - 5.6 之间对 <code>package-lock.json</code> 的处理逻辑进行过几次更新:</p>\n<ul>\n<li>在 v5.0.x 中, <code>npm install</code> 时根据 <code>package-lock.json</code> 文件下载, 不考虑 <code>package.json</code> 内容;</li>\n<li>v5.1.0 - v5.4.2, <code>npm install</code> 会无视 <code>package-lock.json</code> 文件而下载最新的依赖包并更新 <code>package-lock.json</code> ;</li>\n<li>v5.4.2 后：</li>\n<li>如果项目只有 <code>package.json</code> 文件, <code>npm install</code> 后会根据它生成一个 <code>package-lock.json</code> 文件;</li>\n<li>如果存在 <code>package.json</code> 和 <code>package-lock.json</code> 文件，同时 <code>package.json</code> 的 <code>semver-range</code> 版本 和 <code>package-lock.json</code> 中版本兼容, <code>npm install</code> 会根据 <code>package-lock.json</code> 下载;</li>\n<li>如果存在 <code>package.json</code> 和 <code>package-lock.json</code> 且 <code>package.json</code> 的 <code>semver-range</code> 版本和 <code>package-lock.json</code> 中版本不兼容, <code>npm install</code> 时 <code>package-lock.json</code> 将会更新到兼容 <code>package.json</code> 的版本;</li>\n<li>如果 <code>package-lock.json</code> 和 <code>npm-shrinkwrap.json</code> 都存在于项目根目录, <code>package-lock.json</code> 将会被忽略.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"xxxdependencies-声明总结\" style=\"position:relative;\"><a href=\"#xxxdependencies-%E5%A3%B0%E6%98%8E%E6%80%BB%E7%BB%93\" aria-label=\"xxxdependencies 声明总结 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>xxxDependencies</code> 声明总结</h3>\n<p>NPM 中共有 5 中依赖声明:</p>\n<ul>\n<li><code>dependencies</code> 项目依赖, NPM 包被下载时, 它的项目依赖会被一起下载.</li>\n<li><code>devDependencies</code> 开发依赖, 只在开发阶段或开发环境用到的依赖. 在实际业务中只是一个规范, 依赖是否被打包完全取决于项目中是否引入了该模块, 开发依赖在 <code>npm install</code> 时也会被下载.</li>\n<li><code>peerDependencies</code> 同版本依赖, 一般用于在基于某个框架或核心库做扩展库或中间件时, 来声明宿主环境, 如开发基于 React 的 UI 组件库时就可以声明 <code>\"peerDependencies\": { \"react\": \"^17.0.0\" }</code> .</li>\n<li><code>bundledDependencies</code> 捆绑依赖, 在 <code>npm pack</code> 时会在压缩包中包含捆绑依赖中声明的安装包; 业务方使用 <code>npm install xx</code> 安装压缩包时也会安装捆绑依赖中声明的包. 需要注意的是, 此包必须在 <code>dependencies</code> 或 <code>devDependencies</code> 中声明过.</li>\n<li><code>optionalDependencies</code> 可选依赖, 表示安装失败也不影响整个过程, 一般不建议使用.</li>\n</ul>\n<h2 id=\"ci-环境中的-npm-优化\" style=\"position:relative;\"><a href=\"#ci-%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84-npm-%E4%BC%98%E5%8C%96\" aria-label=\"ci 环境中的 npm 优化 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CI 环境中的 NPM 优化</h2>\n<h3 id=\"使用-npm-ci-代替-npm-install\" style=\"position:relative;\"><a href=\"#%E4%BD%BF%E7%94%A8-npm-ci-%E4%BB%A3%E6%9B%BF-npm-install\" aria-label=\"使用 npm ci 代替 npm install permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>使用 <code>npm ci</code> 代替 <code>npm install</code></h3>\n<p><code>npm ci</code> 是专用于 CI 环境的安装命令, 它与 <code>npm install</code> 的主要不同有:</p>\n<ul>\n<li>项目中必须存在 <code>package-lock.json</code> 和 <code>npm-shrinkwrap.json</code> ;</li>\n<li><code>npm ci</code> 完全根据 <code>package-lock.json</code> 安装依赖, 保证整个团队的依赖包完全一致, 同时安装过程也更迅速;</li>\n<li><code>npm ci</code> 执行安装时会删除现有的 <code>node_modules</code> 并重新安装;</li>\n<li><code>npm ci</code> 只能一次安装整个依赖包, 无法单独安装;</li>\n<li>若 <code>package-lock.json</code> 和 <code>package.json</code> 冲突会直接报错;</li>\n<li><code>npm ci</code> 不会修改 <code>package.json</code> 和 <code>package-lock.json</code> .</li>\n</ul>\n<p>基于 <code>npm ci</code> 命令的特性, 可得出以下 CI 环境中的 NPM 优化方法:</p>\n<ul>\n<li>提交 <code>package-lock.json</code> 到仓库;</li>\n<li>缓存 <code>node_modules</code> 文件;</li>\n</ul>\n<h3 id=\"适用于团队的-npm-最佳实践\" style=\"position:relative;\"><a href=\"#%E9%80%82%E7%94%A8%E4%BA%8E%E5%9B%A2%E9%98%9F%E7%9A%84-npm-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\" aria-label=\"适用于团队的 npm 最佳实践 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>适用于团队的 NPM 最佳实践</h3>\n<ul>\n<li>使用 NPM v5.4.2 以上的版本, 最好统一 Node.js 版本.</li>\n<li>项目初次搭建时使用 <code>npm install</code> 安装依赖, 并提交 package.json、package-lock.json, 不提交 node_modules 目录.</li>\n<li>其他成员首次 clone/checkout 项目后, 执行 <code>npm install</code> 安装依赖包.</li>\n<li>\n<p>升级依赖包：</p>\n<ul>\n<li>使用 <code>npm update</code> 升级到新的小版本;</li>\n<li>使用 <code>npm install @</code> 升级大版本;</li>\n<li>也可以手动修改 package.json 中的版本号并执行 <code>npm install</code> 升级版本;</li>\n<li>本地验证升级后无问题再提交新的 package.json、package-lock.json 文件.</li>\n</ul>\n</li>\n<li>降级依赖包：执行 <code>npm install @</code> 命令，验证没问题后提交新的 package.json、package-lock.json 文件.</li>\n<li>\n<p>删除依赖包：</p>\n<ul>\n<li>执行 <code>npm uninstall xx</code> 命令, 验证没问题后提交新的 package.json、package-lock.json 文件;</li>\n<li>或手动更改 package.json 删除依赖并执行 <code>npm install</code> 命令, 验证没问题后提交新的 package.json、package-lock.json 文件.</li>\n</ul>\n</li>\n<li>任何成员更新 package.json、package-lock.json 后, 其他成员在拉取代码后执行 <code>npm install</code> 更新依赖.</li>\n<li>禁止修改 package-lock.json.</li>\n<li>若 package-lock.json 出现冲突或问题，建议删除本地 package-lock.json 文件, 引入远程的 package-lock.json 和 package.json 文件, 再执行 <code>npm install</code> .</li>\n</ul>\n<h2 id=\"yarn\" style=\"position:relative;\"><a href=\"#yarn\" aria-label=\"yarn permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Yarn</h2>\n<p>Yarn 是在 NPM 处于 v3 时为了解决 NPM 在依赖包的版本确定性(无 lock 文件)、扁平化安装、网络性能、缓存机制等方面的问题而出现的包管理器.</p>\n<p>目前 NPM 也吸收了 Yarn 的很多优势特点, 改进了本身存在的诸多问题, 所以二者目前并没有明显的优劣之分.</p>\n<p><code>yarn.lock</code> 与 <code>package-lock.json</code> 相比, 除了文件格式不同, 另一个显著区别是其中的 <strong>子依赖</strong> 的版本号不是固定版本, 而是类似于 <code>^4.0.1</code> 这样的版本规则, 这意味着 <code>yarn.lock</code> 必须和 <code>package.json</code> 文件相配合才能确定 <code>node_modules</code> 目录结构.</p>\n<p>Yarn 和 NPM 的另一个显著区别是: Yarn 默认使用 <code>prefer-online</code> 模式, 即优先使用网络资源, 请求失败后才去读取缓存资源.</p>\n<h3 id=\"yarn-安装机制\" style=\"position:relative;\"><a href=\"#yarn-%E5%AE%89%E8%A3%85%E6%9C%BA%E5%88%B6\" aria-label=\"yarn 安装机制 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Yarn 安装机制</h3>\n<p>Yarn 的安装过程可分为 5 个步骤:</p>\n<ol>\n<li>\n<p>Checking</p>\n<p>检查项目中是否存在 npm 相关文件如 <code>package-lock.json</code> 等, 若有会提示用户可能导致冲突; 也会检查当前环境的操作系统、CPU 等信息.</p>\n</li>\n<li>\n<p>Resolving</p>\n<p>解析依赖树:</p>\n<ol>\n<li>获取首层依赖, 即 <code>package.json</code> 中的 <code>dependencies</code> <code>devDependencies</code> 和 <code>optionalDependencies</code> 内容</li>\n<li>遍历首层依赖, 逐个递归查找嵌套依赖: 对于每个包, 尝试从 <code>yarn.lock</code> 中获取版本信息, 若获取不到, 则从远程仓库获取满足版本规则的最高版本的版本信息.</li>\n<li>通过步骤 b 最终得到所有依赖的具体版本信息和下载地址.</li>\n</ol>\n</li>\n<li>\n<p>Fetching</p>\n<p>检查缓存中是否存在当前依赖包, 对于不存在的包会维护一个 fetch 队列, 将依赖包下载到缓存目录.</p>\n</li>\n<li>\n<p>Linking</p>\n<p>将依赖包从缓存目录 <strong>扁平化</strong> 复制到项目 <code>node_modules</code> 下.</p>\n</li>\n<li>\n<p>Building</p>\n<p>对存在二进制包的依赖包进行编译.</p>\n</li>\n</ol>\n<h2 id=\"依赖嵌套问题\" style=\"position:relative;\"><a href=\"#%E4%BE%9D%E8%B5%96%E5%B5%8C%E5%A5%97%E9%97%AE%E9%A2%98\" aria-label=\"依赖嵌套问题 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>依赖嵌套问题</h2>\n<h3 id=\"早期-npm-的树形依赖\" style=\"position:relative;\"><a href=\"#%E6%97%A9%E6%9C%9F-npm-%E7%9A%84%E6%A0%91%E5%BD%A2%E4%BE%9D%E8%B5%96\" aria-label=\"早期 npm 的树形依赖 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>早期 NPM 的树形依赖</h3>\n<p>早期 NPM 的依赖包采用自然的树形依赖: 将项目的直接依赖放到项目 <code>node_modules</code> 根目录, 若直接依赖 A 还依赖模块 B, 则将模块 B 放在模块 A 的 <code>node_modules</code> 下. 在稍复杂的项目中形成“嵌套地狱”:</p>\n<ul>\n<li>依赖树层级过深, 一方面难以调试, 另一方面可能出现文件路径过长导致的一些问题;</li>\n<li>依赖树的不同分支可能存在重复的依赖包, 导致安装过慢、浪费空间.</li>\n</ul>\n<h3 id=\"扁平化依赖\" style=\"position:relative;\"><a href=\"#%E6%89%81%E5%B9%B3%E5%8C%96%E4%BE%9D%E8%B5%96\" aria-label=\"扁平化依赖 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>扁平化依赖</h3>\n<p>对于没有版本冲突的依赖包, 扁平化地将依赖包放在 <code>node_modules</code> 根目录.</p>\n<p>存在版本冲突时则嵌套安装, 如 模块 A 依赖 模块 B-v1.0 , 模块 C 依赖 模块 B-v2.0 , 则将 模块 B-v2.0 安装在 模块 C 的 <code>node_modules</code> 中.</p>\n<p>冲突模块 B 不同版本的安装路径取决于模块 A 和 C 的安装顺序, 先安装的版本放在根目录.</p>\n<p>此时, 依赖包的安装顺序对依赖树影响很大: 若 模块 A 依赖 模块 B-v1.0 , 而 模块 C、D、E 都依赖 模块 B-2.0 , 则会导致 C、D、E 模块下都存在重复性的 模块 B-v2.0 .</p>\n<p>执行 <code>npm dedupe</code> 会尝试通过将依赖关系向上移动来尽可能删除重复依赖.</p>\n<p>Yarn 则会在安装依赖时自动执行 <code>dedupe</code> 命令.</p>","frontmatter":{"title":"NPM/Yarn包管理策略与最佳实践","date":"July 25, 2021","description":"详解npm包的安装机制和依赖管理策略, 并提出适用于团队的NPM最佳实践"}},"previous":{"fields":{"slug":"/http-1/"},"frontmatter":{"title":"HTTP之一：通识"}},"next":{"fields":{"slug":"/http-2/"},"frontmatter":{"title":"HTTP之二：HTTP Headers"}}},"pageContext":{"id":"b30c72fb-0f1d-5dd1-ab70-c98c5fa4ac3c","previousPostId":"9daf0fea-060c-53a0-a56b-4b40ea7eded5","nextPostId":"79d2e07e-9544-55b6-a161-bf95ddf8e04d"}},"staticQueryHashes":["2841359383","3257411868"]}