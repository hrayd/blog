{"componentChunkName":"component---src-templates-blog-post-js","path":"/http-3/","result":{"data":{"site":{"siteMetadata":{"title":"按太阳穴轮刮眼眶"}},"markdownRemark":{"id":"cc5d8afd-d1ac-544d-968c-8e5a2eab50ea","excerpt":"SSL/TLS 常识 OpenSSL 机密性: 对称加密与非对称加密 对称加密 非对称加密 混合加密 完整性和身份认证 完整性: 摘要算法 身份认证: 数字签名 公钥的可信性: 数字证书 TLS1.2 的握手过程 基于 ECDHE 密钥交换算法的握手过程 传统的基于 RSA 的握手过程 双向认证 TLS1.…","html":"<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#ssltls-%E5%B8%B8%E8%AF%86\">SSL/TLS 常识</a></p>\n<ul>\n<li><a href=\"#openssl\">OpenSSL</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%E6%9C%BA%E5%AF%86%E6%80%A7-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86\">机密性: 对称加密与非对称加密</a></p>\n<ul>\n<li><a href=\"#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86\">对称加密</a></li>\n<li><a href=\"#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86\">非对称加密</a></li>\n<li><a href=\"#%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86\">混合加密</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81\">完整性和身份认证</a></p>\n<ul>\n<li><a href=\"#%E5%AE%8C%E6%95%B4%E6%80%A7-%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95\">完整性: 摘要算法</a></li>\n<li><a href=\"#%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D\">身份认证: 数字签名</a></li>\n<li><a href=\"#%E5%85%AC%E9%92%A5%E7%9A%84%E5%8F%AF%E4%BF%A1%E6%80%A7-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6\">公钥的可信性: 数字证书</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#tls12-%E7%9A%84%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B\">TLS1.2 的握手过程</a></p>\n<ul>\n<li><a href=\"#%E5%9F%BA%E4%BA%8E-ecdhe-%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95%E7%9A%84%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B\">基于 ECDHE 密钥交换算法的握手过程</a></li>\n<li><a href=\"#%E4%BC%A0%E7%BB%9F%E7%9A%84%E5%9F%BA%E4%BA%8E-rsa-%E7%9A%84%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B\">传统的基于 RSA 的握手过程</a></li>\n<li><a href=\"#%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81\">双向认证</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#tls13\">TLS1.3</a></p>\n<ul>\n<li><a href=\"#%E5%85%BC%E5%AE%B9%E6%80%A7\">兼容性</a></li>\n<li><a href=\"#%E5%AE%89%E5%85%A8\">安全</a></li>\n<li><a href=\"#%E6%80%A7%E8%83%BD\">性能</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#https-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96\">HTTPS 的性能优化</a></p>\n<ul>\n<li><a href=\"#%E5%BD%B1%E5%93%8D-https-%E6%80%A7%E8%83%BD%E7%9A%84%E4%B8%BB%E8%A6%81%E5%9B%A0%E7%B4%A0\">影响 HTTPS 性能的主要因素</a></li>\n<li><a href=\"#%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96\"><strong>硬件优化</strong></a></li>\n<li><a href=\"#%E8%BD%AF%E4%BB%B6%E5%8D%87%E7%BA%A7\"><strong>软件升级</strong></a></li>\n<li><a href=\"#%E5%8D%8F%E8%AE%AE%E4%BC%98%E5%8C%96\"><strong>协议优化</strong></a></li>\n<li><a href=\"#%E8%AF%81%E4%B9%A6%E4%BC%98%E5%8C%96\"><strong>证书优化</strong></a></li>\n<li><a href=\"#%E4%BC%9A%E8%AF%9D%E5%A4%8D%E7%94%A8session-ticket\">会话复用(Session Ticket)</a></li>\n<li><a href=\"#%E9%A2%84%E5%85%B1%E4%BA%AB%E5%AF%86%E9%92%A5pre-shared-key\">预共享密钥(Pre-shared Key)</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<p>HTTP 不安全: 明文传输, 任何人都能在链路中截取修改, 伪造请求/响应报文.</p>\n<p><strong>安全</strong> 的四个特性:</p>\n<ul>\n<li>机密性: 非可信人不可见</li>\n<li>完整性: 传输过程无窜改丢失</li>\n<li>身份认证: 确保消息只能发送给指定身份</li>\n<li>不可否认: 保证事务的真实性</li>\n</ul>\n<p><strong>HTTPS</strong> 为 HTTP 添加了以上四个安全特性.</p>\n<p>HTTPS 除了协议名与默认端口 443, 协议的具体内容结构完全沿用 HTTP.</p>\n<p>HTTPS 中的\"S\"表示将 HTTP 下层的传输协议由 <strong>TCP/IP</strong> 换成了 <strong>SSL/TLS</strong> , 收发报文不再使用 Socket API, 而是调用专门的安全接口.</p>\n<h2 id=\"ssltls-常识\" style=\"position:relative;\"><a href=\"#ssltls-%E5%B8%B8%E8%AF%86\" aria-label=\"ssltls 常识 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SSL/TLS 常识</h2>\n<p>SSL(Secure Sockets Layer)由网景公司发明, 在 v3 版本时被正式标准化并更名为 TLS(Transport Layer Security). TLS1.0 即 SSLv3.1</p>\n<p>TLS 已发布了 1.1(2006), 1.2(2008)和 1.3(2018)三个版本, 目前使用最广泛的是 TLS1.2.</p>\n<p>TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成， 综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。</p>\n<p>客户端和服务器各自都支持很多加密算法组合, 这些算法组合称为 <strong>密码套件(cipher suite)</strong> .</p>\n<p>密码套件由特定顺序的算法名称构成, 格式为 <code>密钥交换算法-签名算法-对称加密算法-摘要算法</code>. 如:</p>\n<p>密码套件 <code>ECDHE-RSA-AES256-GCM-SHA384</code> 表示 \"握手时使用 <code>ECDHE</code> 算法进行密钥交换，用 <code>RSA</code> 签名和身份认证，握手后的通信使用 <code>AES</code> 对称算法，密钥长度 256 位，分组模式是 <code>GCM</code>，摘要算法 <code>SHA384</code> 用于消息认证和 产生随机数\".</p>\n<p>在客户端和服务器使用 TLS 建立连接时, 会进行协商, 选择一组恰当的密码套件来进行安全通信.</p>\n<h3 id=\"openssl\" style=\"position:relative;\"><a href=\"#openssl\" aria-label=\"openssl permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OpenSSL</h3>\n<p>开源的密码学程序库和工具包, 是 SSL/TLS 的具体实现. 几乎支持所有公开的加密算法和协议, 是事实上的标准.</p>\n<p>Nginx, Apache 等常用服务器和软件都使用 OpenSSL 实现 TLS 功能.</p>\n<h2 id=\"机密性-对称加密与非对称加密\" style=\"position:relative;\"><a href=\"#%E6%9C%BA%E5%AF%86%E6%80%A7-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86\" aria-label=\"机密性 对称加密与非对称加密 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>机密性: 对称加密与非对称加密</h2>\n<h3 id=\"对称加密\" style=\"position:relative;\"><a href=\"#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86\" aria-label=\"对称加密 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>对称加密</h3>\n<p>指加密和解密使用同一个密钥</p>\n<p>TLS 中常用的对称加密算法:</p>\n<ul>\n<li>AES: 应用最广泛的对称加密算法, 密钥长度可以 128,192 或 256 位, 安全性和性能都高</li>\n<li>ChaCha20: Google 设计, 密钥长度固定 256 位, 纯软件性能优于 AES, 但 AES 具有硬件优化, 所以目前相比 AES 不具有明显优势.</li>\n</ul>\n<p>分组模式: 使算法可以用固定长度的密钥加密任意长度的明文, 最新的分组模式称为 <strong>AEAD</strong> , 加密的同时添加了认证功能, 常用的有: <code>GCM</code> <code>CCM</code> <code>Poly1305</code> .</p>\n<p>对称加密算法 + 分组模式构成了 TLS 密码套件中定义的对称加密算法, 如:</p>\n<ul>\n<li><code>AES128-GCM</code> 128 位密钥长度的 AES 算法, 分组模式是 GCM</li>\n<li><code>ChaCha20-Poly1305</code> ChaCha20 算法, 分组模式是 Poly1305</li>\n</ul>\n<h3 id=\"非对称加密\" style=\"position:relative;\"><a href=\"#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86\" aria-label=\"非对称加密 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>非对称加密</h3>\n<p>对称加密的问题: 密钥交换过程难以保障机密性.</p>\n<p>非对称加密: 具有公钥和私钥, 公钥加密只能私钥解密, 私钥加密只能公钥解密.</p>\n<ul>\n<li>公钥: 可以公开给任何人, 任何人都可以加密</li>\n<li>私钥: 必须严格保密, 用于解密</li>\n<li>私钥加密公钥解密用于后文的 <strong>数字签名</strong></li>\n</ul>\n<p>非对称加密算法设计比对称算法难得多, TLS 只有少数几种, 常用:</p>\n<ul>\n<li>RSA: 最有名的对称加密算法, 基于\"整数分解\"数学难题, 使用两个超大素数乘积作为生成密钥的材料, 推荐长度 1024, 目前普遍认为至少 2048 位.</li>\n<li>\n<p>ECC: 基于\"椭圆曲线离散对数\", 用特定的曲线方程和基点生成公私钥, 在安全强度和性能上都明显就优于 RSA, 160 位 ECC 相当于 1024 位 RSA, 密钥短意味着计算量和所需内存带宽就少. 常用曲线:</p>\n<ul>\n<li>P-256: NIST 和 NSA 推荐使用, 密码学界不信任</li>\n<li>x25519: 被认为是最安全最快速的曲线</li>\n<li>secp256k1: 比特币, 以太坊灯区块链技术中使用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"混合加密\" style=\"position:relative;\"><a href=\"#%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86\" aria-label=\"混合加密 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>混合加密</h3>\n<p>非对称加密虽然没有\"密钥交换\"问题, 但运算速度通常比对称加密慢好几个数量级, 经试验 ECC 比 AES 慢了好几百倍.</p>\n<p>TLS 中使用的 <strong>混合加密</strong> : 通信开始时使用非对称加密进行密钥交换, 之后使用对称加密.</p>\n<h2 id=\"完整性和身份认证\" style=\"position:relative;\"><a href=\"#%E5%AE%8C%E6%95%B4%E6%80%A7%E5%92%8C%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81\" aria-label=\"完整性和身份认证 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>完整性和身份认证</h2>\n<ul>\n<li>完整性问题: 如何保证接收到的消息没有被篡改?</li>\n<li>身份认证: 如何确保通信双方身份真实可信?</li>\n</ul>\n<h3 id=\"完整性-摘要算法\" style=\"position:relative;\"><a href=\"#%E5%AE%8C%E6%95%B4%E6%80%A7-%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95\" aria-label=\"完整性 摘要算法 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>完整性: 摘要算法</h3>\n<p><strong>摘要算法</strong>: 即散列/哈希函数, 将任意长度数据压缩成固定长度且唯一的字符串.</p>\n<p>单向算法, 无法解密逆推原文.</p>\n<p>常用摘要算法:</p>\n<ul>\n<li>MD5, SHA-1, 安全强度较低, 在 TLS 已禁用</li>\n<li>SHA-2: TLS 推荐使用, 是六种摘要算法的统称, 常用: <code>SHA224</code> <code>SHA256</code> <code>SHA384</code></li>\n</ul>\n<p>完整性校验: 原文+摘要, 通过原文计算摘要并进行对比.</p>\n<p>摘要算法不具备机密性, 建立在机密性之上的完整性: 用会话密钥加密消息和摘要.</p>\n<h3 id=\"身份认证-数字签名\" style=\"position:relative;\"><a href=\"#%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D\" aria-label=\"身份认证 数字签名 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>身份认证: 数字签名</h3>\n<p>签名: 使用非对称加密的 <strong>私钥</strong> 来加密 <strong>摘要</strong> , 得到 <strong>数字签名</strong>.</p>\n<p>验签: 数字签名与公钥一样公开, 只有与私钥对应的公钥才能解密得到摘要, 再对比原文验证完整性, 就可以确保通信双方身份和通信内容正确.</p>\n<blockquote>\n<p>一般可以用时间戳和随机数结合做不可逆签名, 避免请求被拦截并重复发送.</p>\n</blockquote>\n<h3 id=\"公钥的可信性-数字证书\" style=\"position:relative;\"><a href=\"#%E5%85%AC%E9%92%A5%E7%9A%84%E5%8F%AF%E4%BF%A1%E6%80%A7-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6\" aria-label=\"公钥的可信性 数字证书 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>公钥的可信性: 数字证书</h3>\n<p>如何确保得到的公钥就是指定通信方的公钥? 只能通过第三方构建公钥的信任链.</p>\n<p>这个第三方就是 <strong>CA</strong>, 即 Certificate Authority, 证书认证机构.</p>\n<p>CA 对各公钥进行签名, 用自己的信誉保证公钥可信. CA 机构有: DigiCert、VeriSign、Entrust、Let’s Encrypt 等.</p>\n<blockquote>\n<p>Let's Encrypt 可颁发免费的 90 天的 DV 证书, 可以用 Certbot 自动续订.</p>\n</blockquote>\n<p>CA 将公钥,序列表,用途,颁发者,有效时间等公钥关联信息打包并签名, 形成 <strong>数字证书</strong> .</p>\n<p>证书分类:</p>\n<ul>\n<li>DV: 可信度最低, 域名级可信</li>\n<li>OV: 可信度在中间</li>\n<li>EV: 可信度最高, 经过法律和审计的核查可证明网站拥有者身份, 浏览器地址栏会显示公司名称</li>\n</ul>\n<p>CA 的信任链: 小的 CA 通过大 CA 进行签名认证, 但最终的 <strong>Root CA</strong> 只能通过 <strong>自签名证书</strong> 或 <strong>根证书</strong> 自己证明自己.</p>\n<p>操作系统和浏览器内置了各大 CA 的根证书, 对于服务器发送的证书, 可以顺着证书链层层校验直到找到根证书, 就能够确定证书可信.</p>\n<p>证书体系(PKI)弱点: 如果 CA 主动或被动颁发了错误证书, 如何弥补?</p>\n<ul>\n<li>CRL: Certificate revocation list, 证书吊销列表</li>\n<li>OCSP: Online certificate status protocol, 在线证书状态协议</li>\n<li>终止信任: 直接从操作系统或浏览器中撤销对根 CA 的信任</li>\n</ul>\n<h2 id=\"tls12-的握手过程\" style=\"position:relative;\"><a href=\"#tls12-%E7%9A%84%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B\" aria-label=\"tls12 的握手过程 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TLS1.2 的握手过程</h2>\n<h3 id=\"基于-ecdhe-密钥交换算法的握手过程\" style=\"position:relative;\"><a href=\"#%E5%9F%BA%E4%BA%8E-ecdhe-%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95%E7%9A%84%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B\" aria-label=\"基于 ecdhe 密钥交换算法的握手过程 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>基于 ECDHE 密钥交换算法的握手过程</h3>\n<blockquote>\n<p>ECDHE: 使用椭圆曲线增强的非对称加密 DH 算法, 公钥私钥都是临时生成的.</p>\n</blockquote>\n<ol>\n<li>\n<p>客户端向服务器发送 \"Client Hello\" 消息:</p>\n<ul>\n<li><code>Version</code> 客户端 TLS 版本号 <code>TLS 1.2 (0x0303)</code></li>\n<li><code>Random</code> 客户端随机数, 用于后续生成会话秘钥</li>\n<li><code>Cipher Suites</code> 客户端支持的密码套件列表</li>\n</ul>\n<pre><code>// 抓包数据\nHandshake Protocol: Client Hello\n   Version: TLS 1.2 (0x0303)\n   Random: 1cbf803321fd2623408dfe...\n   Cipher Suites (17 suites)\n       Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)\n       Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)\n</code></pre>\n</li>\n<li>\n<p>服务器向客户端返回 \"Server Hello\" 消息:</p>\n<ul>\n<li><code>Version</code> 确认 TLS 版本号</li>\n<li><code>Random</code> 服务器随机数</li>\n<li><code>Cipher Suite</code> 从客户端的密码套件列表中选择一项作为本次通信使用的密码套件</li>\n<li><code>Server Certificate</code> 服务器证书</li>\n<li><code>Server Params</code> 密钥交换算法参数 + 私钥签名认证</li>\n<li>\"Server Hello Done\"</li>\n</ul>\n<pre><code>// 抓包数据\nHandshake Protocol: Server Hello\n    Version: TLS 1.2 (0x0303)\n Random: 0e6320f21bae50842e96...\n Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)\nHandshake Protocol: Server Key Exchange\n    EC Diffie-Hellman Server Params\n    Curve Type: named_curve (0x03)\n    Named Curve: x25519 (0x001d)\n    Pubkey: 3b39deaf00217894e...\n    Signature Algorithm: rsa_pkcs1_sha512 (0x0601)\n    Signature: 37141adac38ea4...\n</code></pre>\n</li>\n<li>\n<p>客户端通过证书链确认证书的真实性, 再用证书公钥验证签名, 得到 <code>Server Params</code>. 同时客户端也生成一个 <code>Client Params</code> (密钥交换算法参数)发送给服务器:</p>\n<pre><code>Handshake Protocol: Client Key Exchange\n    EC Diffie-Hellman Client Params\n        Pubkey: 8c674d0e08dc27b5eaa...\n</code></pre>\n<p>此时客户端和服务器都得到了密钥交换算法的两个参数 <code>Client Params</code> 和 <code>Server Params</code> .</p>\n<p>客户端和服务端各自利用这两个参数经密钥交换算法(ECDHE)计算得到随机数 <code>Pre-Master</code> .</p>\n<p>再将得到的三个随机数 <code>Client Random</code> <code>Server Random</code> <code>Pre-Master</code> 作为参数, 通过密码套件中的伪随机函数计算得到加密会话的 48 字节的主秘钥 <code>Master Secret</code> .</p>\n<p>再通过 <code>PRF</code> 扩展出 <code>client_write_key</code> 和 <code>server_write_key</code> 等会话秘钥.</p>\n</li>\n<li>\n<p>客户端再次向服务器发送两个消息:</p>\n<ul>\n<li><code>Change Cipher Spec</code> 通知服务器之后改用会话秘钥加密通信</li>\n<li><code>Finished</code> 之前的所有握手数据进行摘要加密, 发送给服务器进行确认</li>\n<li>使用 ECDHE 实现密钥交换算法时, 此时可以将 HTTP 请求一同发送</li>\n</ul>\n</li>\n<li>\n<p>服务器验证握手数据摘要, 并发送消息进行确认:</p>\n<ul>\n<li><code>Change Cipher Spec</code> 之后改用会话秘钥加密通信</li>\n<li><code>Finished</code> 所有握手数据的摘要</li>\n<li>使用 ECDHE 时可一同发送 HTTP 响应</li>\n</ul>\n</li>\n<li>握手正式结束, 之后收发加密的 HTTP 请求和响应.</li>\n</ol>\n<h3 id=\"传统的基于-rsa-的握手过程\" style=\"position:relative;\"><a href=\"#%E4%BC%A0%E7%BB%9F%E7%9A%84%E5%9F%BA%E4%BA%8E-rsa-%E7%9A%84%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B\" aria-label=\"传统的基于 rsa 的握手过程 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>传统的基于 RSA 的握手过程</h3>\n<p>与基于 ECDHE 的握手过程类似, 只是 <code>Pre-Master</code> 不需要通过算法生成, 而是由客户端直接生成随机数, 经服务器公钥加密后通过 \"Client Key Exchange\" 消息发给服务器, 服务器用私钥解密后双方就实现了共享三个随机数, 生成主秘钥.</p>\n<h3 id=\"双向认证\" style=\"position:relative;\"><a href=\"#%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81\" aria-label=\"双向认证 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>双向认证</h3>\n<p>TLS 握手只认证了服务器的身份, 之后可以通过账号, 密码, 验证码等进行客户端身份认证.</p>\n<p>对于高安全性场景下, 会使用 U 盾给用户颁发客户端证书, 实现 <strong>双向认证</strong> .</p>\n<p>双向认证是在 TLS 握手的 \"Server Hello Done\" 和 \"Client Key Exchange\" 之间, 由客户端向服务器发送 \"Client Certificate\" 消息, 服务器收到证书后根据证书链验证客户端身份.</p>\n<h2 id=\"tls13\" style=\"position:relative;\"><a href=\"#tls13\" aria-label=\"tls13 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TLS1.3</h2>\n<p>TLS1.3 的主要改进目标: 兼容、安全、性能.</p>\n<p>目前各大浏览器和服务器都支持了 TLS1.3</p>\n<h3 id=\"兼容性\" style=\"position:relative;\"><a href=\"#%E5%85%BC%E5%AE%B9%E6%80%A7\" aria-label=\"兼容性 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>兼容性</h3>\n<p>在早期试验中, 一旦将 TLS 头字段中的 <code>Version</code> 改为 TLS1.3(0x304), 会导致大量服务器、网关无法处理, 导致 TLS 握手失败.</p>\n<p>为了兼容性, TLS1.3 仍然使用 TLS1.2 的格式, 通过在记录末尾添加一系列扩展字段来增加新功能, 如在握手的 “Hello” 消息后必须有 <code>supported_versions</code> 字段来标记 TLS 版本号:</p>\n<pre><code class=\"language-jsx\">Handshake Protocol: Client Hello\n    Version: TLS 1.2 (0x0303)\n    Extension: supported_versions (len=11)\n        Supported Version: TLS 1.3 (0x0304)\n        Supported Version: TLS 1.2 (0x0303)\n</code></pre>\n<p>TLS1.3 的很多功能都是通过扩展字段实现的, 见下文的 <strong>性能</strong> 部分.</p>\n<h3 id=\"安全\" style=\"position:relative;\"><a href=\"#%E5%AE%89%E5%85%A8\" aria-label=\"安全 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>安全</h3>\n<p>TLS1.3 修补了 TLS1.2 中的很多不安全因素, 升级了一些加密算法, 也废除了很多被证明不安全的算法, 最终只保留了:</p>\n<ul>\n<li>对称加密算法: AES、ChaCha20</li>\n<li>分组模式: AEAD 的 GCM、CCM 和 Poly1305</li>\n<li>摘要算法: SHA256、SHA384</li>\n<li>密钥交换算法: ECDHE、DHE</li>\n<li>椭圆曲线: P-256、x25519 等 5 种</li>\n</ul>\n<p>加密套件也只有 5 个, 有利于客户端和服务器的选择.</p>\n<blockquote>\n<p>使用 ECDHE 替代 RSA 的原因: RSA 不具备“前项安全”, 一旦拿到了私钥, 就能够破解之前所有的密文. 而 ECDHE 每次握手都生成临时的公私钥, 就算被破解, 也只是一次通信.</p>\n</blockquote>\n<h3 id=\"性能\" style=\"position:relative;\"><a href=\"#%E6%80%A7%E8%83%BD\" aria-label=\"性能 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>性能</h3>\n<p>将 TLS1.2 的 两个消息往返减少为 1 个(1-RTT), 效率提升了一倍.</p>\n<blockquote>\n<p>TLS1.3 的握手过程中, 客户端在 “Client Hello”中直接在扩展字段 “supported<em>groups\" 中写明支持的曲线, 并在 “key</em>share\" 中附带曲线对应的客户端公钥参数, 用 “signature<em>algorithms“ 带上签名算法; 服务器收到后选定一个曲线和参数, 再用 “key</em>share\" 返回服务器的公钥参数, 就实现了密钥交换. 之后的流程与 TLS1.2 相同.</p>\n</blockquote>\n<p>除此之外, TLS1.3 还引入了 “0-RTT” 握手, 满足一些条件时可以在 TCP 连接后立即建立安全连接发送加密消息.</p>\n<h2 id=\"https-的性能优化\" style=\"position:relative;\"><a href=\"#https-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96\" aria-label=\"https 的性能优化 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTPS 的性能优化</h2>\n<h3 id=\"影响-https-性能的主要因素\" style=\"position:relative;\"><a href=\"#%E5%BD%B1%E5%93%8D-https-%E6%80%A7%E8%83%BD%E7%9A%84%E4%B8%BB%E8%A6%81%E5%9B%A0%E7%B4%A0\" aria-label=\"影响 https 性能的主要因素 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>影响 HTTPS 性能的主要因素</h3>\n<p>分析 TLS 握手过程可知, HTTPS 中较为影响性能的过程有:</p>\n<ul>\n<li>比 HTTP 增加的 TLS 握手过程, 两个消息往返即 2-RTT;</li>\n<li>产生(计算)用于密钥交换的临时公私钥对;</li>\n<li>验证证书过程: 访问 CA 获取 CRL 或 OCSP;</li>\n<li>非对称加解密(计算) “Pre-Master\".</li>\n</ul>\n<h3 id=\"硬件优化\" style=\"position:relative;\"><a href=\"#%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96\" aria-label=\"硬件优化 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>硬件优化</strong></h3>\n<p>HTTPS 连接是计算密集型而非 I/O 密集型, 所以提升网卡、带宽和存储作用不大.</p>\n<ul>\n<li>更快的 CPU, 可内建 AES 优化来加速握手和传输;</li>\n<li>SSL 加速卡, 使用专门的硬件做非对称加解密;</li>\n<li>SSL 加速服务器, 专用于 TLS 加解密计算的服务器集群, 性能强大.</li>\n</ul>\n<h3 id=\"软件升级\" style=\"position:relative;\"><a href=\"#%E8%BD%AF%E4%BB%B6%E5%8D%87%E7%BA%A7\" aria-label=\"软件升级 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>软件升级</strong></h3>\n<p>升级 Linux 内核、Nginx、OpenSSL 版本等;</p>\n<h3 id=\"协议优化\" style=\"position:relative;\"><a href=\"#%E5%8D%8F%E8%AE%AE%E4%BC%98%E5%8C%96\" aria-label=\"协议优化 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>协议优化</strong></h3>\n<ul>\n<li>尽量采用 TLS1.3, 完全握手只需 1-RTT;</li>\n<li>\n<p>若只能用 TLS1.2, 可在服务器中配置:</p>\n<ul>\n<li>尽量选用椭圆曲线的 ECDHE 算法, 把握手过程减少到 1-RTT;</li>\n<li>椭圆曲线可选择高性能的 x25519 曲线;</li>\n<li>对称加密算法可采用“AES<em>128</em>GCM\".</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"证书优化\" style=\"position:relative;\"><a href=\"#%E8%AF%81%E4%B9%A6%E4%BC%98%E5%8C%96\" aria-label=\"证书优化 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>证书优化</strong></h3>\n<ul>\n<li>证书传输过程: 可以使用 ECDSA 证书而非 RSA 证书, 节约带宽;</li>\n<li>证书验证过程: 可以使用 “OCSP Stapling”是服务器预先访问 CA 获取 OCSP 响应并发给客户端, 免去客户端连接 CA 验证证书的过程.</li>\n</ul>\n<h3 id=\"会话复用session-ticket\" style=\"position:relative;\"><a href=\"#%E4%BC%9A%E8%AF%9D%E5%A4%8D%E7%94%A8session-ticket\" aria-label=\"会话复用session ticket permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>会话复用(Session Ticket)</h3>\n<p>HTTPS 建立连接时, 先是 TCP 三次握手, 再是 TLS 一次握手, 同时每次连接都要重新计算主密钥, 很影响性能. 可以通过 <strong>会话复用</strong> 在一次会话中缓存主密钥.</p>\n<p>会话复用分为两种:</p>\n<ul>\n<li>\n<p><strong>Session ID</strong>: 客户端和服务器首次连接后各自保存一个会话 ID, 并存储主密钥和其他信息; 当再次连接时可以用主密钥恢复会话状态, 跳过证书验证和密钥交换, 用一个消息往返建立安全通信.</p>\n<ul>\n<li>缺点: 对于超大用户量级别的网站来说, 服务器负担过大.</li>\n</ul>\n</li>\n<li>\n<p><strong>Session Ticket</strong>: 服务端向客户端发送 “New Session Ticket”, 由客户端保存; 再次连接时, 客户端使用 “session_ticket\" 发送 “Ticket”, 有服务器解密验证后可以恢复会话开始加密通信.</p>\n<ul>\n<li>需要一个固定的密钥文件来加密 Ticket, 为了保证前向安全, 此密钥文件需要定期轮换.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"预共享密钥pre-shared-key\" style=\"position:relative;\"><a href=\"#%E9%A2%84%E5%85%B1%E4%BA%AB%E5%AF%86%E9%92%A5pre-shared-key\" aria-label=\"预共享密钥pre shared key permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>预共享密钥(Pre-shared Key)</h3>\n<p>原理与 <strong>Session Ticket</strong> 类似, 发送 Ticket 时会同时带上 <strong>Early Data</strong> , 从而实现“0-RTT”.</p>\n<p>但牺牲了安全性, 权衡方案是只允许安全的 GET/HEAD 方法, 并在消息中加入时间戳、“nonce”验证或“一次性票证”.</p>","frontmatter":{"title":"HTTP之三：安全的HTTPS","date":"August 25, 2021","description":"HTTPS = HTTP + SSL/TLS, 本文研究了对称加密和非对称加密算法的特性, 对HTTPS的数字签名和数字证书、TLS1.2的握手过程以及TLS1.3的改良之处进行了描述, 并分析了HTTPS在不同维度下的性能优化方式."}},"previous":{"fields":{"slug":"/http-2/"},"frontmatter":{"title":"HTTP之二：HTTP Headers"}},"next":{"fields":{"slug":"/html-pickup/"},"frontmatter":{"title":"HTML拾遗"}}},"pageContext":{"id":"cc5d8afd-d1ac-544d-968c-8e5a2eab50ea","previousPostId":"79d2e07e-9544-55b6-a161-bf95ddf8e04d","nextPostId":"ef71ee56-83e0-5b94-a891-f6d4118c0f7f"}},"staticQueryHashes":["2841359383","3257411868"]}